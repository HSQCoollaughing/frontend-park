(window["webpackJsonp_frontend-park"]=window["webpackJsonp_frontend-park"]||[]).push([["chunk-775a2954"],{"011b":function(e,t,n){"use strict";n.d(t,"a",(function(){return d}));var r=n("76c2"),a=n("a3f7"),s=n("c77c"),o=n("b9b9"),i=n("54ef"),c=n("6791"),u=n("a09b");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function l(e,t){let n=Object(a["a"])(e,"a","div"),i=Object(a["a"])(t,"b","div");[n,i]=Object(r["makeTypesMatch"])(n,i);const l=Object(s["a"])(n,i),d=Object(u["a"])(l),p=Object(o["a"])(i,d);return Object(c["a"])(p,d,l)}const d=Object(i["b"])({divNoNan_:l})},"015f":function(e,t,n){"use strict";n.d(t,"a",(function(){return s}));var r=n("6ad5"),a=n("5959");
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function s(e,t){if((Object(r["A"])(e)&&"string"!==t||Array.isArray(e))&&"complex64"!==t)throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");if("string"===t&&Object(r["A"])(e)&&!(e instanceof Uint8Array))throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");const n=[],s=[];return Object(a["a"])(e,n,s,t)}},"0280":function(e,t,n){"use strict";n.d(t,"a",(function(){return a}));var r=n("043e");
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function a(e,t){const n=[];for(let r=0;r<t.length;r++)t[r]&&n.push(r);const a=Object(r["a"])(e,"int32"),s=Object(r["a"])([n.length,e.length],"int32");for(let r=0;r<n.length;r++){const t=a.indexToLoc(n[r]),o=r*e.length;s.values.set(t,o)}return s.toTensor()}},"043e":function(e,t,n){"use strict";n.d(t,"a",(function(){return s}));var r=n("34d7"),a=n("6ad5");
/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function s(e,t="float32",n){return t=t||"float32",a["c"](e),new r["b"](e,t,n)}},"04b8":function(e,t,n){"use strict";n.r(t),n.d(t,"json",(function(){return r}));
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const r=[{tfOpName:"Fill",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"},{start:1,name:"value",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"LinSpace",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"num",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"OneHot",category:"creation",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"depth",type:"number"},{start:2,name:"onValue",type:"number",defaultValue:1},{start:3,name:"offValue",type:"number",defaultValue:0}],attrs:[{tfName:"axis",name:"axis",type:"number",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Ones",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"OnesLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"RandomUniform",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number",defaultValue:0},{tfName:"maxval",name:"maxval",type:"number",defaultValue:1},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Range",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"step",type:"number",defaultValue:0}],attrs:[{tfName:"Tidx",name:"dtype",type:"dtype"}]},{tfOpName:"TruncatedNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"means",name:"mean",type:"number",defaultValue:0},{tfName:"stddev",name:"stdDev",type:"number",defaultValue:1},{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Zeros",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"ZerosLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Multinomial",category:"creation",inputs:[{start:0,name:"logits",type:"tensor"},{start:1,name:"numSamples",type:"number"}],attrs:[{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number"},{tfName:"T",name:"dtype",type:"dtype"},{tfName:"output_dtype",name:"output_dtype",type:"dtype"}]}]},"04c4":function(e,t,n){"use strict";n.d(t,"a",(function(){return u}));var r=n("6ae2"),a=n("c05b"),s=n("a3f7"),o=n("6ad5"),i=n("54ef");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function c(e,t,n){const i=Object(s["a"])(e,"x","bincount"),c=Object(s["a"])(t,"weights","bincount");o["b"]("int32"===i.dtype,()=>"Error in bincount: input dtype must be int32, but got "+i.dtype),o["b"](n>=0,()=>`size must be non-negative, but got ${n}.`),o["b"](c.size===i.size||0===c.size,()=>`Error in bincount: weights must have the same size as input or0-length, but got input shape: ${i.shape}, weights shape: `+c.shape+".");const u={x:i,weights:c},l={size:n};return r["a"].runKernel(a["u"],u,l)}const u=Object(i["b"])({bincount_:c})},"05bb":function(e,t,n){"use strict";n.d(t,"a",(function(){return o}));var r=n("a3f7"),a=n("6ad5"),s=n("5959");
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function o(e,t,n){if(Object(a["d"])(e),null!=t&&3!==t.length)throw new Error("tensor3d() requires shape to have three numbers");const o=Object(r["c"])(e,n);if(3!==o.length&&1!==o.length)throw new Error("tensor3d() requires values to be number[][][] or flat/TypedArray");if(1===o.length&&null==t)throw new Error("tensor3d() requires shape to be provided when `values` are a flat array");return Object(s["a"])(e,t,o,n)}},"0777":function(e,t,n){"use strict";n.d(t,"a",(function(){return u}));var r=n("6ae2"),a=n("c05b"),s=n("a3f7"),o=n("6ad5"),i=n("54ef");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function c(e,t){const n=Object(s["a"])(e,"real","complex"),i=Object(s["a"])(t,"imag","complex");o["e"](n.shape,i.shape,`real and imag shapes, ${n.shape} and ${i.shape}, must match in call to tf.complex().`);const c={real:n,imag:i};return r["a"].runKernel(a["A"],c)}const u=Object(i["b"])({complex_:c})},"07d6":function(e,t){e.exports=function(){throw new Error("define cannot be used indirect")}},"08a9":function(e,t,n){"use strict";n.d(t,"a",(function(){return c}));var r=n("6ae2"),a=n("c05b"),s=n("a3f7"),o=n("54ef");
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function i(e){const t=Object(s["a"])(e,"x","round"),n={x:t};return r["a"].runKernel(a["xc"],n)}const c=Object(o["b"])({round_:i})},"09f4":function(e,t,n){"use strict";n.d(t,"a",(function(){return d}));var r=n("6ae2"),a=n("c05b"),s=n("76c2"),o=n("a3f7"),i=n("526f"),c=n("deb3"),u=n("54ef");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function l(e,t){let n=Object(o["a"])(e,"a","maximum"),u=Object(o["a"])(t,"b","maximum");[n,u]=Object(s["makeTypesMatch"])(n,u),"bool"===n.dtype&&(n=Object(c["a"])(n,"int32"),u=Object(c["a"])(u,"int32")),Object(i["a"])(n.shape,u.shape);const l={a:n,b:u};return r["a"].runKernel(a["Pb"],l)}const d=Object(u["b"])({maximum_:l})},"0db5":function(e,t,n){"use strict";n.d(t,"a",(function(){return c}));var r=n("6ae2"),a=n("c05b"),s=n("a3f7"),o=n("54ef");
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function i(e){const t=Object(s["a"])(e,"x","onesLike"),n={x:t};return r["a"].runKernel(a["dc"],n)}const c=Object(o["b"])({onesLike_:i})},"0eb5":function(e,t,n){"use strict";n.d(t,"a",(function(){return c}));var r=n("6ae2"),a=n("c05b"),s=n("a3f7"),o=n("54ef");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function i(e,t,n=0){const o=Object(s["a"])(e,"x","pad");if(0===o.rank)throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");const i={paddings:t,constantValue:n},c={x:o};return r["a"].runKernel(a["fc"],c,i)}const c=Object(o["b"])({pad_:i})},"113e":function(e,t,n){"use strict";n.r(t),n.d(t,"json",(function(){return r}));
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const r=[{tfOpName:"FFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"RFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]},{tfOpName:"IRFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]}]},1212:function(e,t,n){(function(e){var r;(function(e,a,s){function o(e){var t=this,n=u();t.next=function(){var e=2091639*t.s0+2.3283064365386963e-10*t.c;return t.s0=t.s1,t.s1=t.s2,t.s2=e-(t.c=0|e)},t.c=1,t.s0=n(" "),t.s1=n(" "),t.s2=n(" "),t.s0-=n(e),t.s0<0&&(t.s0+=1),t.s1-=n(e),t.s1<0&&(t.s1+=1),t.s2-=n(e),t.s2<0&&(t.s2+=1),n=null}function i(e,t){return t.c=e.c,t.s0=e.s0,t.s1=e.s1,t.s2=e.s2,t}function c(e,t){var n=new o(e),r=t&&t.state,a=n.next;return a.int32=function(){return 4294967296*n.next()|0},a.double=function(){return a()+11102230246251565e-32*(2097152*a()|0)},a.quick=a,r&&("object"==typeof r&&i(r,n),a.state=function(){return i(n,{})}),a}function u(){var e=4022871197,t=function(t){t=t.toString();for(var n=0;n<t.length;n++){e+=t.charCodeAt(n);var r=.02519603282416938*e;e=r>>>0,r-=e,r*=e,e=r>>>0,r-=e,e+=4294967296*r}return 2.3283064365386963e-10*(e>>>0)};return t}a&&a.exports?a.exports=c:n("07d6")&&n("3c35")?(r=function(){return c}.call(t,n,t,a),void 0===r||(a.exports=r)):this.alea=c})(0,e,n("07d6"))}).call(this,n("62e4")(e))},"122e":function(e,t,n){"use strict";n.d(t,"a",(function(){return c}));var r=n("6ae2"),a=n("c05b"),s=n("a3f7"),o=n("54ef");
/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function i(e,t=null,n=!1){const o=Object(s["a"])(e,"x","mean"),i={x:o},c={axis:t,keepDims:n};return r["a"].runKernel(a["Qb"],i,c)}const c=Object(o["b"])({mean_:i})},"132b":function(e,t,n){"use strict";n.d(t,"b",(function(){return a["a"]})),n.d(t,"c",(function(){return s["a"]})),n.d(t,"d",(function(){return o["a"]})),n.d(t,"e",(function(){return i["a"]})),n.d(t,"f",(function(){return c["a"]})),n.d(t,"g",(function(){return u["a"]})),n.d(t,"h",(function(){return l["a"]})),n.d(t,"i",(function(){return d["a"]})),n.d(t,"j",(function(){return p["a"]})),n.d(t,"k",(function(){return h["a"]})),n.d(t,"l",(function(){return f["a"]})),n.d(t,"m",(function(){return m["a"]})),n.d(t,"n",(function(){return b["a"]})),n.d(t,"o",(function(){return g["a"]})),n.d(t,"p",(function(){return y["a"]})),n.d(t,"q",(function(){return x["a"]})),n.d(t,"r",(function(){return T})),n.d(t,"w",(function(){return $["a"]})),n.d(t,"s",(function(){return E["a"]})),n.d(t,"t",(function(){return _})),n.d(t,"u",(function(){return D})),n.d(t,"v",(function(){return L})),n.d(t,"x",(function(){return P["a"]})),n.d(t,"z",(function(){return B["a"]})),n.d(t,"A",(function(){return V["a"]})),n.d(t,"B",(function(){return z["a"]})),n.d(t,"C",(function(){return W["a"]})),n.d(t,"D",(function(){return U["a"]})),n.d(t,"E",(function(){return G["a"]})),n.d(t,"F",(function(){return H["a"]})),n.d(t,"G",(function(){return q["a"]})),n.d(t,"H",(function(){return v["a"]})),n.d(t,"I",(function(){return X})),n.d(t,"J",(function(){return Q})),n.d(t,"K",(function(){return J})),n.d(t,"L",(function(){return te})),n.d(t,"M",(function(){return ne["a"]})),n.d(t,"N",(function(){return re["a"]})),n.d(t,"O",(function(){return ae["a"]})),n.d(t,"P",(function(){return se["a"]})),n.d(t,"Q",(function(){return pe})),n.d(t,"R",(function(){return he["a"]})),n.d(t,"S",(function(){return fe["a"]})),n.d(t,"U",(function(){return me["a"]})),n.d(t,"V",(function(){return be["a"]})),n.d(t,"W",(function(){return ge["a"]})),n.d(t,"X",(function(){return ye["a"]})),n.d(t,"Y",(function(){return Oe})),n.d(t,"Z",(function(){return ve["a"]})),n.d(t,"ab",(function(){return we["a"]})),n.d(t,"bb",(function(){return ke["a"]})),n.d(t,"cb",(function(){return Se})),n.d(t,"eb",(function(){return Ne["a"]})),n.d(t,"fb",(function(){return Ce["a"]})),n.d(t,"hb",(function(){return Ie["a"]})),n.d(t,"ib",(function(){return Te["a"]})),n.d(t,"jb",(function(){return $e["a"]})),n.d(t,"kb",(function(){return Ee["a"]})),n.d(t,"lb",(function(){return Ae["a"]})),n.d(t,"mb",(function(){return Fe})),n.d(t,"ob",(function(){return De["a"]})),n.d(t,"pb",(function(){return Me["a"]})),n.d(t,"qb",(function(){return Le["a"]})),n.d(t,"sb",(function(){return Pe["a"]})),n.d(t,"ub",(function(){return Be["a"]})),n.d(t,"vb",(function(){return Ve["a"]})),n.d(t,"xb",(function(){return ze["a"]})),n.d(t,"Bb",(function(){return Ue})),n.d(t,"Cb",(function(){return He})),n.d(t,"Db",(function(){return qe["a"]})),n.d(t,"Eb",(function(){return Ke["a"]})),n.d(t,"Fb",(function(){return Xe["a"]})),n.d(t,"Gb",(function(){return Ye["a"]})),n.d(t,"Ib",(function(){return Qe["a"]})),n.d(t,"Jb",(function(){return Ze["a"]})),n.d(t,"Kb",(function(){return Je["a"]})),n.d(t,"Lb",(function(){return et["a"]})),n.d(t,"Mb",(function(){return st})),n.d(t,"Nb",(function(){return ot["a"]})),n.d(t,"Ob",(function(){return pt})),n.d(t,"Pb",(function(){return ht["a"]})),n.d(t,"Qb",(function(){return ft["a"]})),n.d(t,"Rb",(function(){return mt["a"]})),n.d(t,"Sb",(function(){return yt})),n.d(t,"Ub",(function(){return w["a"]})),n.d(t,"Vb",(function(){return ct["a"]})),n.d(t,"Wb",(function(){return xt["a"]})),n.d(t,"Xb",(function(){return Ot["a"]})),n.d(t,"Yb",(function(){return vt["a"]})),n.d(t,"Zb",(function(){return wt["a"]})),n.d(t,"ac",(function(){return kt["a"]})),n.d(t,"bc",(function(){return Nt})),n.d(t,"cc",(function(){return Ct["a"]})),n.d(t,"dc",(function(){return It["a"]})),n.d(t,"ec",(function(){return Tt["a"]})),n.d(t,"fc",(function(){return $t["a"]})),n.d(t,"gc",(function(){return Rt})),n.d(t,"ic",(function(){return k["a"]})),n.d(t,"jc",(function(){return Ft})),n.d(t,"kc",(function(){return Dt["a"]})),n.d(t,"lc",(function(){return nt["a"]})),n.d(t,"nc",(function(){return Mt["a"]})),n.d(t,"oc",(function(){return Lt["a"]})),n.d(t,"pc",(function(){return jt["a"]})),n.d(t,"qc",(function(){return Pt["a"]})),n.d(t,"sc",(function(){return Vt})),n.d(t,"tc",(function(){return zt["a"]})),n.d(t,"uc",(function(){return Ut})),n.d(t,"vc",(function(){return Ht})),n.d(t,"wc",(function(){return Kt})),n.d(t,"xc",(function(){return Yt})),n.d(t,"yc",(function(){return nn})),n.d(t,"zc",(function(){return rn["a"]})),n.d(t,"Ac",(function(){return an["a"]})),n.d(t,"Bc",(function(){return sn["a"]})),n.d(t,"Cc",(function(){return on["a"]})),n.d(t,"Dc",(function(){return un})),n.d(t,"Ec",(function(){return pn})),n.d(t,"Fc",(function(){return fn})),n.d(t,"Gc",(function(){return mn["a"]})),n.d(t,"Hc",(function(){return bn["a"]})),n.d(t,"Ic",(function(){return gn["a"]})),n.d(t,"Jc",(function(){return yn["a"]})),n.d(t,"Kc",(function(){return xn["a"]})),n.d(t,"Lc",(function(){return On["a"]})),n.d(t,"Mc",(function(){return ce["a"]})),n.d(t,"Nc",(function(){return vn["a"]})),n.d(t,"Oc",(function(){return kn})),n.d(t,"Pc",(function(){return Sn})),n.d(t,"Qc",(function(){return Cn})),n.d(t,"Rc",(function(){return Tn})),n.d(t,"Tc",(function(){return $n["a"]})),n.d(t,"Uc",(function(){return En["a"]})),n.d(t,"Vc",(function(){return An["a"]})),n.d(t,"Xc",(function(){return Rn["a"]})),n.d(t,"Yc",(function(){return Fn})),n.d(t,"Zc",(function(){return Dn["a"]})),n.d(t,"ad",(function(){return S["a"]})),n.d(t,"bd",(function(){return Mn["a"]})),n.d(t,"dd",(function(){return Ln["a"]})),n.d(t,"ed",(function(){return Pn["a"]})),n.d(t,"fd",(function(){return N["a"]})),n.d(t,"gd",(function(){return Vn})),n.d(t,"hd",(function(){return Wn})),n.d(t,"id",(function(){return Gn})),n.d(t,"jd",(function(){return qn})),n.d(t,"kd",(function(){return Kn["a"]})),n.d(t,"ld",(function(){return rt["a"]})),n.d(t,"md",(function(){return Zt["a"]})),n.d(t,"nb",(function(){return Xn["a"]})),n.d(t,"wb",(function(){return Yn["a"]})),n.d(t,"Ab",(function(){return Qn["a"]})),n.d(t,"Sc",(function(){return Zn["a"]})),n.d(t,"qd",(function(){return Jn["a"]})),n.d(t,"rd",(function(){return er["a"]})),n.d(t,"sd",(function(){return Et["a"]})),n.d(t,"td",(function(){return tr["a"]})),n.d(t,"ud",(function(){return nr["a"]})),n.d(t,"vd",(function(){return rr["a"]})),n.d(t,"wd",(function(){return ar["a"]})),n.d(t,"xd",(function(){return sr["a"]})),n.d(t,"zd",(function(){return ut["a"]})),n.d(t,"Ad",(function(){return lt["a"]})),n.d(t,"Bd",(function(){return or["a"]})),n.d(t,"Cd",(function(){return C["a"]})),n.d(t,"Dd",(function(){return ir["a"]})),n.d(t,"Ed",(function(){return cr["a"]})),n.d(t,"Fd",(function(){return lr})),n.d(t,"Gd",(function(){return dr["a"]})),n.d(t,"Hd",(function(){return pr})),n.d(t,"Id",(function(){return hr})),n.d(t,"Jd",(function(){return fr})),n.d(t,"Kd",(function(){return Re["a"]})),n.d(t,"Ld",(function(){return mr["a"]})),n.d(t,"Nd",(function(){return br["a"]})),n.d(t,"Od",(function(){return gr["a"]})),n.d(t,"Pd",(function(){return xr})),n.d(t,"Qd",(function(){return Or["a"]})),n.d(t,"Rd",(function(){return vr})),n.d(t,"Sd",(function(){return wr["a"]})),n.d(t,"Td",(function(){return kr["a"]})),n.d(t,"Ud",(function(){return jr["a"]})),n.d(t,"Vd",(function(){return Sr["a"]})),n.d(t,"y",(function(){return Cr})),n.d(t,"Md",(function(){return Ir["a"]})),n.d(t,"mc",(function(){return Er})),n.d(t,"hc",(function(){return _r})),n.d(t,"Wc",(function(){return Fr["a"]})),n.d(t,"od",(function(){return Dr["a"]})),n.d(t,"tb",(function(){return Mr["a"]})),n.d(t,"db",(function(){return Br})),n.d(t,"gb",(function(){return Vr})),n.d(t,"T",(function(){return zr})),n.d(t,"zb",(function(){return Ur})),n.d(t,"rc",(function(){return j["b"]})),n.d(t,"a",(function(){return j["a"]})),n.d(t,"yb",(function(){return Fs})),n.d(t,"Hb",(function(){return Ds})),n.d(t,"Tb",(function(){return Ms})),n.d(t,"pd",(function(){return Rs})),n.d(t,"rb",(function(){return r})),n.d(t,"cd",(function(){return _s})),n.d(t,"nd",(function(){return Ls})),n.d(t,"yd",(function(){return Ps}));var r={};n.r(r),n.d(r,"conv2d",(function(){return Yr})),n.d(r,"depthwiseConv2d",(function(){return na})),n.d(r,"matMul",(function(){return aa}));var a=n("8ae0"),s=n("a374"),o=n("4615"),i=n("9117"),c=n("4850"),u=n("df81"),l=n("4516"),d=n("e89f"),p=n("db49"),h=n("220f"),f=n("dc59"),m=n("7e36"),b=n("6002"),g=n("d1a8"),y=n("9748"),x=n("ba53"),O=n("a3f7"),v=n("649e"),w=n("487b"),k=n("a5aa"),j=n("54ef"),S=n("ffb3"),N=n("6d3c"),C=n("8888");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function I(e,t,n,r,a,s){const o=Object(O["a"])(e,"forgetBias","basicLSTMCell"),c=Object(O["a"])(t,"lstmKernel","basicLSTMCell"),u=Object(O["a"])(n,"lstmBias","basicLSTMCell"),l=Object(O["a"])(r,"data","basicLSTMCell"),d=Object(O["a"])(a,"c","basicLSTMCell"),p=Object(O["a"])(s,"h","basicLSTMCell"),h=Object(v["a"])([l,p],1),f=Object(w["a"])(h,c),m=Object(i["a"])(f,u),b=m.shape[0],g=m.shape[1]/4,y=[b,g],x=Object(N["a"])(m,[0,0],y),j=Object(N["a"])(m,[0,g],y),I=Object(N["a"])(m,[0,2*g],y),T=Object(N["a"])(m,[0,3*g],y),$=Object(i["a"])(Object(k["a"])(Object(S["a"])(x),Object(C["a"])(j)),Object(k["a"])(d,Object(S["a"])(Object(i["a"])(o,I)))),E=Object(k["a"])(Object(C["a"])($),Object(S["a"])(T));return[$,E]}const T=Object(j["b"])({basicLSTMCell_:I});var $=n("3b28"),E=n("71db"),A=n("6ad5");function R(e,t,n,r,a,s){const o=Object(O["a"])(e,"x","batchNorm"),i=Object(O["a"])(t,"mean","batchNorm"),c=Object(O["a"])(n,"variance","batchNorm");let u,l;return null!=a&&(u=Object(O["a"])(a,"scale","batchNorm")),null!=r&&(l=Object(O["a"])(r,"offset","batchNorm")),A["b"](2===o.rank,()=>"Error in batchNorm2D: x must be rank 2 but got rank "+o.rank+"."),A["b"](2===i.rank||1===i.rank,()=>`Error in batchNorm2D: mean must be rank 2 or rank 1 but got rank ${i.rank}.`),A["b"](2===c.rank||1===c.rank,()=>`Error in batchNorm2D: variance must be rank 2 or rank 1 but got rank ${c.rank}.`),null!=u&&A["b"](2===u.rank||1===u.rank,()=>`Error in batchNorm2D: scale must be rank 2 or rank 1 but got rank ${u.rank}.`),null!=l&&A["b"](2===l.rank||1===l.rank,()=>`Error in batchNorm2D: offset must be rank 2 or rank 1 but got rank ${l.rank}.`),Object(E["a"])(o,i,c,l,u,s)}const _=Object(j["b"])({batchNorm2d_:R});function F(e,t,n,r,a,s){const o=Object(O["a"])(e,"x","batchNorm"),i=Object(O["a"])(t,"mean","batchNorm"),c=Object(O["a"])(n,"variance","batchNorm");let u,l;return null!=a&&(u=Object(O["a"])(a,"scale","batchNorm")),null!=r&&(l=Object(O["a"])(r,"offset","batchNorm")),A["b"](3===o.rank,()=>"Error in batchNorm3D: x must be rank 3 but got rank "+o.rank+"."),A["b"](3===i.rank||1===i.rank,()=>`Error in batchNorm3D: mean must be rank 3 or rank 1 but got rank ${i.rank}.`),A["b"](3===c.rank||1===c.rank,()=>`Error in batchNorm3D: variance must be rank 3 or rank 1 but got rank ${c.rank}.`),null!=u&&A["b"](3===u.rank||1===u.rank,()=>`Error in batchNorm3D: scale must be rank 3 or rank 1 but got rank ${u.rank}.`),null!=l&&A["b"](3===l.rank||1===l.rank,()=>`Error in batchNorm3D: offset must be rank 3 or rank 1 but got rank ${l.rank}.`),Object(E["a"])(o,i,c,l,u,s)}const D=Object(j["b"])({batchNorm3d_:F});function M(e,t,n,r,a,s){const o=Object(O["a"])(e,"x","batchNorm"),i=Object(O["a"])(t,"mean","batchNorm"),c=Object(O["a"])(n,"variance","batchNorm");let u,l;return null!=a&&(u=Object(O["a"])(a,"scale","batchNorm")),null!=r&&(l=Object(O["a"])(r,"offset","batchNorm")),A["b"](4===o.rank,()=>"Error in batchNorm4D: x must be rank 4 but got rank "+o.rank+"."),A["b"](4===i.rank||1===i.rank,()=>`Error in batchNorm4D: mean must be rank 4 or rank 1 but got rank ${i.rank}.`),A["b"](4===c.rank||1===c.rank,()=>`Error in batchNorm4D: variance must be rank 4 or rank 1 but got rank ${c.rank}.`),null!=u&&A["b"](4===u.rank||1===u.rank,()=>`Error in batchNorm4D: scale must be rank 4 or rank 1 but got rank ${u.rank}.`),null!=l&&A["b"](4===l.rank||1===l.rank,()=>`Error in batchNorm4D: offset must be rank 4 or rank 1 but got rank ${l.rank}.`),Object(E["a"])(o,i,c,l,u,s)}const L=Object(j["b"])({batchNorm4d_:M});var P=n("04c4"),B=n("22e3"),V=n("48db"),z=n("043e"),W=n("deb3"),U=n("5960"),G=n("c08f"),H=n("f0a9"),q=n("0777");function K(e){return Object(v["a"])(e,0)}const X=Object(j["b"])({concat1d_:K});function Y(e,t){return Object(v["a"])(e,t)}const Q=Object(j["b"])({concat2d_:Y});function Z(e,t){return Object(v["a"])(e,t)}const J=Object(j["b"])({concat3d_:Z});function ee(e,t){return Object(v["a"])(e,t)}const te=Object(j["b"])({concat4d_:ee});var ne=n("7675"),re=n("dd7e"),ae=n("cd1f"),se=n("1590"),oe=n("6ae2"),ie=n("c05b"),ce=n("35c9");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function ue(e,t,n,r,a){A["b"](e.length===t.rank,()=>`Length of inShape (${e.length}) and rank of dy (${t.rank}) must match`);let s=e,o=t,i=!1;4===t.rank&&(i=!0,o=Object(ce["a"])(t,[1,t.shape[0],t.shape[1],t.shape[2],t.shape[3]]),s=[1,e[0],e[1],e[2],e[3]]);const c=s[4],u=o.shape[4];A["b"](5===s.length,()=>"Error in conv3dDerInput: inShape must be length 5, but got length "+s.length+"."),A["b"](5===o.rank,()=>"Error in conv3dDerInput: dy must be rank 5, but got rank "+o.rank),A["b"](5===n.rank,()=>"Error in conv3dDerInput: filter must be rank 5, but got rank "+n.rank),A["b"](c===n.shape[3],()=>`Error in conv3dDerInput: depth of input (${c}) must match input depth for filter ${n.shape[3]}.`),A["b"](u===n.shape[4],()=>`Error in conv3dDerInput: depth of output (${u}) must match output depth for filter ${n.shape[4]}.`);const l={dy:o,filter:n},d={pad:a,strides:r,inputShape:s},p=oe["a"].runKernel(ie["I"],l,d);return i?Object(ce["a"])(p,[p.shape[1],p.shape[2],p.shape[3],p.shape[4]]):p}const le=Object(j["b"])({conv3DBackpropInput_:ue});function de(e,t,n,r,a){const s=Object(O["a"])(e,"x","conv3dTranspose"),o=Object(O["a"])(t,"filter","conv3dTranspose");return le(n,s,o,r,a)}const pe=Object(j["b"])({conv3dTranspose_:de});var he=n("eff7"),fe=n("c1a2"),me=n("1e68"),be=n("2f2c"),ge=n("364e"),ye=n("838f");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function xe(e){const t=Object(O["a"])(e,"x","diag"),n={x:t};return oe["a"].runKernel(ie["S"],n)}const Oe=Object(j["b"])({diag_:xe});var ve=n("c170"),we=n("c77c"),ke=n("011b");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function je(e,t){const n=Object(O["a"])(e,"t1","dot"),r=Object(O["a"])(t,"t2","dot");A["b"]((1===n.rank||2===n.rank)&&(1===r.rank||2===r.rank),()=>`Error in dot: inputs must all be rank 1 or 2, but got ranks ${n.rank} and ${r.rank}.`);const a=1===n.rank?n.size:n.shape[1],s=1===r.rank?r.size:r.shape[0];if(A["b"](a===s,()=>`Error in dot: inner dimensions of inputs must match, but got ${a} and ${s}.`),1===n.rank&&1===r.rank){const e=Object(ce["a"])(n,[1,-1]),t=Object(ce["a"])(r,[-1,1]),a=Object(w["a"])(e,t);return Object(ce["a"])(a,[])}if(1===n.rank&&2===r.rank){const e=Object(ce["a"])(n,[1,-1]),t=Object(ce["a"])(r,[r.shape[0],r.shape[1]]),a=Object(w["a"])(e,t);return Object(ce["a"])(a,[a.size])}if(2===n.rank&&1===r.rank){const e=Object(ce["a"])(r,[-1,1]),t=Object(w["a"])(n,e);return Object(ce["a"])(t,[t.size])}{const e=Object(ce["a"])(r,[r.shape[0],r.shape[1]]),t=Object(w["a"])(n,e);return t}}const Se=Object(j["b"])({dot_:je});var Ne=n("75ab"),Ce=n("9e38"),Ie=n("b9b9"),Te=n("8e05"),$e=n("4f20"),Ee=n("dae8"),Ae=n("1ba2"),Re=n("8d71");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function _e(e,t,n,r="float32"){null==t&&(t=e);const a=Object(z["a"])([e,t],r),s=e<=t?e:t;for(let i=0;i<s;++i)a.set(1,i,i);const o=Object(ce["a"])(a.toTensor(),[e,t]);if(null==n)return o;if(1===n.length)return Object(Re["a"])(Object(Ee["a"])(o,0),[n[0],1,1]);if(2===n.length)return Object(Re["a"])(Object(Ee["a"])(Object(Ee["a"])(o,0),0),[n[0],n[1],1,1]);if(3===n.length)return Object(Re["a"])(Object(Ee["a"])(Object(Ee["a"])(Object(Ee["a"])(o,0),0),0),[n[0],n[1],n[2],1,1]);throw new Error(`eye() currently supports only 1D and 2D batchShapes, but received ${n.length}D.`)}const Fe=Object(j["b"])({eye_:_e});var De=n("46b8"),Me=n("d369"),Le=n("508f"),Pe=n("91a3"),Be=n("cef0"),Ve=n("bb2d"),ze=n("24b0");
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function We(e){const t=Object(O["a"])(e,"x","isFinite"),n={x:t};return oe["a"].runKernel(ie["ub"],n)}const Ue=Object(j["b"])({isFinite_:We});
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ge(e){const t=Object(O["a"])(e,"x","isInf"),n={x:t};return oe["a"].runKernel(ie["vb"],n)}const He=Object(j["b"])({isInf_:Ge});var qe=n("6fef"),Ke=n("6f37"),Xe=n("e1fd"),Ye=n("b21c"),Qe=n("5894"),Ze=n("e101"),Je=n("1359"),et=n("46b1"),tt=n("538e"),nt=n("3bb7"),rt=n("9ffd");
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function at(e){const t=Object(O["a"])(e,"x","logSigmoid"),n=Object(tt["a"])(e=>{const t=Object(nt["a"])(Object(rt["a"])(Object(nt["a"])(e))),n=t=>{const n=Object(k["a"])(t,Object(S["a"])(Object(nt["a"])(e)));return n};return{value:t,gradFunc:n}});return n(t)}const st=Object(j["b"])({logSigmoid_:at});var ot=n("804a"),it=n("36e5"),ct=n("c021"),ut=n("a009"),lt=n("e053");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function dt(e,t=null,n=!1){const r=Object(O["a"])(e,"x","logSumExp"),a=Object(A["I"])(t,r.shape),s=Object(ct["a"])(r,a,!0),o=Object(ut["a"])(r,s),c=Object($e["a"])(o),u=Object(lt["a"])(c,a),l=Object(Je["a"])(u),d=Object(i["a"])(Object(ce["a"])(s,l.shape),l);if(n){const e=Object(it["e"])(d.shape,a);return Object(ce["a"])(d,e)}return d}const pt=Object(j["b"])({logSumExp_:dt});var ht=n("e333"),ft=n("ef00"),mt=n("f183"),bt=n("526f");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function gt(e,t){const n=Object(O["a"])(e,"a","logicalXor","bool"),r=Object(O["a"])(t,"b","logicalXor","bool");return Object(bt["a"])(n.shape,r.shape),Object(ht["a"])(Object(mt["a"])(e,t),Object(ft["a"])(Object(ht["a"])(e,t)))}const yt=Object(j["b"])({logicalXor_:gt});var xt=n("9fe6"),Ot=n("53fd"),vt=n("8bc9"),wt=n("09f4"),kt=n("122e"),jt=n("c22a"),St=n("34d7");
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Nt(e,t,{indexing:n="xy"}={}){if("xy"!==n&&"ij"!==n)throw new TypeError(n+" is not a valid third argument to meshgrid");if(void 0===e)return[];let r=Object(O["a"])(e,"x","meshgrid",e instanceof St["a"]?e.dtype:"float32");if(void 0===t)return[r];let a=Object(O["a"])(t,"y","meshgrid",t instanceof St["a"]?t.dtype:"float32");const s=Object(A["O"])(r.shape),o=Object(A["O"])(a.shape);return"xy"===n?(r=Object(ce["a"])(r,[1,-1]),a=Object(ce["a"])(a,[-1,1]),[Object(w["a"])(Object(jt["a"])([o,1],r.dtype),r),Object(w["a"])(a,Object(jt["a"])([1,s],a.dtype))]):(r=Object(ce["a"])(r,[-1,1]),a=Object(ce["a"])(a,[1,-1]),[Object(w["a"])(r,Object(jt["a"])([1,o],r.dtype)),Object(w["a"])(Object(jt["a"])([s,1],a.dtype),a)])}var Ct=n("ae6d"),It=n("f0e5"),Tt=n("93db"),$t=n("4611"),Et=n("93b2");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function At(e,t=null,n=!1){e=Object(O["a"])(e,"x","moments");const r=Object(A["I"])(t,e.shape),a=Object(kt["a"])(e,r,n);let s=a.shape;n||(s=Object(it["e"])(a.shape,r));const o=Object(Et["a"])(Object(ut["a"])(Object(W["a"])(e,"float32"),Object(ce["a"])(a,s))),i=Object(kt["a"])(o,r,n);return{mean:a,variance:i}}const Rt=Object(j["b"])({moments_:At});function _t(e,t,n,r){const a=Object(O["a"])(t,"data","multiRNNCell"),s=Object(O["b"])(n,"c","multiRNNCell"),o=Object(O["b"])(r,"h","multiRNNCell");let i=a;const c=[];for(let d=0;d<e.length;d++){const t=e[d](i,s[d],o[d]);c.push(t[0]),c.push(t[1]),i=t[1]}const u=[],l=[];for(let d=0;d<c.length;d+=2)u.push(c[d]),l.push(c[d+1]);return[u,l]}const Ft=Object(j["b"])({multiRNNCell_:_t});var Dt=n("3efc"),Mt=n("d4de"),Lt=n("e22c"),Pt=n("0db5");function Bt(e,t){const n=Object(O["a"])(e,"v1","outerProduct"),r=Object(O["a"])(t,"v2","outerProduct");A["b"](1===n.rank&&1===r.rank,()=>`Error in outerProduct: inputs must be rank 1, but got ranks ${n.rank} and ${r.rank}.`);const a=Object(ce["a"])(n,[-1,1]),s=Object(ce["a"])(r,[1,-1]);return Object(w["a"])(a,s)}const Vt=Object(j["b"])({outerProduct_:Bt});var zt=n("0eb5");function Wt(e,t,n=0){return Object(A["b"])(2===t.length,()=>"Invalid number of paddings. Must be length of 2."),Object(zt["a"])(e,[t],n)}const Ut=Object(j["b"])({pad1d_:Wt});function Gt(e,t,n=0){return Object(A["b"])(2===t.length&&2===t[0].length&&2===t[1].length,()=>"Invalid number of paddings. Must be length of 2 each."),Object(zt["a"])(e,t,n)}const Ht=Object(j["b"])({pad2d_:Gt});function qt(e,t,n=0){return Object(A["b"])(3===t.length&&2===t[0].length&&2===t[1].length&&2===t[2].length,()=>"Invalid number of paddings. Must be length of 2 each."),Object(zt["a"])(e,t,n)}const Kt=Object(j["b"])({pad3d_:qt});function Xt(e,t,n=0){return Object(A["b"])(4===t.length&&2===t[0].length&&2===t[1].length&&2===t[2].length&&2===t[3].length,()=>"Invalid number of paddings. Must be length of 2 each."),Object(zt["a"])(e,t,n)}const Yt=Object(j["b"])({pad4d_:Xt});var Qt=n("b818"),Zt=n("7580");
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Jt(e,t,n,r,a,s){null==a&&(a=[1,1]),null==s&&(s=1),0===r&&(r="valid");const o=Object(O["a"])(e,"x","maxPool");let i=o,c=!1;3===o.rank&&(c=!0,i=Object(ce["a"])(o,[1,o.shape[0],o.shape[1],o.shape[2]])),A["b"](Qt["h"](s,a),()=>`Error in pool: Either strides or dilations must be 1. Got strides ${s} and dilations '${a}'`);const u=Qt["e"](i.shape,t,s,a,r),l=[u.dilationHeight,u.dilationWidth];let d;d="same"===r?tn([u.filterHeight,u.filterWidth],l):[[0,0],[0,0]];const p=1===l[0]&&1===l[1],[h,f]=en([u.inHeight,u.inWidth],l,d),m=p?r:"valid",b=p?i:Object(Zt["a"])(i,l,h),g="avg"===n?()=>Object(y["a"])(b,t,s,m):()=>Object(xt["a"])(b,t,s,m),x=g(),v=p?x:Object($["a"])(x,l,f);return c?Object(ce["a"])(v,[v.shape[1],v.shape[2],v.shape[3]]):v}function en(e,t,n){const r=n.map(e=>e[0]),a=n.map(e=>e[1]),s=e.concat(r,a),o=t.map((e,t)=>(e-s[t]%e)%e),i=a.map((e,t)=>e+o[t]),c=t.map((e,t)=>[r[t],i[t]]),u=t.map((e,t)=>[0,o[t]]);return[c,u]}function tn(e,t){const n=e.map((e,n)=>e+(e-1)*(t[n]-1)),r=n.map(e=>e-1),a=r.map(e=>Math.floor(e/2)),s=r.map((e,t)=>e-a[t]);return r.map((e,t)=>[a[t],s[t]])}const nn=Object(j["b"])({pool_:Jt});var rn=n("c9f1"),an=n("520f"),sn=n("7568"),on=n("f3ae");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function cn(e,t,n){const r=Object(A["O"])(e);let a=null;if(null==n||"float32"===n)a=new Float32Array(r);else if("int32"===n)a=new Int32Array(r);else{if("bool"!==n)throw new Error("Unknown data type "+n);a=new Uint8Array(r)}for(let s=0;s<r;s++)a[s]=t();return oe["a"].makeTensor(a,e,n)}const un=Object(j["b"])({rand_:cn});var ln=n("d4e4");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dn(e,t,n=1,r="float32",a){if(null==n&&(n=1),null==r&&(r="float32"),"float32"!==r&&"int32"!==r)throw new Error("Unsupported data type "+r);const s=new ln["b"](t,n,r,a),o=Object(z["a"])(e,r);for(let i=0;i<o.values.length;i++)o.values[i]=s.nextValue();return o.toTensor()}const pn=Object(j["b"])({randomGamma_:dn});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hn(e,t=0,n=1,r,a){if(null!=r&&"bool"===r)throw new Error("Unsupported data type "+r);const s=new ln["a"](t,n,r,!1,a),o=Object(z["a"])(e,r);for(let i=0;i<o.values.length;i++)o.values[i]=s.nextValue();return o.toTensor()}const fn=Object(j["b"])({randomNormal_:hn});var mn=n("8629"),bn=n("84d6"),gn=n("d7b0"),yn=n("b500"),xn=n("917a"),On=n("46a8"),vn=n("d08e");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function wn(e){const t=Object(O["a"])(e,"x","reverse");return A["b"](1===t.rank,()=>`Error in reverse1D: x must be rank 1 but got rank ${t.rank}.`),Object(vn["a"])(t,0)}const kn=Object(j["b"])({reverse1d_:wn});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jn(e,t){const n=Object(O["a"])(e,"x","reverse");return A["b"](2===n.rank,()=>`Error in reverse2D: x must be rank 2 but got rank ${n.rank}.`),Object(vn["a"])(n,t)}const Sn=Object(j["b"])({reverse2d_:jn});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Nn(e,t){const n=Object(O["a"])(e,"x","reverse");return A["b"](3===n.rank,()=>`Error in reverse3D: x must be rank 3 but got rank ${n.rank}.`),Object(vn["a"])(n,t)}const Cn=Object(j["b"])({reverse3d_:Nn});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function In(e,t){const n=Object(O["a"])(e,"x","reverse");return A["b"](4===n.rank,()=>`Error in reverse4D: x must be rank 4 but got rank ${n.rank}.`),Object(vn["a"])(n,t)}const Tn=Object(j["b"])({reverse4d_:In});var $n=n("08a9"),En=n("5f2a"),An=n("015f"),Rn=n("b39e");function _n(e,t,n,r,a,s=[1,1],o="NHWC"){const i=Object(O["a"])(e,"x","separableConv2d"),c=Object(O["a"])(t,"depthwiseFilter","separableConv2d"),u=Object(O["a"])(n,"pointwiseFilter","separableConv2d");let l=i,d=!1;if(3===i.rank&&(d=!0,l=Object(ce["a"])(i,[1,i.shape[0],i.shape[1],i.shape[2]])),"NCHW"===o)throw new Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");A["b"](4===l.rank,()=>`Error in separableConv2d: input must be rank 4, but got rank ${l.rank}.`),A["b"](4===c.rank,()=>`Error in separableConv2d: depthwise filter must be rank 4, but got rank ${c.rank}.`),A["b"](4===u.rank,()=>`Error in separableConv2d: pointwise filter must be rank 4, but got rank ${c.rank}.`),A["b"](1===u.shape[0],()=>`Error in separableConv2d: the first dimension of pointwise filter  must be 1, but got ${u.shape[0]}.`),A["b"](1===u.shape[1],()=>`Error in separableConv2d: the second dimension of pointwise filter must be 1, but got ${u.shape[1]}.`);const p=c.shape[2],h=c.shape[3];A["b"](u.shape[2]===p*h,()=>`Error in separableConv2d: the third dimension of pointwise filter must be ${p*h}, but got ${u.shape[2]}.`);const f=Object(ye["a"])(l,c,r,a,o,s),m=1,b=Object(re["a"])(f,u,m,"valid",o);return d?Object(ce["a"])(b,[b.shape[1],b.shape[2],b.shape[3]]):b}const Fn=Object(j["b"])({separableConv2d_:_n});var Dn=n("f74c"),Mn=n("1df6"),Ln=n("6932"),Pn=n("5dc4");
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Bn(e,t,n){const r=Object(O["a"])(e,"x","slice1d");return A["b"](1===r.rank,()=>`slice1d expects a rank-1 tensor, but got a rank-${r.rank} tensor`),Object(N["a"])(r,[t],[n])}const Vn=Object(j["b"])({slice1d_:Bn});
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zn(e,t,n){const r=Object(O["a"])(e,"x","slice2d");return A["b"](2===r.rank,()=>`slice2d expects a rank-2 tensor, but got a rank-${r.rank} tensor`),Object(N["a"])(r,t,n)}const Wn=Object(j["b"])({slice2d_:zn});
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Un(e,t,n){const r=Object(O["a"])(e,"x","slice3d");return A["b"](3===r.rank,()=>`slice3d expects a rank-3 tensor, but got a rank-${r.rank} tensor`),Object(N["a"])(r,t,n)}const Gn=Object(j["b"])({slice3d_:Un});
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Hn(e,t,n){const r=Object(O["a"])(e,"x","slice4d");return A["b"](4===r.rank,()=>`slice4d expects a rank-4 tensor, but got a rank-${r.rank} tensor`),Object(N["a"])(r,t,n)}const qn=Object(j["b"])({slice4d_:Hn});var Kn=n("5f87"),Xn=n("1ab7"),Yn=n("4c7a"),Qn=n("69dc"),Zn=n("b61d"),Jn=n("45bb"),er=n("163a"),tr=n("4184"),nr=n("d1f4"),rr=n("d54d"),ar=n("2fb1"),sr=n("de1a"),or=n("d30a"),ir=n("357d"),cr=n("960f"),ur=n("5959");
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function lr(e,t,n){if(Object(A["d"])(e),null!=t&&2!==t.length)throw new Error("tensor2d() requires shape to have two numbers");const r=Object(O["c"])(e,n);if(2!==r.length&&1!==r.length)throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");if(1===r.length&&null==t)throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");return Object(ur["a"])(e,t,r,n)}var dr=n("05bb");
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pr(e,t,n){if(Object(A["d"])(e),null!=t&&4!==t.length)throw new Error("tensor4d() requires shape to have four numbers");const r=Object(O["c"])(e,n);if(4!==r.length&&1!==r.length)throw new Error("tensor4d() requires values to be number[][][][] or flat/TypedArray");if(1===r.length&&null==t)throw new Error("tensor4d() requires shape to be provided when `values` are a flat array");return Object(ur["a"])(e,t,r,n)}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hr(e,t,n){if(Object(A["d"])(e),null!=t&&5!==t.length)throw new Error("tensor5d() requires shape to have five numbers");const r=Object(O["c"])(e,n);if(5!==r.length&&1!==r.length)throw new Error("tensor5d() requires values to be number[][][][][] or flat/TypedArray");if(1===r.length&&null==t)throw new Error("tensor5d() requires shape to be provided when `values` are a flat array");return Object(ur["a"])(e,t,r,n)}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fr(e,t,n){if(Object(A["d"])(e),null!=t&&6!==t.length)throw new Error("tensor6d() requires shape to have six numbers");const r=Object(O["c"])(e,n);if(6!==r.length&&1!==r.length)throw new Error("tensor6d() requires values to be number[][][][][][] or flat/TypedArray");if(1===r.length&&null==t)throw new Error("tensor6d() requires shape to be provided when `values` are a flat array");return t=t||r,Object(ur["a"])(e,t,r,n)}var mr=n("5616"),br=n("7e6a"),gr=n("853e");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function yr(e,t,n){const r=Object(O["a"])(e,"x","unsortedSegmentSum"),a=Object(O["a"])(t,"segmentIds","unsortedSegmentSum","int32");Object(A["b"])(Object(A["v"])(n),()=>"numSegments must be of dtype int");const s={x:r,segmentIds:a},o={numSegments:n};return oe["a"].runKernel(ie["id"],s,o)}const xr=Object(j["b"])({unsortedSegmentSum_:yr});var Or=n("3a44");
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vr(e,t=!0,n,r){return oe["a"].makeVariable(e,t,n,r)}var wr=n("6791"),kr=n("a780"),jr=n("5a2c"),Sr=n("a09b");
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
async function Nr(e,t,n){const r=Object(O["a"])(e,"tensor","boolMask"),a=Object(O["a"])(t,"mask","boolMask","bool"),s=null==n?0:n,o=a.rank,i=r.shape;A["b"](o>0,()=>"mask cannot be scalar"),A["e"](i.slice(s,s+o),a.shape,"mask's shape must match the first K dimensions of tensor's shape,");let c=1;for(let m=s;m<s+o;m++)c*=i[m];const u=i.slice(0,s).concat([c],i.slice(s+o)),l=Object(ce["a"])(r,u),d=Object(ce["a"])(a,[-1]),p=await Object(kr["a"])(d),h=Object(nr["a"])(p,[1]),f=Object(Pe["a"])(l,h,s);return e!==r&&r.dispose(),t!==a&&a.dispose(),h.dispose(),l.dispose(),d.dispose(),p.dispose(),f}const Cr=Nr;var Ir=n("c912");
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Tr(e,t="euclidean",n=null,r=!1){e=Object(O["a"])(e,"x","norm");const a=$r(e,t,n);let s=a.shape;if(r){const t=Object(A["I"])(n,e.shape);s=it["e"](a.shape,t)}return Object(ce["a"])(a,s)}function $r(e,t,n=null){if(0===e.rank)return Object(a["a"])(e);if(1!==e.rank&&null===n)return $r(Object(ce["a"])(e,[-1]),t,n);if(1===e.rank||"number"===typeof n||Array.isArray(n)&&1===n.length){if(1===t)return Object(lt["a"])(Object(a["a"])(e),n);if(t===1/0)return Object(ct["a"])(Object(a["a"])(e),n);if(t===-1/0)return Object(Ct["a"])(Object(a["a"])(e),n);if("euclidean"===t||2===t)return Object(er["a"])(Object(lt["a"])(Object(rn["a"])(Object(a["a"])(e),Object(An["a"])(2,"int32")),n));throw new Error("Error in norm: invalid ord value: "+t)}if(Array.isArray(n)&&2===n.length){if(1===t)return Object(ct["a"])(Object(lt["a"])(Object(a["a"])(e),n[0]),n[1]-1);if(t===1/0)return Object(ct["a"])(Object(lt["a"])(Object(a["a"])(e),n[1]),n[0]);if(t===-1/0)return Object(Ct["a"])(Object(lt["a"])(Object(a["a"])(e),n[1]),n[0]);if("fro"===t||"euclidean"===t)return Object(er["a"])(Object(lt["a"])(Object(Et["a"])(e),n));throw new Error("Error in norm: invalid ord value: "+t)}throw new Error("Error in norm: invalid axis: "+n)}const Er=Object(j["b"])({norm_:Tr});var Ar=n("76c2");
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Rr(e,t,n,r,a=!0){const s=Object(O["a"])(e,"v","movingAverage"),o=Object(O["a"])(t,"x","movingAverage"),c=Object(O["a"])(n,"decay","movingAverage");Object(Ar["assertTypesMatch"])(s,o),A["b"](A["a"](s.shape,o.shape),()=>"Shape mismatch in v and x");const u=Object(An["a"])(1),l=Object(ut["a"])(u,c);let d=Object(k["a"])(Object(ut["a"])(o,s),l);if(a){A["b"](null!=r,()=>"When using zeroDebias: true, step is required.");const e=Object(O["a"])(r,"step","movingAverage");d=Object(we["a"])(d,Object(ut["a"])(u,Object(rn["a"])(c,e)))}return Object(i["a"])(s,d)}const _r=Object(j["b"])({movingAverage_:Rr});var Fr=n("8bfa"),Dr=n("bc62"),Mr=n("ba40");
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Lr(e,t){if(null==t)return e.shape.slice();if(A["a"](e.shape,t))return t;if(e.shape.length===t.length){const n=[];for(let r=0;r<e.shape.length;r++)null==t[r]&&null!=e.shape[r]?n.push(e.shape[r]):n.push(t[r]);return n}return t}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Pr(e,t,n,r){const a=Object(O["a"])(e,"x","dropout");if(A["b"]("float32"===a.dtype,()=>`x has to be a floating point tensor since it's going to be scaled, but got a ${a.dtype} tensor instead.`),A["b"](t>=0&&t<1,()=>`rate must be a float in the range [0, 1), but got ${t}.`),0===t)return e instanceof St["a"]?a.clone():a;const s=Lr(a,n),o=1-t,c=Object(we["a"])(Object(Me["a"])(Object(i["a"])(Object(mn["a"])(s,0,1,"float32",r),o)),o);return Object(k["a"])(a,c)}const Br=Object(j["b"])({dropout_:Pr});
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Vr(e){return Math.floor(Math.pow(2,Math.ceil(Math.log(e)/Math.log(2))))}function zr(e,t,n){const r=1-e%2,a=new Float32Array(e);for(let s=0;s<e;++s){const o=2*Math.PI*s/(e+r-1);a[s]=t-n*Math.cos(o)}return Object(cr["a"])(a,"float32")}
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function Wr(e,t,n=1){const r=Object(O["a"])(e,"predictions","inTopK"),a=Object(O["a"])(t,"targets","inTopK");Object(A["b"])(r.rank>1,()=>"inTopK() expects the predictions to be of rank 2 or higher, but got "+r.rank),Object(A["b"])(r.rank-1===a.rank,()=>`predictions rank should be 1 larger than targets rank, but got predictions rank ${r.rank} and targets rank ${a.rank}`),Object(A["e"])(r.shape.slice(0,r.shape.length-1),a.shape,"predictions's shape should be align with the targets' shape, except the last dimension.");const s=r.shape[r.shape.length-1];Object(A["b"])(n>0&&n<=s,()=>`'k' passed to inTopK() must be > 0 && <= the predictions last dimension (${s}), but got ${n}`);const o=await r.data(),i=await a.data(),[c,u]=[o.length/s,s],l=Object(A["o"])("bool",c);for(let d=0;d<c;d++){const e=d*u,t=o.subarray(e,e+u),r=[];for(let n=0;n<t.length;n++)r.push({value:t[n],index:n});r.sort((e,t)=>t.value-e.value),l[d]=0;for(let a=0;a<n;a++)if(r[a].index===i[d]){l[d]=1;break}}return e!==r&&r.dispose(),t!==a&&a.dispose(),Object(ir["a"])(l,a.shape,"bool")}const Ur=Wr;
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Gr(e,t,n,r,a,s="NHWC",o){let i=e;3===e.rank&&(i=Object(ce["a"])(e,[1,e.shape[0],e.shape[1],e.shape[2]]));let c=t;3===c.rank&&(c=Object(ce["a"])(t,[1,t.shape[0],t.shape[1],t.shape[2]])),A["b"](4===i.rank,()=>"Error in conv2dDerFilter: input must be rank 4, but got shape "+i.shape+"."),A["b"](4===c.rank,()=>"Error in conv2dDerFilter: dy must be rank 4, but got shape "+c.shape+"."),A["b"](4===n.length,()=>"Error in conv2dDerFilter: filterShape must be length 4, but got "+n+".");const u="NHWC"===s?i.shape[3]:i.shape[1],l="NHWC"===s?c.shape[3]:c.shape[1];A["b"](u===n[2],()=>`Error in conv2dDerFilter: depth of input ${u}) must match input depth in filter (${n[2]}.`),A["b"](l===n[3],()=>`Error in conv2dDerFilter: depth of dy (${l}) must match output depth for filter (${n[3]}).`),null!=o&&A["b"](A["v"](a),()=>`Error in conv2dDerFilter: pad must be an integer when using, dimRoundingMode ${o} but got pad ${a}.`);const d={x:i,dy:c},p={strides:r,pad:a,dataFormat:s,dimRoundingMode:o,filterShape:n};return oe["a"].runKernel(ie["E"],d,p)}const Hr=Object(j["b"])({conv2DBackpropFilter_:Gr});var qr=n("73d3"),Kr=n("4749");
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Xr({x:e,filter:t,strides:n,pad:r,dataFormat:a="NHWC",dilations:s=[1,1],dimRoundingMode:o,bias:c,activation:u="linear",preluActivationWeights:l,leakyreluAlpha:d}){if(u=u||"linear",!1===Object(Kr["d"])(oe["a"].state.gradientDepth,u)){let p=Object(re["a"])(e,t,n,r,a,s,o);return null!=c&&(p=Object(i["a"])(p,c)),Object(Kr["a"])(p,u,l,d)}const p=Object(O["a"])(e,"x","conv2d"),h=Object(O["a"])(t,"filter","conv2d");let f=p,m=!1;3===p.rank&&(m=!0,f=Object(ce["a"])(p,[1,p.shape[0],p.shape[1],p.shape[2]])),A["b"](4===f.rank,()=>"Error in fused conv2d: input must be rank 4, but got rank "+f.rank+"."),A["b"](4===h.rank,()=>"Error in fused conv2d: filter must be rank 4, but got rank "+h.rank+"."),null!=o&&A["b"](A["v"](r),()=>`Error in fused conv2d: pad must be an integer when using, dimRoundingMode ${o} but got pad ${r}.`),A["b"](f.shape[3]===h.shape[2],()=>`Error in conv2d: depth of input (${f.shape[3]}) must match input depth for filter ${h.shape[2]}.`),A["b"](Qt["h"](n,s),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${n} and dilations '${s}'`),A["b"]("NHWC"===a,()=>`Error in conv2d: got dataFormat of ${a} but only NHWC is currently supported.`);const b=Qt["a"](f.shape,h.shape,n,s,r,o);let g,y;null!=c&&(g=Object(O["a"])(c,"bias","fused conv2d"),[g]=Object(Ar["makeTypesMatch"])(g,p),bt["a"](b.outShape,g.shape)),null!=l&&(y=Object(O["a"])(l,"prelu weights","fused conv2d"));const x=(e,t)=>{const[a,o,i,c]=t,l=Object(Kr["c"])(e,i,u);A["b"](Qt["i"](s),()=>`Error in gradient of fused conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${s}'`);const d=Object(qr["a"])(o.shape,l,a,n,r),p=Hr(o,l,a.shape,n,r),h=[d,p];if(null!=c){const e=Object(Kr["b"])(c,l);h.push(e)}return h},v={x:f,filter:h,bias:g,preluActivationWeights:y},w={strides:n,pad:r,dataFormat:a,dilations:s,dimRoundingMode:o,activation:u,leakyreluAlpha:d};if(null==c){const e=Object(tt["a"])((e,t,n)=>{let r=oe["a"].runKernel(ie["lb"],v,w);return n([t,e,r]),m&&(r=Object(ce["a"])(r,[r.shape[1],r.shape[2],r.shape[3]])),{value:r,gradFunc:x}});return e(f,h)}{const e=Object(tt["a"])((e,t,n,r)=>{let a=oe["a"].runKernel(ie["lb"],v,w);return r([t,e,a,n]),m&&(a=Object(ce["a"])(a,[a.shape[1],a.shape[2],a.shape[3]])),{value:a,gradFunc:x}});return e(f,h,g)}}const Yr=Object(j["b"])({fusedConv2d_:Xr});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Qr(e,t,n,r,a,s=[1,1],o){let i=e;3===e.rank&&(i=Object(ce["a"])(e,[1,e.shape[0],e.shape[1],e.shape[2]]));let c=t;3===c.rank&&(c=Object(ce["a"])(t,[1,t.shape[0],t.shape[1],t.shape[2]]));const u={x:i,dy:c},l={strides:r,pad:a,dimRoundingMode:o,dilations:s,filterShape:n};return oe["a"].runKernel(ie["Q"],u,l)}const Zr=Object(j["b"])({depthwiseConv2dNativeBackpropFilter_:Qr});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Jr(e,t,n,r,a,s=[1,1],o){let i=t,c=!1;3===t.rank&&(c=!0,i=Object(ce["a"])(t,[1,t.shape[0],t.shape[1],t.shape[2]]));const u={dy:i,filter:n},l={strides:r,pad:a,dimRoundingMode:o,dilations:s,inputShape:e},d=oe["a"].runKernel(ie["R"],u,l);return c?Object(ce["a"])(d,[d.shape[1],d.shape[2],d.shape[3]]):d}const ea=Object(j["b"])({depthwiseConv2dNativeBackpropInput_:Jr});
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ta({x:e,filter:t,strides:n,pad:r,dataFormat:a="NHWC",dilations:s=[1,1],dimRoundingMode:o,bias:c,activation:u="linear",preluActivationWeights:l,leakyreluAlpha:d}){if(!1===Object(Kr["d"])(oe["a"].state.gradientDepth,u)){let p=Object(ye["a"])(e,t,n,r,a,s,o);return null!=c&&(p=Object(i["a"])(p,c)),Object(Kr["a"])(p,u,l,d)}const p=Object(O["a"])(e,"x","depthwiseConv2d"),h=Object(O["a"])(t,"filter","depthwiseConv2d");let f=p,m=!1;3===p.rank&&(m=!0,f=Object(ce["a"])(p,[1,p.shape[0],p.shape[1],p.shape[2]])),A["b"](4===f.rank,()=>`Error in fused depthwiseConv2d: input must be rank 4, but got rank ${f.rank}.`),A["b"](4===h.rank,()=>`Error in fused depthwiseConv2d: filter must be rank 4, but got rank ${h.rank}.`),A["b"](f.shape[3]===h.shape[2],()=>`Error in fused depthwiseConv2d: number of input channels (${f.shape[3]}) must match the inChannels dimension in filter ${h.shape[2]}.`),null==s&&(s=[1,1]),A["b"](Qt["h"](n,s),()=>`Error in fused depthwiseConv2d: Either strides or dilations must be 1. Got strides ${n} and dilations '${s}'`),null!=o&&A["b"](A["v"](r),()=>`Error in fused depthwiseConv2d: pad must be an integer when using dimRoundingMode ${o} but got pad ${r}.`);const b=Qt["a"](f.shape,h.shape,n,s,r,o,!0);let g,y;null!=c&&(g=Object(O["a"])(c,"bias","fused conv2d"),[g]=Object(Ar["makeTypesMatch"])(g,p),bt["a"](b.outShape,g.shape)),null!=l&&(y=Object(O["a"])(l,"prelu weights","fused depthwiseConv2d"));const x=(e,t)=>{A["b"](Qt["i"](s),()=>`Error in gradient of fused depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations '${s}'`);const[a,i,c,l]=t,d=Object(Kr["c"])(e,c,u),p=ea(i.shape,d,a,n,r,s,o),h=Zr(i,d,a.shape,n,r,s,o);if(null!=l){const e=Object(Kr["b"])(g,d);return[p,h,e]}return[p,h]},v={x:f,filter:h,bias:g,preluActivationWeights:y},w={strides:n,pad:r,dataFormat:a,dilations:s,dimRoundingMode:o,activation:u,leakyreluAlpha:d};if(null==c){const e=Object(tt["a"])((e,t,n)=>{let r=oe["a"].runKernel(ie["mb"],v,w);return n([t,e,r]),m&&(r=Object(ce["a"])(r,[r.shape[1],r.shape[2],r.shape[3]])),{value:r,gradFunc:x}});return e(f,h)}{const e=Object(tt["a"])((e,t,n,r)=>{let a=oe["a"].runKernel(ie["mb"],v,w);return r([t,e,a,n]),m&&(a=Object(ce["a"])(a,[a.shape[1],a.shape[2],a.shape[3]])),{value:a,gradFunc:x}});return e(f,h,g)}}const na=Object(j["b"])({fusedDepthwiseConv2d_:ta});
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ra({a:e,b:t,transposeA:n=!1,transposeB:r=!1,bias:a,activation:s="linear",preluActivationWeights:o,leakyreluAlpha:c}){if(!1===Object(Kr["d"])(oe["a"].state.gradientDepth,s)){let u=Object(w["a"])(e,t,n,r);return null!=a&&(u=Object(i["a"])(u,a)),Object(Kr["a"])(u,s,o,c)}let u=Object(O["a"])(e,"a","fused matMul"),l=Object(O["a"])(t,"b","fused matMul");[u,l]=Object(Ar["makeTypesMatch"])(u,l);const d=n?u.shape[u.rank-2]:u.shape[u.rank-1],p=r?l.shape[l.rank-1]:l.shape[l.rank-2],h=n?u.shape[u.rank-1]:u.shape[u.rank-2],f=r?l.shape[l.rank-2]:l.shape[l.rank-1],m=u.shape.slice(0,-2),b=l.shape.slice(0,-2),g=A["O"](m),y=A["O"](b);A["b"](u.rank>=2&&l.rank>=2&&u.rank===l.rank,()=>`Error in fused matMul: inputs must have the same rank of at least 2, got ranks ${u.rank} and ${l.rank}.`),A["b"](A["a"](m,b),()=>`Error in fused matMul: outer dimensions (${m}) and (${b}) of Tensors with shapes ${u.shape} and `+l.shape+" must match."),A["b"](d===p,()=>`Error in fused matMul: inner shapes (${d}) and (${p}) of Tensors with shapes ${u.shape} and ${l.shape} and transposeA=${n} and transposeB=${r} must match.`);const x=u.shape.slice(0,-2).concat([h,f]),v=n?Object(ce["a"])(u,[g,d,h]):Object(ce["a"])(u,[g,h,d]),k=r?Object(ce["a"])(l,[y,f,p]):Object(ce["a"])(l,[y,p,f]);let j,S;null!=a&&(j=Object(O["a"])(a,"bias","fused matMul"),[j]=Object(Ar["makeTypesMatch"])(j,u),bt["a"](x,j.shape)),null!=o&&(S=Object(O["a"])(o,"prelu weights","fused matMul"));const N=(e,t)=>{const[o,i,c,u]=t,l=Object(Kr["c"])(Object(ce["a"])(e,c.shape),c,s);let d,p;if(n||r?!n&&r?(d=Object(w["a"])(l,i,!1,!1),p=Object(w["a"])(l,o,!0,!1)):n&&!r?(d=Object(w["a"])(i,l,!1,!0),p=Object(w["a"])(o,l,!1,!1)):(d=Object(w["a"])(i,l,!0,!0),p=Object(w["a"])(l,o,!0,!0)):(d=Object(w["a"])(l,i,!1,!0),p=Object(w["a"])(o,l,!0,!1)),null!=a){const e=Object(Kr["b"])(u,l);return[d,p,e]}return[d,p]},C={a:v,b:k,bias:j,preluActivationWeights:S},I={transposeA:n,transposeB:r,activation:s,leakyreluAlpha:c};if(null==a){const e=Object(tt["a"])((e,t,n)=>{const r=oe["a"].runKernel(ie["kd"],C,I);return n([e,t,r]),{value:Object(ce["a"])(r,x),gradFunc:N}});return e(v,k)}{const e=Object(tt["a"])((e,t,n,r)=>{const a=oe["a"].runKernel(ie["kd"],C,I);return r([e,t,a,n]),{value:Object(ce["a"])(a,x),gradFunc:N}});return e(v,k,j)}}const aa=Object(j["b"])({fusedMatMul_:ra});
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sa(e){return zr(e,.54,.46)}const oa=Object(j["b"])({hammingWindow_:sa});
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ia(e){return zr(e,.5,.5)}const ca=Object(j["b"])({hannWindow_:ia});
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ua(e,t,n,r=!1,a=0){let s=0;const o=[];while(s+t<=e.size)o.push(Object(N["a"])(e,s,t)),s+=n;if(r)while(s<e.size){const r=s+t-e.size,i=Object(v["a"])([Object(N["a"])(e,s,t-r),Object(De["a"])([r],a)]);o.push(i),s+=n}return 0===o.length?lr([],[0,t]):Object(ce["a"])(Object(v["a"])(o),[o.length,t])}const la=Object(j["b"])({frame_:ua});
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function da(e,t,n,r,a=ca){null==r&&(r=Vr(t));const s=la(e,t,n),o=Object(k["a"])(s,a(t));return Object(Zn["a"])(o,r)}const pa=Object(j["b"])({stft_:da});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ha(e,t,n,r,a="bilinear",s=0){const o=Object(O["a"])(e,"image","cropAndResize"),i=Object(O["a"])(t,"boxes","cropAndResize","float32"),c=Object(O["a"])(n,"boxInd","cropAndResize","int32"),u=i.shape[0];A["b"](4===o.rank,()=>`Error in cropAndResize: image must be rank 4,but got rank ${o.rank}.`),A["b"](2===i.rank&&4===i.shape[1],()=>`Error in cropAndResize: boxes must be have size [${u},4] but had shape ${i.shape}.`),A["b"](1===c.rank&&c.shape[0]===u,()=>`Error in cropAndResize: boxInd must be have size [${u}] but had shape ${i.shape}.`),A["b"](2===r.length,()=>`Error in cropAndResize: cropSize must be of length 2, but got length ${r.length}.`),A["b"](r[0]>=1&&r[1]>=1,()=>"cropSize must be atleast [1,1], but was "+r),A["b"]("bilinear"===a||"nearest"===a,()=>"method must be bilinear or nearest, but was "+a);const l={image:o,boxes:i,boxInd:c},d={method:a,extrapolationValue:s,cropSize:r},p=oe["a"].runKernel(ie["L"],l,d);return p}const fa=Object(j["b"])({cropAndResize_:ha});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ma(e){const t=Object(O["a"])(e,"image","flipLeftRight","float32");A["b"](4===t.rank,()=>`Error in flipLeftRight: image must be rank 4,but got rank ${t.rank}.`);const n={image:t},r=oe["a"].runKernel(ie["gb"],n,{});return r}const ba=Object(j["b"])({flipLeftRight_:ma});
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ga(e){const t=Object(O["a"])(e,"image","grayscaleToRGB"),n=t.rank-1,r=t.shape[n];A["b"](t.rank>=2,()=>`Error in grayscaleToRGB: images must be at least rank 2, but got rank ${t.rank}.`),A["b"](1===r,()=>`Error in grayscaleToRGB: last dimension of a grayscale image should be size 1, but got size ${r}.`);const a=new Array(t.rank);return a.fill(1,0,n),a[n]=3,Object(Re["a"])(t,a)}const ya=Object(j["b"])({grayscaleToRGB_:ga});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xa(e,t,n=0,r=.5){const a=Object(O["a"])(e,"image","rotateWithOffset","float32");A["b"](4===a.rank,()=>`Error in rotateWithOffset: image must be rank 4,but got rank ${a.rank}.`);const s={image:a},o={radians:t,fillValue:n,center:r},i=oe["a"].runKernel(ie["wc"],s,o);return i}const Oa=Object(j["b"])({rotateWithOffset_:xa});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function va(e,t,n,r,a,s){null==r&&(r=.5),null==a&&(a=Number.NEGATIVE_INFINITY),null==s&&(s=0);const o=e.shape[0];return n=Math.min(n,o),A["b"](0<=r&&r<=1,()=>`iouThreshold must be in [0, 1], but was '${r}'`),A["b"](2===e.rank,()=>`boxes must be a 2D tensor, but was of rank '${e.rank}'`),A["b"](4===e.shape[1],()=>"boxes must have 4 columns, but 2nd dimension was "+e.shape[1]),A["b"](1===t.rank,()=>"scores must be a 1D tensor"),A["b"](t.shape[0]===o,()=>`scores has incompatible shape with boxes. Expected ${o}, but was `+t.shape[0]),A["b"](0<=s&&s<=1,()=>`softNmsSigma must be in [0, 1], but was '${s}'`),{maxOutputSize:n,iouThreshold:r,scoreThreshold:a,softNmsSigma:s}}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wa(e,t,n,r=.5,a=Number.NEGATIVE_INFINITY){const s=Object(O["a"])(e,"boxes","nonMaxSuppression"),o=Object(O["a"])(t,"scores","nonMaxSuppression"),i=va(s,o,n,r,a);n=i.maxOutputSize,r=i.iouThreshold,a=i.scoreThreshold;const c={maxOutputSize:n,iouThreshold:r,scoreThreshold:a};return oe["a"].runKernel(ie["Yb"],{boxes:s,scores:o},c)}const ka=Object(j["b"])({nonMaxSuppression_:wa});var ja=n("8389");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function Sa(e,t,n,r=.5,a=Number.NEGATIVE_INFINITY){const s=Object(O["a"])(e,"boxes","nonMaxSuppressionAsync"),o=Object(O["a"])(t,"scores","nonMaxSuppressionAsync"),i=va(s,o,n,r,a);n=i.maxOutputSize,r=i.iouThreshold,a=i.scoreThreshold;const c=await Promise.all([s.data(),o.data()]),u=c[0],l=c[1],{selectedIndices:d}=Object(ja["a"])(u,l,n,r,a);return s!==e&&s.dispose(),o!==t&&o.dispose(),Object(cr["a"])(d,"int32")}const Na=Sa;
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ca(e,t,n,r=.5,a=Number.NEGATIVE_INFINITY,s=0){const o=Object(O["a"])(e,"boxes","nonMaxSuppression"),i=Object(O["a"])(t,"scores","nonMaxSuppression"),c=va(o,i,n,r,a,s);n=c.maxOutputSize,r=c.iouThreshold,a=c.scoreThreshold,s=c.softNmsSigma;const u={boxes:o,scores:i},l={maxOutputSize:n,iouThreshold:r,scoreThreshold:a,softNmsSigma:s},d=oe["a"].runKernel(ie["ac"],u,l);return{selectedIndices:d[0],selectedScores:d[1]}}const Ia=Object(j["b"])({nonMaxSuppressionWithScore_:Ca});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function Ta(e,t,n,r=.5,a=Number.NEGATIVE_INFINITY,s=0){const o=Object(O["a"])(e,"boxes","nonMaxSuppressionAsync"),i=Object(O["a"])(t,"scores","nonMaxSuppressionAsync"),c=va(o,i,n,r,a,s);n=c.maxOutputSize,r=c.iouThreshold,a=c.scoreThreshold,s=c.softNmsSigma;const u=await Promise.all([o.data(),i.data()]),l=u[0],d=u[1],{selectedIndices:p,selectedScores:h}=Object(ja["c"])(l,d,n,r,a,s);return o!==e&&o.dispose(),i!==t&&i.dispose(),{selectedIndices:Object(cr["a"])(p,"int32"),selectedScores:Object(cr["a"])(h)}}const $a=Ta;
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ea(e,t,n,r=.5,a=Number.NEGATIVE_INFINITY,s=!1){const o=Object(O["a"])(e,"boxes","nonMaxSuppression"),i=Object(O["a"])(t,"scores","nonMaxSuppression"),c=va(o,i,n,r,a,null),u=c.maxOutputSize,l=c.iouThreshold,d=c.scoreThreshold,p={boxes:o,scores:i},h={maxOutputSize:u,iouThreshold:l,scoreThreshold:d,padToMaxOutputSize:s},f=oe["a"].runKernel(ie["Zb"],p,h);return{selectedIndices:f[0],validOutputs:f[1]}}const Aa=Object(j["b"])({nonMaxSuppressionPadded_:Ea});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function Ra(e,t,n,r=.5,a=Number.NEGATIVE_INFINITY,s=!1){const o=Object(O["a"])(e,"boxes","nonMaxSuppressionAsync"),i=Object(O["a"])(t,"scores","nonMaxSuppressionAsync"),c=va(o,i,n,r,a,null),u=c.maxOutputSize,l=c.iouThreshold,d=c.scoreThreshold,[p,h]=await Promise.all([o.data(),i.data()]),{selectedIndices:f,validOutputs:m}=Object(ja["b"])(p,h,u,l,d,s);return o!==e&&o.dispose(),i!==t&&i.dispose(),{selectedIndices:Object(cr["a"])(f,"int32"),validOutputs:Object(An["a"])(m,"int32")}}const _a=Ra;
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Fa(e,t,n=!1,r=!1){const a=Object(O["a"])(e,"images","resizeBilinear");A["b"](3===a.rank||4===a.rank,()=>`Error in resizeBilinear: x must be rank 3 or 4, but got rank ${a.rank}.`),A["b"](2===t.length,()=>"Error in resizeBilinear: new shape must 2D, but got shape "+t+"."),A["b"](!1===r||!1===n,()=>"Error in resizeBilinear: If halfPixelCenters is true, alignCorners must be false.");let s=a,o=!1;3===a.rank&&(o=!0,s=Object(ce["a"])(a,[1,a.shape[0],a.shape[1],a.shape[2]]));const[]=t,i={images:s},c={alignCorners:n,halfPixelCenters:r,size:t},u=oe["a"].runKernel(ie["rc"],i,c);return o?Object(ce["a"])(u,[u.shape[1],u.shape[2],u.shape[3]]):u}const Da=Object(j["b"])({resizeBilinear_:Fa});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ma(e,t,n=!1,r=!1){const a=Object(O["a"])(e,"images","resizeNearestNeighbor");A["b"](3===a.rank||4===a.rank,()=>`Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank ${a.rank}.`),A["b"](2===t.length,()=>"Error in resizeNearestNeighbor: new shape must 2D, but got shape "+t+"."),A["b"]("float32"===a.dtype||"int32"===a.dtype,()=>"`images` must have `int32` or `float32` as dtype"),A["b"](!1===r||!1===n,()=>"Error in resizeNearestNeighbor: If halfPixelCenters is true, alignCorners must be false.");let s=a,o=!1;3===a.rank&&(o=!0,s=Object(ce["a"])(a,[1,a.shape[0],a.shape[1],a.shape[2]]));const[]=t,i={images:s},c={alignCorners:n,halfPixelCenters:r,size:t},u=oe["a"].runKernel(ie["tc"],i,c);return o?Object(ce["a"])(u,[u.shape[1],u.shape[2],u.shape[3]]):u}const La=Object(j["b"])({resizeNearestNeighbor_:Ma});
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Pa(e,t="binary",n=!1,r=.5){const a=Object(O["a"])(e,"image","threshold"),s=.2989,o=.587,c=.114,u=a.shape[0]*a.shape[1];let l,d,p,h,f=Object(k["a"])(Object(cr["a"])([r]),255);if(A["b"](3===a.rank,()=>`Error in threshold: image must be rank 3,but got rank ${a.rank}.`),A["b"](3===a.shape[2]||1===a.shape[2],()=>`Error in threshold: image color channel must be equal to 3 or 1but got ${a.shape[2]}.`),A["b"]("int32"===a.dtype||"float32"===a.dtype,()=>`Error in dtype: image dtype must be int32 or float32,but got dtype ${a.dtype}.`),A["b"]("otsu"===t||"binary"===t,()=>"Method must be binary or otsu, but was "+t),3===a.shape[2]){[l,d,p]=Object(Jn["a"])(a,[1,1,1],-1);const e=Object(k["a"])(l,s),t=Object(k["a"])(d,o),n=Object(k["a"])(p,c);h=Object(i["a"])(Object(i["a"])(e,t),n)}else h=e;if("otsu"===t){const e=Object(P["a"])(Object(W["a"])(Object($n["a"])(h),"int32"),Object(ir["a"])([]),256);f=Ba(e,u)}const m=n?Object(Ye["a"])(h,f):Object(Be["a"])(h,f),b=Object(W["a"])(Object(k["a"])(m,255),"int32");return b}function Ba(e,t){let n,r,a,s,o,c,u=Object(cr["a"])([-1]),l=Object(cr["a"])([0]),d=Object(cr["a"])([0]);for(let p=0;p<e.size-1;p++){n=Object(N["a"])(e,0,p+1),r=Object(N["a"])(e,p+1),o=Object(we["a"])(Object(lt["a"])(n),t),c=Object(we["a"])(Object(lt["a"])(r),t);const h=Object(lt["a"])(Object(k["a"])(n,Object(bn["a"])(0,n.size)));a=Object(we["a"])(h,Object(lt["a"])(n));const f=Object(De["a"])(r.shape,n.size),m=Object(i["a"])(Object(bn["a"])(0,r.size),f),b=Object(k["a"])(r,m);s=Object(we["a"])(Object(lt["a"])(b),Object(lt["a"])(r));const g=Object(ut["a"])(a,s),y=Object(ut["a"])(a,s),x=Object(k["a"])(o,c);d=Object(k["a"])(Object(k["a"])(x,g),y);const O=Object(Be["a"])(d,l);l=Object(wr["a"])(O,d,l),u=Object(wr["a"])(O,Object(cr["a"])([p]),u)}return u}const Va=Object(j["b"])({threshold_:Pa});
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function za(e,t,n="nearest",r="constant",a=0,s){const o=Object(O["a"])(e,"image","transform","float32"),i=Object(O["a"])(t,"transforms","transform","float32");A["b"](4===o.rank,()=>`Error in transform: image must be rank 4,but got rank ${o.rank}.`),A["b"](2===i.rank&&(i.shape[0]===o.shape[0]||1===i.shape[0])&&8===i.shape[1],()=>"Error in transform: Input transform should be batch x 8 or 1 x 8"),A["b"](null==s||2===s.length,()=>`Error in transform: outputShape must be [height, width] or null, but got ${s}.`);const c={image:o,transforms:i},u={interpolation:n,fillMode:r,fillValue:a,outputShape:s};return oe["a"].runKernel(ie["ed"],c,u)}const Wa=Object(j["b"])({transform_:za});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ua(e,t,n){Object(A["b"])(t%1===0,()=>`bandPart(): numLower must be an integer, got ${t}.`),Object(A["b"])(n%1===0,()=>`bandPart(): numUpper must be an integer, got ${n}.`);const r=Object(O["a"])(e,"a","bandPart");Object(A["b"])(r.rank>=2,()=>`bandPart(): Rank must be at least 2, got ${r.rank}.`);const a=r.shape,[s,o]=r.shape.slice(-2);if(!(t<=s))throw new Error(`bandPart(): numLower (${t}) must not be greater than the number of rows (${s}).`);if(!(n<=o))throw new Error(`bandPart(): numUpper (${n}) must not be greater than the number of columns (${o}).`);t<0&&(t=s),n<0&&(n=o);const i=Object(ce["a"])(Object(bn["a"])(0,s,1,"int32"),[-1,1]),c=Object(bn["a"])(0,o,1,"int32"),u=Object(ut["a"])(i,c),l=Object(ht["a"])(Object(Ye["a"])(u,Object(An["a"])(+t,"int32")),Object(Ve["a"])(u,Object(An["a"])(-n,"int32"))),d=Object(jr["a"])([s,o],r.dtype);return Object(ce["a"])(Object(rr["a"])(Object(Or["a"])(Object(ce["a"])(r,[-1,s,o])).map(e=>Object(wr["a"])(l,e,d))),a)}const Ga=Object(j["b"])({bandPart_:Ua});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ha(e){let t;if(Array.isArray(e)){t=!1,Object(A["b"])(null!=e&&e.length>0,()=>"Gram-Schmidt process: input must not be null, undefined, or empty");const n=e[0].shape[0];for(let t=1;t<e.length;++t)Object(A["b"])(e[t].shape[0]===n,()=>`Gram-Schmidt: Non-unique lengths found in the input vectors: (${e[t].shape[0]} vs. ${n})`)}else t=!0,e=Object(Jn["a"])(e,e.shape[0],0).map(e=>Object(nr["a"])(e,[0]));Object(A["b"])(e.length<=e[0].shape[0],()=>`Gram-Schmidt: Number of vectors (${e.length}) exceeds number of dimensions (${e[0].shape[0]}).`);const n=[],r=e;for(let a=0;a<e.length;++a)n.push(oe["a"].tidy(()=>{let e=r[a];if(a>0)for(let t=0;t<a;++t){const r=Object(k["a"])(Object(lt["a"])(Object(k["a"])(n[t],e)),n[t]);e=Object(ut["a"])(e,r)}return Object(we["a"])(e,Er(e,"euclidean"))}));return t?Object(rr["a"])(n,0):n}const qa=Object(j["b"])({gramSchmidt_:Ha});var Ka=n("c04e4");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Xa(e,t=!1){if(Object(A["b"])(e.rank>=2,()=>"qr() requires input tensor to have a rank >= 2, but got rank "+e.rank),2===e.rank)return Ya(e,t);{const n=e.shape.slice(0,e.shape.length-2).reduce((e,t)=>e*t),r=Object(Or["a"])(Object(ce["a"])(e,[n,e.shape[e.shape.length-2],e.shape[e.shape.length-1]]),0),a=[],s=[];r.forEach(e=>{const[n,r]=Ya(e,t);a.push(n),s.push(r)});const o=Object(ce["a"])(Object(rr["a"])(a,0),e.shape),i=Object(ce["a"])(Object(rr["a"])(s,0),e.shape);return[o,i]}}function Ya(e,t=!1){return oe["a"].tidy(()=>{Object(A["b"])(2===e.shape.length,()=>`qr2d() requires a 2D Tensor, but got a ${e.shape.length}D Tensor.`);const n=e.shape[0],r=e.shape[1];let a=Fe(n),s=Object(H["a"])(e);const o=lr([[1]],[1,1]);let i=Object(H["a"])(o);const c=n>=r?r:n;for(let e=0;e<c;++e){const t=s,c=i,u=a;[i,s,a]=oe["a"].tidy(()=>{const t=Object(N["a"])(s,[e,e],[n-e,1]),c=Er(t),u=Object(N["a"])(s,[e,e],[1,1]),l=Object(wr["a"])(Object(Be["a"])(u,0),lr([[-1]]),lr([[1]])),d=Object(ut["a"])(u,Object(k["a"])(l,c)),p=Object(we["a"])(t,d);i=1===p.shape[0]?Object(H["a"])(o):Object(v["a"])([o,Object(N["a"])(p,[1,0],[p.shape[0]-1,p.shape[1]])],0);const h=Object(nt["a"])(Object(we["a"])(Object(w["a"])(l,d),c)),f=Object(N["a"])(s,[e,0],[n-e,r]),m=Object(k["a"])(h,i),b=Object(Ir["a"])(i);if(0===e)s=Object(ut["a"])(f,Object(w["a"])(m,Object(w["a"])(b,f)));else{const t=Object(ut["a"])(f,Object(w["a"])(m,Object(w["a"])(b,f)));s=Object(v["a"])([Object(N["a"])(s,[0,0],[e,r]),t],0)}const g=Object(Ir["a"])(m),y=Object(N["a"])(a,[0,e],[n,a.shape[1]-e]);if(0===e)a=Object(ut["a"])(y,Object(w["a"])(Object(w["a"])(y,i),g));else{const t=Object(ut["a"])(y,Object(w["a"])(Object(w["a"])(y,i),g));a=Object(v["a"])([Object(N["a"])(a,[0,0],[n,e]),t],1)}return[i,s,a]}),Object(Ka["d"])([t,c,u])}return!t&&n>r&&(a=Object(N["a"])(a,[0,0],[n,r]),s=Object(N["a"])(s,[0,0],[r,r])),[a,s]})}const Qa=Object(j["b"])({qr_:Xa});var Za=n("57e0");function Ja(e,t,n=Za["a"].SUM_BY_NONZERO_WEIGHTS){const r=Object(O["a"])(e,"losses","computeWeightedLoss");let a=null;null!=t&&(a=Object(O["a"])(t,"weights","computeWeightedLoss"));const s=null==a?r:Object(k["a"])(r,a);if(n===Za["a"].NONE)return s;if(n===Za["a"].SUM)return Object(lt["a"])(s);if(n===Za["a"].MEAN){if(null==a)return Object(kt["a"])(s);{const e=r.size/a.size,t=Object(we["a"])(Object(lt["a"])(s),Object(lt["a"])(a));return e>1?Object(we["a"])(t,Object(An["a"])(e)):t}}if(n===Za["a"].SUM_BY_NONZERO_WEIGHTS){if(null==a)return Object(we["a"])(Object(lt["a"])(s),Object(An["a"])(r.size));{const e=Object(k["a"])(a,Object(jt["a"])(r.shape)),t=Object(W["a"])(Object(lt["a"])(Object(Mt["a"])(e,Object(An["a"])(0))),"float32");return Object(we["a"])(Object(lt["a"])(s),t)}}throw Error("Unknown reduction: "+n)}const es=Object(j["b"])({computeWeightedLoss_:Ja});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ts(e,t,n,r=Za["a"].SUM_BY_NONZERO_WEIGHTS){const s=Object(O["a"])(e,"labels","absoluteDifference"),o=Object(O["a"])(t,"predictions","absoluteDifference");let i=null;null!=n&&(i=Object(O["a"])(n,"weights","absoluteDifference")),Object(A["e"])(s.shape,o.shape,"Error in absoluteDifference: ");const c=Object(a["a"])(Object(ut["a"])(s,o));return es(c,i,r)}const ns=Object(j["b"])({absoluteDifference_:ts});function rs(e,t,n,r,a=Za["a"].SUM_BY_NONZERO_WEIGHTS){const s=Object(O["a"])(e,"labels","cosineDistance"),o=Object(O["a"])(t,"predictions","cosineDistance");let i=null;null!=r&&(i=Object(O["a"])(r,"weights","cosineDistance")),Object(A["e"])(s.shape,o.shape,"Error in cosineDistance: ");const c=Object(An["a"])(1),u=Object(ut["a"])(c,Object(lt["a"])(Object(k["a"])(s,o),n,!0));return es(u,i,a)}const as=Object(j["b"])({cosineDistance_:rs});function ss(e,t,n,r=Za["a"].SUM_BY_NONZERO_WEIGHTS){let a=Object(O["a"])(e,"labels","hingeLoss");const s=Object(O["a"])(t,"predictions","hingeLoss");let o=null;null!=n&&(o=Object(O["a"])(n,"weights","hingeLoss")),Object(A["e"])(a.shape,s.shape,"Error in hingeLoss: ");const i=Object(An["a"])(1);a=Object(ut["a"])(Object(k["a"])(Object(An["a"])(2),a),i);const c=Object(xn["a"])(Object(ut["a"])(i,Object(k["a"])(a,s)));return es(c,o,r)}const os=Object(j["b"])({hingeLoss_:ss});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function is(e,t,n,r=1,s=Za["a"].SUM_BY_NONZERO_WEIGHTS){const o=Object(O["a"])(e,"labels","huberLoss"),c=Object(O["a"])(t,"predictions","huberLoss");let u=null;null!=n&&(u=Object(O["a"])(n,"weights","huberLoss")),Object(A["e"])(o.shape,c.shape,"Error in huberLoss: ");const l=Object(An["a"])(r),d=Object(a["a"])(Object(ut["a"])(c,o)),p=Object(It["a"])(d,l),h=Object(ut["a"])(d,p),f=Object(i["a"])(Object(k["a"])(Object(An["a"])(.5),Object(Et["a"])(p)),Object(k["a"])(l,h));return es(f,u,s)}const cs=Object(j["b"])({huberLoss_:is});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function us(e,t,n,r=1e-7,a=Za["a"].SUM_BY_NONZERO_WEIGHTS){const s=Object(O["a"])(e,"labels","logLoss"),o=Object(O["a"])(t,"predictions","logLoss");let c=null;null!=n&&(c=Object(O["a"])(n,"weights","logLoss")),Object(A["e"])(s.shape,o.shape,"Error in logLoss: ");const u=Object(An["a"])(1),l=Object(An["a"])(r),d=Object(nt["a"])(Object(k["a"])(s,Object(Je["a"])(Object(i["a"])(o,l)))),p=Object(k["a"])(Object(ut["a"])(u,s),Object(Je["a"])(Object(i["a"])(Object(ut["a"])(u,o),l))),h=Object(ut["a"])(d,p);return es(h,c,a)}const ls=Object(j["b"])({logLoss_:us});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ds(e,t,n,r=Za["a"].SUM_BY_NONZERO_WEIGHTS){const a=Object(O["a"])(e,"labels","meanSquaredError"),s=Object(O["a"])(t,"predictions","meanSquaredError");let o=null;null!=n&&(o=Object(O["a"])(n,"weights","meanSquaredError")),Object(A["e"])(a.shape,s.shape,"Error in meanSquaredError: ");const i=Object(tr["a"])(a,s);return es(i,o,r)}const ps=Object(j["b"])({meanSquaredError_:ds});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hs(e,t){const n=Object(O["a"])(e,"labels","sigmoidCrossEntropyWithLogits"),r=Object(O["a"])(t,"logits","sigmoidCrossEntropyWithLogits");Object(A["e"])(n.shape,r.shape,"Error in sigmoidCrossEntropyWithLogits: ");const s=Object(xn["a"])(r),o=Object(k["a"])(r,n),c=Object(et["a"])(Object($e["a"])(Object(nt["a"])(Object(a["a"])(r))));return Object(i["a"])(Object(ut["a"])(s,o),c)}function fs(e,t,n,r=0,a=Za["a"].SUM_BY_NONZERO_WEIGHTS){let s=Object(O["a"])(e,"multiClassLabels","sigmoidCrossEntropy");const o=Object(O["a"])(t,"logits","sigmoidCrossEntropy");let c=null;if(null!=n&&(c=Object(O["a"])(n,"weights","sigmoidCrossEntropy")),Object(A["e"])(s.shape,o.shape,"Error in sigmoidCrossEntropy: "),r>0){const e=Object(An["a"])(r),t=Object(An["a"])(1),n=Object(An["a"])(.5);s=Object(i["a"])(Object(k["a"])(s,Object(ut["a"])(t,e)),Object(k["a"])(n,e))}const u=hs(s,o);return es(u,c,a)}const ms=Object(j["b"])({sigmoidCrossEntropy_:fs});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bs(e,t,n=-1){if(-1===n&&(n=t.rank-1),n!==t.rank-1)throw Error(`Softmax cross entropy along a non-last dimension is not yet supported. Labels / logits was rank ${t.rank} and dim was `+n);const r=Object(tt["a"])((e,t,r)=>{const a=!0,s=pt(t,[n],a),o=Object(ut["a"])(Object(W["a"])(t,"float32"),s);r([e,o]);const i=Object(nt["a"])(Object(k["a"])(o,e)),c=Object(lt["a"])(i,[n]),u=(e,t)=>{const[r,a]=t,s=Object(it["e"])(e.shape,[n]);return[Object(k["a"])(Object(ce["a"])(e,s),Object(ut["a"])(Object(W["a"])(r,"float32"),Object($e["a"])(a))),Object(k["a"])(Object(ce["a"])(e,s),Object(ut["a"])(Object($e["a"])(a),Object(W["a"])(r,"float32")))]};return{value:c,gradFunc:u}});return r(e,t)}function gs(e,t,n,r=0,a=Za["a"].SUM_BY_NONZERO_WEIGHTS){let s=Object(O["a"])(e,"onehotLabels","softmaxCrossEntropy");const o=Object(O["a"])(t,"logits","softmaxCrossEntropy");let c=null;if(null!=n&&(c=Object(O["a"])(n,"weights","softmaxCrossEntropy")),Object(A["e"])(s.shape,o.shape,"Error in softmaxCrossEntropy: "),r>0){const e=Object(An["a"])(r),t=Object(An["a"])(1),n=Object(An["a"])(s.shape[1]);s=Object(i["a"])(Object(k["a"])(s,Object(ut["a"])(t,e)),Object(we["a"])(e,n))}const u=bs(s,o);return es(u,c,a)}const ys=Object(j["b"])({softmaxCrossEntropy_:gs});
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xs(e,t,n,r){const a=Object(O["a"])(e,"indices","sparseFillEmptyRows"),s=Object(O["a"])(t,"values","sparseFillEmptyRows"),o=Object(O["a"])(n,"denseShape","sparseFillEmptyRows"),i=Object(O["a"])(r,"defaultValue","sparseFillEmptyRows",s.dtype);if(2!==a.rank)throw new Error("Indices should be Tensor2D but received shape\n        "+a.shape);if(1!==s.rank)throw new Error("Values should be Tensor1D but received shape "+s.shape);if(1!==o.rank)throw new Error("Dense shape should be Tensor1D but received shape "+o.shape);if(0!==i.rank)throw new Error("Default value should be a scalar but received shape "+i.shape);const c={indices:a,values:s,denseShape:o,defaultValue:i},u=oe["a"].runKernel(ie["Kc"],c);return{outputIndices:u[0],outputValues:u[1],emptyRowIndicator:u[2],reverseIndexMap:u[3]}}const Os=Object(j["b"])({sparseFillEmptyRows_:xs});
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vs(e,t,n){const r=Object(O["a"])(e,"inputIndices","sparseReshape"),a=Object(O["a"])(t,"inputShape","sparseReshape"),s=Object(O["a"])(n,"newShape","sparseReshape");if(2!==r.rank)throw new Error("Input indices should be Tensor2D but received shape\n        "+r.shape);if(1!==a.rank)throw new Error("Input shape should be Tensor1D but received shape "+a.shape);if(1!==s.rank)throw new Error("New shape should be Tensor1D but received shape "+s.shape);const o={inputIndices:r,inputShape:a,newShape:s},i=oe["a"].runKernel(ie["Lc"],o);return{outputIndices:i[0],outputShape:i[1]}}const ws=Object(j["b"])({sparseReshape_:vs});
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ks(e,t,n){const r=Object(O["a"])(e,"data","sparseSegmentMean"),a=Object(O["a"])(t,"indices","sparseSegmentMean"),s=Object(O["a"])(n,"segmentIds","sparseSegmentMean");if(r.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==a.rank)throw new Error("Indices should be Tensor1D but received shape\n          "+a.shape);if(1!==s.rank)throw new Error("Segment ids should be Tensor1D but received shape\n          "+s.shape);const o={data:r,indices:a,segmentIds:s};return oe["a"].runKernel(ie["Mc"],o)}const js=Object(j["b"])({sparseSegmentMean_:ks});
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ss(e,t,n){const r=Object(O["a"])(e,"data","sparseSegmentSum"),a=Object(O["a"])(t,"indices","sparseSegmentSum"),s=Object(O["a"])(n,"segmentIds","sparseSegmentSum");if(r.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==a.rank)throw new Error("Indices should be Tensor1D but received shape\n         "+a.shape);if(1!==s.rank)throw new Error("Segment ids should be Tensor1D but received shape\n         "+s.shape);const o={data:r,indices:a,segmentIds:s};return oe["a"].runKernel(ie["Nc"],o)}const Ns=Object(j["b"])({sparseSegmentSum_:Ss});
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Cs(e,t,n,r,a,s,o,i){const c=Object(O["a"])(e,"data","stringNGrams","string");if("string"!==c.dtype)throw new Error("Data must be of datatype string");if(1!==c.shape.length)throw new Error("Data must be a vector, saw: "+c.shape);const u=Object(O["a"])(t,"dataSplits","stringNGrams");if("int32"!==u.dtype)throw new Error("Data splits must be of datatype int32");const l={separator:n,nGramWidths:r,leftPad:a,rightPad:s,padWidth:o,preserveShortSequences:i},d={data:c,dataSplits:u},p=oe["a"].runKernel(ie["Vc"],d,l);return{nGrams:p[0],nGramsSplits:p[1]}}const Is=Object(j["b"])({stringNGrams_:Cs});
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ts(e,t,n=!0){const r=Object(O["a"])(e,"input","stringSplit","string"),a=Object(O["a"])(t,"delimiter","stringSplit","string");if(1!==r.rank)throw new Error("Input should be Tensor1D but received shape "+r.shape);if(0!==a.rank)throw new Error("Delimiter should be a scalar but received shape "+a.shape);const s={skipEmpty:n},o={input:r,delimiter:a},i=oe["a"].runKernel(ie["Wc"],o,s);return{indices:i[0],values:i[1],shape:i[2]}}const $s=Object(j["b"])({stringSplit_:Ts});
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Es(e,t){const n=Object(O["a"])(e,"input","stringToHashBucketFast","string"),r={numBuckets:t};if(t<=0)throw new Error("Number of buckets must be at least 1");const a={input:n};return oe["a"].runKernel(ie["Xc"],a,r)}const As=Object(j["b"])({stringToHashBucketFast_:Es}),Rs={fft:Xn["a"],ifft:Yn["a"],rfft:Zn["a"],irfft:Qn["a"]},_s={hammingWindow:oa,hannWindow:ca,frame:la,stft:pa},Fs={flipLeftRight:ba,grayscaleToRGB:ya,resizeNearestNeighbor:La,resizeBilinear:Da,rotateWithOffset:Oa,cropAndResize:fa,nonMaxSuppression:ka,nonMaxSuppressionAsync:Na,nonMaxSuppressionWithScore:Ia,nonMaxSuppressionWithScoreAsync:$a,nonMaxSuppressionPadded:Aa,nonMaxSuppressionPaddedAsync:_a,threshold:Va,transform:Wa},Ds={bandPart:Ga,gramSchmidt:qa,qr:Qa},Ms={absoluteDifference:ns,computeWeightedLoss:es,cosineDistance:as,hingeLoss:os,huberLoss:cs,logLoss:ls,meanSquaredError:ps,sigmoidCrossEntropy:ms,softmaxCrossEntropy:ys},Ls={sparseFillEmptyRows:Os,sparseReshape:ws,sparseSegmentMean:js,sparseSegmentSum:Ns},Ps={stringNGrams:Is,stringSplit:$s,stringToHashBucketFast:As};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */},1359:function(e,t,n){"use strict";n.d(t,"a",(function(){return c}));var r=n("6ae2"),a=n("c05b"),s=n("a3f7"),o=n("54ef");
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function i(e){const t=Object(s["a"])(e,"x","log"),n={x:t};return r["a"].runKernel(a["Db"],n)}const c=Object(o["b"])({log_:i})},1528:function(e,t,n){"use strict";n("441e")},1590:function(e,t,n){"use strict";n.d(t,"a",(function(){return d}));var r=n("6ae2"),a=n("c05b"),s=n("a3f7"),o=n("6ad5"),i=n("b818"),c=n("54ef"),u=n("35c9");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function l(e,t,n,c,l="NDHWC",d=[1,1,1]){const p=Object(s["a"])(e,"x","conv3d"),h=Object(s["a"])(t,"filter","conv3d");let f=p,m=!1;4===p.rank&&(m=!0,f=Object(u["a"])(p,[1,p.shape[0],p.shape[1],p.shape[2],p.shape[3]])),o["b"](5===f.rank,()=>`Error in conv3d: input must be rank 5, but got rank ${f.rank}.`),o["b"](5===h.rank,()=>"Error in conv3d: filter must be rank 5, but got rank "+h.rank+"."),o["b"](f.shape[4]===h.shape[3],()=>`Error in conv3d: depth of input (${f.shape[4]}) must match input depth for filter ${h.shape[3]}.`),o["b"](Object(i["h"])(n,d),()=>`Error in conv3D: Either strides or dilations must be 1. Got strides ${n} and dilations '${d}'`),o["b"]("NDHWC"===l,()=>`Error in conv3d: got dataFormat of ${l} but only NDHWC is currently supported.`);const b={x:f,filter:h},g={strides:n,pad:c,dataFormat:l,dilations:d},y=r["a"].runKernel(a["G"],b,g);return m?Object(u["a"])(y,[y.shape[1],y.shape[2],y.shape[3],y.shape[4]]):y}const d=Object(c["b"])({conv3d_:l})},"163a":function(e,t,n){"use strict";n.d(t,"a",(function(){return c}));var r=n("6ae2"),a=n("c05b"),s=n("a3f7"),o=n("54ef");
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function i(e){const t=Object(s["a"])(e,"x","sqrt"),n={x:t};return r["a"].runKernel(a["Qc"],n)}const c=Object(o["b"])({sqrt_:i})},1906:function(e,t,n){"use strict";n.r(t),n.d(t,"json",(function(){return r}));
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const r=[{tfOpName:"StringNGrams",category:"string",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"dataSplits",type:"tensor"}],attrs:[{tfName:"separator",name:"separator",type:"string"},{tfName:"ngram_widths",name:"nGramWidths",type:"number[]"},{tfName:"left_pad",name:"leftPad",type:"string"},{tfName:"right_pad",name:"rightPad",type:"string"},{tfName:"pad_width",name:"padWidth",type:"number"},{tfName:"preserve_short_sequences",name:"preserveShortSequences",type:"bool"}],outputs:["ngrams","ngrams_splits"]},{tfOpName:"StringSplit",category:"string",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"delimiter",type:"tensor"}],attrs:[{tfName:"skip_empty",name:"skipEmpty",type:"bool"}],outputs:["indices","values","shape"]},{tfOpName:"StringToHashBucketFast",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"num_buckets",name:"numBuckets",type:"number"}]}]},"1ab7":function(e,t,n){"use strict";n.d(t,"a",(function(){return c}));var r=n("6ae2"),a=n("c05b"),s=n("6ad5"),o=n("54ef");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function i(e){Object(s["b"])("complex64"===e.dtype,()=>`The dtype for tf.spectral.fft() must be complex64 but got ${e.dtype}.`);const t={input:e};return r["a"].runKernel(a["eb"],t)}const c=Object(o["b"])({fft_:i})},"1ba2":function(e,t,n){"use strict";n.d(t,"a",(function(){return c}));var r=n("6ae2"),a=n("c05b"),s=n("a3f7"),o=n("54ef");
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function i(e){const t=Object(s["a"])(e,"x","expm1"),n={x:t};return r["a"].runKernel(a["db"],n)}const c=Object(o["b"])({expm1_:i})},"1df6":function(e,t,n){"use strict";n.d(t,"a",(function(){return c}));var r=n("6ae2"),a=n("c05b"),s=n("a3f7"),o=n("54ef");
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function i(e){const t=Object(s["a"])(e,"x","sign"),n={x:t};return r["a"].runKernel(a["Dc"],n)}const c=Object(o["b"])({sign_:i})},"1e68":function(e,t,n){"use strict";n.d(t,"a",(function(){return c}));var r=n("6ae2"),a=n("c05b"),s=n("a3f7"),o=n("54ef");
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function i(e,t=0,n=!1,o=!1){const i=Object(s["a"])(e,"x","cumsum"),c={x:i},u={axis:t,exclusive:n,reverse:o};return r["a"].runKernel(a["M"],c,u)}const c=Object(o["b"])({cumsum_:i})},"220f":function(e,t,n){"use strict";n.d(t,"a",(function(){return c}));var r=n("6ae2"),a=n("c05b"),s=n("a3f7"),o=n("54ef");
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function i(e){const t=Object(s["a"])(e,"x","asin"),n={x:t};return r["a"].runKernel(a["j"],n)}const c=Object(o["b"])({asin_:i})},"22e3":function(e,t,n){"use strict";n.d(t,"a",(function(){return c}));var r=n("6ae2"),a=n("c05b"),s=n("a3f7"),o=n("54ef");
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function i(e,t){const n=Object(s["a"])(e,"s0","broadcastArgs","int32"),o=Object(s["a"])(t,"s1","broadcastArgs","int32");if(1!==n.rank)throw new Error("broadcastArgs(): first input must be a vector (rank=1). Has rank "+n.rank);if(1!==o.rank)throw new Error("broadcastArgs(): second input must be a vector (rank=1). Has rank "+o.rank);const i={s0:n,s1:o};return r["a"].runKernel(a["v"],i)}const c=Object(o["b"])({broadcastArgs_:i})},"23bf":function(e,t,n){"use strict";
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
var r,a,s,o,i;n.d(t,"a",(function(){return r})),n.d(t,"c",(function(){return u})),n.d(t,"b",(function(){return l})),function(e){e["R0"]="R0",e["R1"]="R1",e["R2"]="R2",e["R3"]="R3",e["R4"]="R4",e["R5"]="R5",e["R6"]="R6"}(r||(r={})),function(e){e["float32"]="float32",e["int32"]="int32",e["bool"]="int32",e["complex64"]="complex64"}(a||(a={})),function(e){e["float32"]="float32",e["int32"]="int32",e["bool"]="bool",e["complex64"]="complex64"}(s||(s={})),function(e){e["float32"]="float32",e["int32"]="float32",e["bool"]="float32",e["complex64"]="complex64"}(o||(o={})),function(e){e["float32"]="complex64",e["int32"]="complex64",e["bool"]="complex64",e["complex64"]="complex64"}(i||(i={}));const c={float32:o,int32:a,bool:s,complex64:i};function u(e,t){if("string"===e||"string"===t){if("string"===e&&"string"===t)return"string";throw new Error(`Can not upcast ${e} with ${t}`)}return c[e][t]}function l(e){return u(e,"int32")}},"24b0":function(e,t,n){"use strict";n.d(t,"a",(function(){return c}));var r=n("6ae2"),a=n("c05b"),s=n("a3f7"),o=n("54ef");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function i(e){const t=Object(s["a"])(e,"input","imag"),n={input:t};return r["a"].runKernel(a["tb"],n)}const c=Object(o["b"])({imag_:i})},"29a8":function(e,t,n){"use strict";(function(e){n("6ae2");var t=n("7ed6"),r=n("b333");
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const a=Object(r["c"])();a.registerFlag("DEBUG",()=>!1,e=>{e&&console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.")}),a.registerFlag("IS_BROWSER",()=>t["isBrowser"]()),a.registerFlag("IS_NODE",()=>"undefined"!==typeof e&&"undefined"!==typeof e.versions&&"undefined"!==typeof e.versions.node),a.registerFlag("IS_CHROME",()=>"undefined"!==typeof navigator&&null!=navigator&&null!=navigator.userAgent&&/Chrome/.test(navigator.userAgent)&&/Google Inc/.test(navigator.vendor)),a.registerFlag("PROD",()=>!1),a.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY",()=>a.getBool("DEBUG")),a.registerFlag("DEPRECATION_WARNINGS_ENABLED",()=>!0),a.registerFlag("IS_TEST",()=>!1),a.registerFlag("CHECK_COMPUTATION_FOR_ERRORS",()=>!0),a.registerFlag("WRAP_TO_IMAGEBITMAP",()=>!1)}).call(this,n("4362"))},"29d8":function(e,t,n){"use strict";n.r(t),n.d(t,"json",(function(){return r}));
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const r=[{tfOpName:"ResizeBilinear",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ResizeNearestNeighbor",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"CropAndResize",category:"image",inputs:[{start:0,name:"image",type:"tensor"},{start:1,name:"boxes",type:"tensor"},{start:2,name:"boxInd",type:"tensor"},{start:3,name:"cropSize",type:"number[]"}],attrs:[{tfName:"method",name:"method",type:"string"},{tfName:"extrapolation_value",name:"extrapolationValue",type:"number"}]}]},"2f2c":function(e,t,n){"use strict";n.d(t,"a",(function(){return u}));var r=n("6ae2"),a=n("c05b"),s=n("a3f7"),o=n("6ad5"),i=n("54ef");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function c(e,t,n,i=!1){const c=Object(s["a"])(e,"x","denseBincount"),u=Object(s["a"])(t,"weights","denseBincount");o["b"]("int32"===c.dtype,()=>"Error in denseBincount: input dtype must be int32, but got "+c.dtype),o["b"](c.rank<=2,()=>`Error in denseBincount: input must be at most rank 2, but got rank ${c.rank}.`),o["b"](n>=0,()=>`size must be non-negative, but got ${n}.`),o["b"](u.size===c.size||0===u.size,()=>`Error in denseBincount: weights must have the same shape as x or 0-length, but got x shape: ${c.shape}, weights shape: `+u.shape+".");const l={x:c,weights:u},d={size:n,binaryOutput:i};return r["a"].runKernel(a["N"],l,d)}const u=Object(i["b"])({denseBincount_:c})},"2fb1":function(e,t,n){"use strict";n.d(t,"a",(function(){return c}));var r=n("6ae2"),a=n("c05b"),s=n("a3f7"),o=n("54ef");
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function i(e,t=0){const n=Object(s["a"])(e,"x","step"),o={x:n},i={alpha:t};return r["a"].runKernel(a["Tc"],o,i)}const c=Object(o["b"])({step_:i})},"31bb":function(e,t,n){"use strict";n.r(t),n.d(t,"json",(function(){return r}));
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const r=[{tfOpName:"Bincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}]},{tfOpName:"DenseBincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}],attrs:[{tfName:"binary_output",name:"binaryOutput",type:"bool"}]},{tfOpName:"Max",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Mean",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Min",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Sum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"All",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Any",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"ArgMax",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"ArgMin",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"Prod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Cumsum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]}]},"34d7":function(e,t,n){"use strict";n.d(t,"b",(function(){return m})),n.d(t,"f",(function(){return x})),n.d(t,"e",(function(){return O})),n.d(t,"d",(function(){return v})),n.d(t,"a",(function(){return w})),n.d(t,"c",(function(){return j}));var r=n("f490"),a=n("6ad5");
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const s=20,o=3,i=7;function c(e,t,n,r){const s=Object(a["j"])(t),o=u(e,t,n,s),i=t.length,c=p(e,t,n,s,o),l=["Tensor"];return r&&(l.push("  dtype: "+n),l.push("  rank: "+i),l.push(`  shape: [${t}]`),l.push("  values:")),l.push(c.map(e=>"    "+e).join("\n")),l.join("\n")}function u(e,t,n,r){const s=Object(a["O"])(t),o=r[r.length-1],i=new Array(o).fill(0),c=t.length,u="complex64"===n?h(e):e;if(c>1)for(let a=0;a<s/o;a++){const e=a*o;for(let t=0;t<o;t++)i[t]=Math.max(i[t],l(u[e+t],0,n).length)}return i}function l(e,t,n){let r;return r=Array.isArray(e)?parseFloat(e[0].toFixed(i))+" + "+parseFloat(e[1].toFixed(i))+"j":Object(a["z"])(e)?`'${e}'`:"bool"===n?d(e):parseFloat(e.toFixed(i)).toString(),Object(a["L"])(r,t)}function d(e){return 0===e?"false":"true"}function p(e,t,n,r,a,i=!0){const c="complex64"===n?2:1,u=t[0],f=t.length;if(0===f){if("complex64"===n){const t=h(e);return[l(t[0],0,n)]}return"bool"===n?[d(e[0])]:[e[0].toString()]}if(1===f){if(u>s){const t=o*c;let r=Array.from(e.slice(0,t)),s=Array.from(e.slice((u-o)*c,u*c));return"complex64"===n&&(r=h(r),s=h(s)),["["+r.map((e,t)=>l(e,a[t],n)).join(", ")+", ..., "+s.map((e,t)=>l(e,a[u-o+t],n)).join(", ")+"]"]}const t="complex64"===n?h(e):Array.from(e);return["["+t.map((e,t)=>l(e,a[t],n)).join(", ")+"]"]}const m=t.slice(1),b=r.slice(1),g=r[0]*c,y=[];if(u>s){for(let t=0;t<o;t++){const r=t*g,s=r+g;y.push(...p(e.slice(r,s),m,n,b,a,!1))}y.push("...");for(let t=u-o;t<u;t++){const r=t*g,s=r+g;y.push(...p(e.slice(r,s),m,n,b,a,t===u-1))}}else for(let s=0;s<u;s++){const t=s*g,r=t+g;y.push(...p(e.slice(t,r),m,n,b,a,s===u-1))}const x=2===f?",":"";y[0]="["+y[0]+x;for(let s=1;s<y.length-1;s++)y[s]=" "+y[s]+x;let O=",\n";for(let s=2;s<f;s++)O+="\n";return y[y.length-1]=" "+y[y.length-1]+"]"+(i?"":O),y}function h(e){const t=[];for(let n=0;n<e.length;n+=2)t.push([e[n],e[n+1]]);return t}var f=n("eb7e");
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class m{constructor(e,t,n){if(this.dtype=t,this.shape=e.slice(),this.size=a["O"](e),null!=n){const e=n.length;a["b"](e===this.size,()=>`Length of values '${e}' does not match the size inferred by the shape '${this.size}'.`)}if("complex64"===t)throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");this.values=n||a["n"](t,this.size),this.strides=Object(a["j"])(e)}set(e,...t){0===t.length&&(t=[0]),a["b"](t.length===this.rank,()=>`The number of provided coordinates (${t.length}) must match the rank (${this.rank})`);const n=this.locToIndex(t);this.values[n]=e}get(...e){0===e.length&&(e=[0]);let t=0;for(const r of e){if(r<0||r>=this.shape[t]){const t=`Requested out of range element at ${e}.   Buffer shape=`+this.shape;throw new Error(t)}t++}let n=e[e.length-1];for(let r=0;r<e.length-1;++r)n+=this.strides[r]*e[r];return this.values[n]}locToIndex(e){if(0===this.rank)return 0;if(1===this.rank)return e[0];let t=e[e.length-1];for(let n=0;n<e.length-1;++n)t+=this.strides[n]*e[n];return t}indexToLoc(e){if(0===this.rank)return[];if(1===this.rank)return[e];const t=new Array(this.shape.length);for(let n=0;n<t.length-1;++n)t[n]=Math.floor(e/this.strides[n]),e-=t[n]*this.strides[n];return t[t.length-1]=e,t}get rank(){return this.shape.length}toTensor(){return b().makeTensor(this.values,this.shape,this.dtype)}}let b=null,g=null,y=null;function x(e){b=e}function O(e){g=e}function v(e){y=e}class w{constructor(e,t,n,r){this.kept=!1,this.isDisposedInternal=!1,this.shape=e.slice(),this.dtype=t||"float32",this.size=a["O"](e),this.strides=Object(a["j"])(e),this.dataId=n,this.id=r,this.rankType=this.rank<5?this.rank.toString():"higher"}get rank(){return this.shape.length}async buffer(){const e=await this.data();return g.buffer(this.shape,this.dtype,e)}bufferSync(){return g.buffer(this.shape,this.dtype,this.dataSync())}async array(){const e=await this.data();return Object(a["U"])(this.shape,e,"complex64"===this.dtype)}arraySync(){return Object(a["U"])(this.shape,this.dataSync(),"complex64"===this.dtype)}async data(){this.throwIfDisposed();const e=b().read(this.dataId);if("string"===this.dtype){const n=await e;try{return n.map(e=>f["decodeString"](e))}catch(t){throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}}return e}dataSync(){this.throwIfDisposed();const e=b().readSync(this.dataId);if("string"===this.dtype)try{return e.map(e=>f["decodeString"](e))}catch(t){throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}return e}async bytes(){this.throwIfDisposed();const e=await b().read(this.dataId);return"string"===this.dtype?e:new Uint8Array(e.buffer)}dispose(){this.isDisposed||(b().disposeTensor(this),this.isDisposedInternal=!0)}get isDisposed(){return this.isDisposedInternal}throwIfDisposed(){if(this.isDisposed)throw new Error("Tensor is disposed.")}print(e=!1){return g.print(this,e)}clone(){return this.throwIfDisposed(),g.clone(this)}toString(e=!1){const t=this.dataSync();return c(t,this.shape,this.dtype,e)}cast(e){return this.throwIfDisposed(),g.cast(this,e)}variable(e=!0,t,n){return this.throwIfDisposed(),b().makeVariable(this,e,t,n)}}function k(){return Object(r["a"])("Tensor",()=>w)}Object.defineProperty(w,Symbol.hasInstance,{value:e=>!!e&&null!=e.data&&null!=e.dataSync&&null!=e.throwIfDisposed}),k();class j extends w{constructor(e,t,n,r){super(e.shape,e.dtype,e.dataId,r),this.trainable=t,this.name=n}assign(e){if(e.dtype!==this.dtype)throw new Error(`dtype of the new value (${e.dtype}) and previous value (${this.dtype}) must match`);if(!a["a"](e.shape,this.shape))throw new Error(`shape of the new value (${e.shape}) and previous value (${this.shape}) must match`);b().disposeTensor(this),this.dataId=e.dataId,b().incRef(this,null)}dispose(){b().disposeVariable(this),this.isDisposedInternal=!0}}Object.defineProperty(j,Symbol.hasInstance,{value:e=>e instanceof w&&null!=e.assign&&e.assign instanceof Function})},"350f":function(e,t,n){"use strict";(function(e){n.d(t,"f",(function(){return c})),n.d(t,"e",(function(){return u})),n.d(t,"a",(function(){return h})),n.d(t,"b",(function(){return f})),n.d(t,"d",(function(){return m})),n.d(t,"c",(function(){return b})),n.d(t,"i",(function(){return g})),n.d(t,"g",(function(){return y})),n.d(t,"h",(function(){return x}));var r=n("0777"),a=n("357d"),s=n("6ad5"),o=n("9847");
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const i=4;async function c(e,t){const n=[],r=[],a=Array.isArray(e)?e.map(e=>e.name):Object.keys(e);for(let o=0;o<a.length;++o){const s=a[o],c=Array.isArray(e)?e[o].tensor:e[s];if("float32"!==c.dtype&&"int32"!==c.dtype&&"bool"!==c.dtype&&"string"!==c.dtype&&"complex64"!==c.dtype)throw new Error(`Unsupported dtype in weight '${s}': ${c.dtype}`);const u={name:s,shape:c.shape,dtype:c.dtype};if("string"===c.dtype){const e=new Promise(async e=>{const t=await c.bytes(),n=t.reduce((e,t)=>e+t.length,0)+i*t.length,r=new Uint8Array(n);let a=0;for(let s=0;s<t.length;s++){const e=t[s],n=new Uint8Array(new Uint32Array([e.length]).buffer);r.set(n,a),a+=i,r.set(e,a),a+=e.length}e(r)});r.push(e)}else r.push(c.data());null!=t&&(u.group=t),n.push(u)}const s=await Promise.all(r);return{data:l(s),specs:n}}function u(e,t){const n={};let c,u=0;for(const l of t){const t=l.name,d=l.dtype,p=l.shape,h=Object(s["O"])(p);let f;if("quantization"in l){const n=l.quantization;if("uint8"===n.dtype||"uint16"===n.dtype){if(!("min"in n)||!("scale"in n))throw new Error(`Weight ${l.name} with quantization ${n.dtype} doesn't have corresponding metadata min and scale.`)}else{if("float16"!==n.dtype)throw new Error(`Weight ${l.name} has unknown quantization dtype ${n.dtype}. Supported quantization dtypes are: 'uint8', 'uint16', and 'float16'.`);if("float32"!==d)throw new Error(`Weight ${l.name} is quantized with ${n.dtype} which only supports weights of type float32 not ${d}.`)}const r=o["a"][n.dtype],a=e.slice(u,u+h*r),s="uint8"===n.dtype?new Uint8Array(a):new Uint16Array(a);if("float32"===d)if("uint8"===n.dtype||"uint16"===n.dtype){f=new Float32Array(s.length);for(let e=0;e<s.length;e++){const t=s[e];f[e]=t*n.scale+n.min}}else{if("float16"!==n.dtype)throw new Error(`Unsupported quantization type ${n.dtype} for weight type float32.`);void 0===c&&(c=k()),f=c(s)}else{if("int32"!==d)throw new Error(`Unsupported dtype in weight '${t}': ${d}`);if("uint8"!==n.dtype&&"uint16"!==n.dtype)throw new Error(`Unsupported quantization type ${n.dtype} for weight type int32.`);f=new Int32Array(s.length);for(let e=0;e<s.length;e++){const t=s[e];f[e]=Math.round(t*n.scale+n.min)}}u+=h*r}else if("string"===d){const t=Object(s["O"])(l.shape);f=[];for(let n=0;n<t;n++){const t=new Uint32Array(e.slice(u,u+i))[0];u+=i;const n=new Uint8Array(e.slice(u,u+t));f.push(n),u+=t}}else{const s=o["a"][d],i=e.slice(u,u+h*s);if("float32"===d)f=new Float32Array(i);else if("int32"===d)f=new Int32Array(i);else if("bool"===d)f=new Uint8Array(i);else{if("complex64"!==d)throw new Error(`Unsupported dtype in weight '${t}': ${d}`);{f=new Float32Array(i);const e=new Float32Array(f.length/2),s=new Float32Array(f.length/2);for(let t=0;t<e.length;t++)e[t]=f[2*t],s[t]=f[2*t+1];const o=Object(a["a"])(e,p,"float32"),c=Object(a["a"])(s,p,"float32");n[t]=Object(r["a"])(o,c),o.dispose(),c.dispose()}}u+=h*s}"complex64"!==d&&(n[t]=Object(a["a"])(f,p,d))}return n}function l(e){if(null===e)throw new Error("Invalid input value: "+JSON.stringify(e));let t=0;const n=[];e.forEach(e=>{if(t+=e.byteLength,n.push(e.byteLength===e.buffer.byteLength?e:new e.constructor(e)),!(e instanceof Float32Array||e instanceof Int32Array||e instanceof Uint8Array))throw new Error("Unsupported TypedArray subtype: "+e.constructor.name)});const r=new Uint8Array(t);let a=0;return n.forEach(e=>{r.set(new Uint8Array(e.buffer),a),a+=e.byteLength}),r.buffer}const d="undefined"!==typeof e&&("undefined"===typeof Blob||"undefined"===typeof atob||"undefined"===typeof btoa);function p(t){return d?e.byteLength(t):new Blob([t]).size}function h(t){if(d)return e.from(t).toString("base64");const n=new Uint8Array(t);let r="";for(let e=0,a=n.length;e<a;e++)r+=String.fromCharCode(n[e]);return btoa(r)}function f(t){if(d){const n=e.from(t,"base64");return n.buffer.slice(n.byteOffset,n.byteOffset+n.byteLength)}const n=atob(t),r=new Uint8Array(n.length);for(let e=0;e<n.length;++e)r.set([n.charCodeAt(e)],e);return r.buffer}function m(e){if(1===e.length)return e[0];let t=0;e.forEach(e=>{t+=e.byteLength});const n=new Uint8Array(t);let r=0;return e.forEach(e=>{n.set(new Uint8Array(e),r),r+=e.byteLength}),n.buffer}function b(e){const t="/";e=e.trim();while(e.endsWith(t))e=e.slice(0,e.length-1);const n=e.split(t);return n[n.length-1]}function g(e,t){const n={modelTopology:e.modelTopology,format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy,weightsManifest:t};return null!=e.signature&&(n.signature=e.signature),null!=e.userDefinedMetadata&&(n.userDefinedMetadata=e.userDefinedMetadata),null!=e.modelInitializer&&(n.modelInitializer=e.modelInitializer),null!=e.trainingConfig&&(n.trainingConfig=e.trainingConfig),n}async function y(e,t){const n={modelTopology:e.modelTopology,format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy};if(null!=e.trainingConfig&&(n.trainingConfig=e.trainingConfig),null!=e.weightsManifest){const[r,a]=await t(e.weightsManifest);n.weightSpecs=r,n.weightData=a}return null!=e.signature&&(n.signature=e.signature),null!=e.userDefinedMetadata&&(n.userDefinedMetadata=e.userDefinedMetadata),null!=e.modelInitializer&&(n.modelInitializer=e.modelInitializer),n}function x(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("Expected JSON model topology, received ArrayBuffer.");return{dateSaved:new Date,modelTopologyType:"JSON",modelTopologyBytes:null==e.modelTopology?0:p(JSON.stringify(e.modelTopology)),weightSpecsBytes:null==e.weightSpecs?0:p(JSON.stringify(e.weightSpecs)),weightDataBytes:null==e.weightData?0:e.weightData.byteLength}}function O(){const e=e=>{let t=e<<13,n=0;while(0===(8388608&t))n-=8388608,t<<=1;return t&=-8388609,n+=947912704,t|n},t=new Uint32Array(2048);t[0]=0;for(let n=1;n<1024;n++)t[n]=e(n);for(let n=1024;n<2048;n++)t[n]=939524096+(n-1024<<13);return t}function v(){const e=new Uint32Array(64);e[0]=0,e[31]=1199570944,e[32]=2147483648,e[63]=3347054592;for(let t=1;t<31;t++)e[t]=t<<23;for(let t=33;t<63;t++)e[t]=2147483648+(t-32<<23);return e}function w(){const e=new Uint32Array(64);for(let t=0;t<64;t++)e[t]=1024;return e[0]=e[32]=0,e}function k(){const e=O(),t=v(),n=w();return r=>{const a=new ArrayBuffer(4*r.length),s=new Uint32Array(a);for(let o=0;o<r.length;o++){const a=r[o],i=e[n[a>>10]+(1023&a)]+t[a>>10];s[o]=i}return new Float32Array(a)}}}).call(this,n("b639").Buffer)},"357d":function(e,t,n){"use strict";n.d(t,"a",(function(){return s}));var r=n("a3f7"),a=n("5959");
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function s(e,t,n){const s=Object(r["c"])(e,n);return Object(a["a"])(e,t,s,n)}},"35c9":function(e,t,n){"use strict";n.d(t,"a",(function(){return c}));var r=n("6ae2"),a=n("c05b"),s=n("a3f7"),o=n("54ef");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function i(e,t){const n=Object(s["a"])(e,"x","reshape","string_or_numeric"),o={x:n},i={shape:t};return r["a"].runKernel(a["qc"],o,i)}const c=Object(o["b"])({reshape_:i})},"364e":function(e,t,n){"use strict";n.d(t,"a",(function(){return u}));var r=n("6ae2"),a=n("c05b"),s=n("a3f7"),o=n("6ad5"),i=n("54ef");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function c(e,t,n="NHWC"){const i=Object(s["a"])(e,"x","depthToSpace"),c="NHWC"===n?i.shape[1]:i.shape[2],u="NHWC"===n?i.shape[2]:i.shape[3],l="NHWC"===n?i.shape[3]:i.shape[1];o["b"](c*t>=0,()=>`Negative dimension size caused by overflow when multiplying\n    ${c} and ${t}  for depthToSpace with input shape\n    ${i.shape}`),o["b"](u*t>=0,()=>`Negative dimension size caused by overflow when multiplying\n    ${u} and ${t} for depthToSpace with input shape\n        ${i.shape}`),o["b"](l%(t*t)===0,()=>`Dimension size must be evenly divisible by ${t*t} but is ${l} for depthToSpace with input shape ${i.shape}`);const d={x:i},p={blockSize:t,dataFormat:n};return r["a"].runKernel(a["O"],d,p)}const u=Object(i["b"])({depthToSpace_:c})},"36e5":function(e,t,n){"use strict";n.d(t,"b",(function(){return a})),n.d(t,"c",(function(){return s})),n.d(t,"d",(function(){return o})),n.d(t,"e",(function(){return i})),n.d(t,"a",(function(){return c})),n.d(t,"f",(function(){return u})),n.d(t,"h",(function(){return l})),n.d(t,"g",(function(){return d}));var r=n("6ad5");
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function a(e,t){for(let n=0;n<e.length;++n)if(e[e.length-n-1]!==t-1-n)return!1;return!0}function s(e,t,n){const r=e.length+t.length,a=[];let s=0,o=0;for(let i=0;i<r;i++)-1===n.indexOf(i)?a.push(e[s++]):a.push(t[o++]);return a}function o(e,t){const n=[],r=e.length;for(let s=0;s<r;s++)-1===t.indexOf(s)&&n.push(e[s]);const a=t.map(t=>e[t]);return[n,a]}function i(e,t){const n=t.map(e=>1);return s(e,n,t)}function c(e,t,n){r["b"](a(t,n),()=>e+" supports only inner-most axes for now. "+`Got axes ${t} and rank-${n} input.`)}function u(e,t){if(a(e,t))return null;const n=[];for(let r=0;r<t;++r)-1===e.indexOf(r)&&n.push(r);return e.forEach(e=>n.push(e)),n}function l(e){return e.map((e,t)=>[t,e]).sort((e,t)=>e[1]-t[1]).map(e=>e[0])}function d(e,t){const n=[];for(let r=t-e;r<t;++r)n.push(r);return n}},"3a44":function(e,t,n){"use strict";n.d(t,"a",(function(){return u}));var r=n("6ae2"),a=n("c05b"),s=n("a3f7"),o=n("6ad5"),i=n("54ef");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function c(e,t=0){const n=Object(s["a"])(e,"x","unstack","string_or_numeric");o["b"](t>=-n.shape.length&&t<n.shape.length,()=>`Axis = ${t} is not in [-${n.shape.length}, ${n.shape.length})`);const i={value:n},c={axis:t};return r["a"].runKernel(a["hd"],i,c)}const u=Object(i["b"])({unstack_:c})},"3b28":function(e,t,n){"use strict";n.d(t,"a",(function(){return u}));var r=n("6ae2"),a=n("c05b"),s=n("a3f7"),o=n("6ad5"),i=n("54ef");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function c(e,t,n){const i=Object(s["a"])(e,"x","batchToSpaceND"),c=t.reduce((e,t)=>e*t);o["b"](i.rank>=1+t.length,()=>`input rank is ${i.rank} but should be > than blockShape.length ${t.length}`),o["b"](n.length===t.length,()=>`crops.length is ${n.length} but should be equal to blockShape.length  ${t.length}`),o["b"](i.shape[0]%c===0,()=>`input tensor batch is ${i.shape[0]} but is not divisible by the product of the elements of blockShape ${t.join(" * ")} === ${c}`);const u={x:i},l={blockShape:t,crops:n};return r["a"].runKernel(a["t"],u,l)}const u=Object(i["b"])({batchToSpaceND_:c})},"3bb7":function(e,t,n){"use strict";n.d(t,"a",(function(){return c}));var r=n("6ae2"),a=n("c05b"),s=n("a3f7"),o=n("54ef");
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function i(e){const t=Object(s["a"])(e,"x","neg"),n={x:t};return r["a"].runKernel(a["Xb"],n)}const c=Object(o["b"])({neg_:i})},"3bfc":function(e,t,n){"use strict";n.r(t),n.d(t,"json",(function(){return r}));
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const r=[{tfOpName:"FusedBatchNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV2",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV3",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"LRN",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"depth_radius",name:"radius",type:"number",defaultValue:5},{tfName:"bias",name:"bias",type:"number",defaultValue:1},{tfName:"alpha",name:"alpha",type:"number",defaultValue:1},{tfName:"beta",name:"beta",type:"number",defaultValue:.5}]},{tfOpName:"Softmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"LogSoftmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"SparseToDense",category:"normalization",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!0,notSupported:!0}]}]},"3c35":function(e,t){(function(t){e.exports=t}).call(this,{})},"3d50":function(e,t,n){"use strict";n.r(t),n.d(t,"json",(function(){return r}));
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const r=[{tfOpName:"PlaceholderWithDefault",category:"graph",inputs:[{start:0,name:"default",type:"tensor"}],attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Placeholder",category:"graph",attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Const",category:"graph"},{tfOpName:"Identity",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IdentityN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Snapshot",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Rank",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Size",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Shape",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"ShapeN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Print",category:"graph",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"data",type:"tensors"}],attrs:[{tfName:"message",name:"message",type:"string"},{tfName:"first_n",name:"firstN",type:"number",notSupported:!0},{tfName:"summarize",name:"summarize",type:"number",defaultValue:3}]},{tfOpName:"NoOp",category:"graph",inputs:[]},{tfOpName:"StopGradient",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"FakeQuantWithMinMaxVars",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"min",name:"min",type:"number"},{tfName:"max",name:"max",type:"number"}]}]},"3efc":function(e,t,n){"use strict";n.d(t,"a",(function(){return u}));var r=n("6ae2"),a=n("c05b"),s=n("a3f7"),o=n("54ef"),i=n("35c9");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function c(e,t,n,o=!1){const c=Object(s["a"])(e,"logits","multinomial"),u=c.size,l=c.rank;if(u<2)throw new Error("Error in multinomial: you need at least 2 outcomes, but got "+u+".");if(l>2)throw new Error("Rank of probabilities must be 1 or 2, but is "+l);n=n||Math.random();const d=1===l?Object(i["a"])(c,[1,-1]):c,p={logits:d},h={numSamples:t,seed:n,normalized:o},f=r["a"].runKernel(a["Vb"],p,h);return 1===l?Object(i["a"])(f,[f.size]):f}const u=Object(o["b"])({multinomial_:c})},4:function(e,t){},4184:function(e,t,n){"use strict";n.d(t,"a",(function(){return l}));var r=n("6ae2"),a=n("c05b"),s=n("76c2"),o=n("a3f7"),i=n("526f"),c=n("54ef");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function u(e,t){let n=Object(o["a"])(e,"a","squaredDifference"),c=Object(o["a"])(t,"b","squaredDifference");[n,c]=Object(s["makeTypesMatch"])(n,c),Object(i["a"])(n.shape,c.shape);const u={a:n,b:c},l={};return r["a"].runKernel(a["Sc"],u,l)}const l=Object(c["b"])({squaredDifference_:u})},4362:function(e,t,n){t.nextTick=function(e){var t=Array.prototype.slice.call(arguments);t.shift(),setTimeout((function(){e.apply(null,t)}),0)},t.platform=t.arch=t.execPath=t.title="browser",t.pid=1,t.browser=!0,t.env={},t.argv=[],t.binding=function(e){throw new Error("No such module. (Possibly not yet loaded)")},function(){var e,r="/";t.cwd=function(){return r},t.chdir=function(t){e||(e=n("df7c")),r=e.resolve(t,r)}}(),t.exit=t.kill=t.umask=t.dlopen=t.uptime=t.memoryUsage=t.uvCounters=function(){},t.features={}},"441e":function(e,t,n){},4516:function(e,t,n){"use strict";n.d(t,"a",(function(){return c}));var r=n("6ae2"),a=n("c05b"),s=n("a3f7"),o=n("54ef");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function i(e,t=null,n=!1){const o=Object(s["a"])(e,"x","any","bool"),i={x:o},c={axis:t,keepDims:n};return r["a"].runKernel(a["g"],i,c)}const c=Object(o["b"])({any_:i})},"45bb":function(e,t,n){"use strict";n.d(t,"a",(function(){return c}));var r=n("6ae2"),a=n("c05b"),s=n("a3f7"),o=n("54ef");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function i(e,t,n=0){const o=Object(s["a"])(e,"x","split"),i={x:o},c={numOrSizeSplits:t,axis:n};return r["a"].runKernel(a["Pc"],i,c)}const c=Object(o["b"])({split_:i})},4611:function(e,t,n){"use strict";n.d(t,"a",(function(){return u}));var r=n("6ae2"),a=n("c05b"),s=n("76c2"),o=n("a3f7"),i=n("54ef");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function c(e,t){let n=Object(o["a"])(e,"a","mod"),i=Object(o["a"])(t,"b","mod");[n,i]=Object(s["makeTypesMatch"])(n,i);const c={a:n,b:i};return r["a"].runKernel(a["Ub"],c)}const u=Object(i["b"])({mod_:c})},4615:function(e,t,n){"use strict";n.d(t,"a",(function(){return c}));var r=n("6ae2"),a=n("c05b"),s=n("a3f7"),o=n("54ef");
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function i(e){const t=Object(s["a"])(e,"x","acosh"),n={x:t};return r["a"].runKernel(a["c"],n)}const c=Object(o["b"])({acosh_:i})},"46a8":function(e,t,n){"use strict";n.d(t,"a",(function(){return c}));var r=n("6ae2"),a=n("c05b"),s=n("a3f7"),o=n("54ef");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function i(e){const t=Object(s["a"])(e,"x","relu6"),n={x:t};return r["a"].runKernel(a["pc"],n)}const c=Object(o["b"])({relu6_:i})},"46b1":function(e,t,n){"use strict";n.d(t,"a",(function(){return c}));var r=n("6ae2"),a=n("c05b"),s=n("a3f7"),o=n("54ef");
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function i(e){const t=Object(s["a"])(e,"x","log1p"),n={x:t};return r["a"].runKernel(a["Eb"],n)}const c=Object(o["b"])({log1p_:i})},"46b8":function(e,t,n){"use strict";n.d(t,"a",(function(){return s}));var r=n("6ae2"),a=n("c05b");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function s(e,t,n){const s={shape:e,value:t,dtype:n};return r["a"].runKernel(a["fb"],{},s)}},"46cc":function(e,t,n){"use strict";
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */
var r,a;n.d(t,"a",(function(){return r})),function(e){e[e["DT_INVALID"]=0]="DT_INVALID",e[e["DT_FLOAT"]=1]="DT_FLOAT",e[e["DT_DOUBLE"]=2]="DT_DOUBLE",e[e["DT_INT32"]=3]="DT_INT32",e[e["DT_UINT8"]=4]="DT_UINT8",e[e["DT_INT16"]=5]="DT_INT16",e[e["DT_INT8"]=6]="DT_INT8",e[e["DT_STRING"]=7]="DT_STRING",e[e["DT_COMPLEX64"]=8]="DT_COMPLEX64",e[e["DT_INT64"]=9]="DT_INT64",e[e["DT_BOOL"]=10]="DT_BOOL",e[e["DT_QINT8"]=11]="DT_QINT8",e[e["DT_QUINT8"]=12]="DT_QUINT8",e[e["DT_QINT32"]=13]="DT_QINT32",e[e["DT_BFLOAT16"]=14]="DT_BFLOAT16",e[e["DT_FLOAT_REF"]=101]="DT_FLOAT_REF",e[e["DT_DOUBLE_REF"]=102]="DT_DOUBLE_REF",e[e["DT_INT32_REF"]=103]="DT_INT32_REF",e[e["DT_UINT8_REF"]=104]="DT_UINT8_REF",e[e["DT_INT16_REF"]=105]="DT_INT16_REF",e[e["DT_INT8_REF"]=106]="DT_INT8_REF",e[e["DT_STRING_REF"]=107]="DT_STRING_REF",e[e["DT_COMPLEX64_REF"]=108]="DT_COMPLEX64_REF",e[e["DT_INT64_REF"]=109]="DT_INT64_REF",e[e["DT_BOOL_REF"]=110]="DT_BOOL_REF",e[e["DT_QINT8_REF"]=111]="DT_QINT8_REF",e[e["DT_QUINT8_REF"]=112]="DT_QUINT8_REF",e[e["DT_QINT32_REF"]=113]="DT_QINT32_REF",e[e["DT_BFLOAT16_REF"]=114]="DT_BFLOAT16_REF"}(r||(r={})),function(e){let t;(function(e){e[e["LEGACY"]=0]="LEGACY",e[e["V1"]=1]="V1",e[e["V2"]=2]="V2"})(t=e.CheckpointFormatVersion||(e.CheckpointFormatVersion={}))}(a||(a={}))},4749:function(e,t,n){"use strict";n.d(t,"c",(function(){return f})),n.d(t,"b",(function(){return m})),n.d(t,"a",(function(){return b})),n.d(t,"d",(function(){return g}));var r=n("526f"),a=n("9e38"),s=n("6f37"),o=n("a5aa"),i=n("520f"),c=n("917a"),u=n("46a8"),l=n("35c9"),d=n("ffb3"),p=n("2fb1"),h=n("e053");
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function f(e,t,n){if(null==n||"linear"===n)return e;if("relu"===n)return Object(o["a"])(e,Object(p["a"])(t));throw new Error(`Cannot compute gradient for fused activation ${n}.`)}function m(e,t){let n=t;const a=r["c"](e.shape,t.shape);return a.length>0&&(n=Object(h["a"])(n,a)),Object(l["a"])(n,e.shape)}function b(e,t,n,r){if("linear"===t)return e;if("relu"===t)return Object(c["a"])(e);if("elu"===t)return Object(a["a"])(e);if("relu6"===t)return Object(u["a"])(e);if("prelu"===t)return Object(i["a"])(e,n);if("leakyrelu"===t)return Object(s["a"])(e,r);if("sigmoid"===t)return Object(d["a"])(e);throw new Error(`Unknown fused activation ${t}.`)}const g=(e,t)=>{const n=e>0;return!n||"linear"===t}},4850:function(e,t,n){"use strict";n.d(t,"a",(function(){return u}));var r=n("6ae2"),a=n("c05b"),s=n("a3f7"),o=n("6ad5"),i=n("54ef");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function c(e){o["b"](Array.isArray(e),()=>"The argument passed to tf.addN() must be a list of tensors"),o["b"](e.length>=1,()=>"Must pass at least one tensor to tf.addN(), but got "+e.length);const t=e.map((e,t)=>Object(s["a"])(e,"tensors"+t,"addN")),n=t[0];t.forEach(e=>{if(e.dtype!==n.dtype)throw new Error("All tensors passed to tf.addN() must have the same dtype")}),t.forEach(e=>{if(!o["a"](e.shape,n.shape))throw new Error("All tensors passed to tf.addN() must have the same shape")});const i=t;return r["a"].runKernel(a["e"],i)}const u=Object(i["b"])({addN_:c})},"487b":function(e,t,n){"use strict";n.d(t,"a",(function(){return u}));var r=n("6ae2"),a=n("c05b"),s=n("76c2"),o=n("a3f7"),i=n("54ef");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function c(e,t,n=!1,i=!1){let c=Object(o["a"])(e,"a","matMul"),u=Object(o["a"])(t,"b","matMul");[c,u]=Object(s["makeTypesMatch"])(c,u);const l={a:c,b:u},d={transposeA:n,transposeB:i};return r["a"].runKernel(a["s"],l,d)}const u=Object(i["b"])({matMul_:c})},"48db":function(e,t,n){"use strict";n.d(t,"a",(function(){return l}));var r=n("6ae2"),a=n("c05b"),s=n("a3f7"),o=n("f0a9"),i=n("54ef"),c=n("35c9");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function u(e,t){let n=Object(s["a"])(e,"broadcastTo","x");const i=n.shape;if(t.some(e=>!(e>0)||e%1!==0))throw new Error(`broadcastTo(): Invalid broadcast shape [${t}].`);if(t.length<n.rank)throw new Error(`broadcastTo(): shape.length=${t.length} < input.rank=${n.rank}.`);if(t.length>n.rank){const e=n.shape.slice();while(e.length<t.length)e.unshift(1);n=Object(c["a"])(n,e)}const u=n.shape,l=Array.from(t);for(let r=t.length-1;r>=0;r--)if(u[r]===t[r])l[r]=1;else if(1!==n.shape[r])throw new Error(`broadcastTo(): [${i}] cannot be broadcast to [${t}].`);const d=l.map((e,t)=>e>1?t:-1).filter(e=>e>=0);if(0===d.length)return Object(o["a"])(n);const p={x:n},h={reps:l};return r["a"].runKernel(a["cd"],p,h)}const l=Object(i["b"])({broadcastTo_:u})},"4b05":function(e,t,n){"use strict";(function(e){var t=n("b333");
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const r={importFetch:()=>n(4)};let a;class s{constructor(){this.util=n(5),this.textEncoder=new this.util.TextEncoder}fetch(e,n){return null!=Object(t["c"])().global.fetch?Object(t["c"])().global.fetch(e,n):(null==a&&(a=r.importFetch()),a(e,n))}now(){const t=e.hrtime();return 1e3*t[0]+t[1]/1e6}encode(e,t){if("utf-8"!==t&&"utf8"!==t)throw new Error("Node built-in encoder only supports utf-8, but got "+t);return this.textEncoder.encode(e)}decode(e,t){return 0===e.length?"":new this.util.TextDecoder(t).decode(e)}}Object(t["c"])().get("IS_NODE")&&Object(t["c"])().setPlatform("node",new s)}).call(this,n("4362"))},"4c7a":function(e,t,n){"use strict";n.d(t,"a",(function(){return c}));var r=n("6ae2"),a=n("c05b"),s=n("6ad5"),o=n("54ef");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function i(e){Object(s["b"])("complex64"===e.dtype,()=>`The dtype for tf.spectral.ifft() must be complex64 but got ${e.dtype}.`);const t={input:e};return r["a"].runKernel(a["rb"],t)}const c=Object(o["b"])({ifft_:i})},"4f20":function(e,t,n){"use strict";n.d(t,"a",(function(){return c}));var r=n("6ae2"),a=n("c05b"),s=n("a3f7"),o=n("54ef");
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function i(e){const t=Object(s["a"])(e,"x","exp"),n={x:t};return r["a"].runKernel(a["bb"],n)}const c=Object(o["b"])({exp_:i})},5:function(e,t){},"508f":function(e,t,n){"use strict";n.d(t,"a",(function(){return u}));var r=n("6ae2"),a=n("c05b"),s=n("76c2"),o=n("a3f7"),i=n("54ef");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function c(e,t){let n=Object(o["a"])(e,"a","floorDiv"),i=Object(o["a"])(t,"b","floorDiv");[n,i]=Object(s["makeTypesMatch"])(n,i);const c={a:n,b:i};return r["a"].runKernel(a["ib"],c)}const u=Object(i["b"])({floorDiv_:c})},"520f":function(e,t,n){"use strict";n.d(t,"a",(function(){return c}));var r=n("6ae2"),a=n("c05b"),s=n("a3f7"),o=n("54ef");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function i(e,t){const n=Object(s["a"])(e,"x","prelu"),o=Object(s["a"])(t,"alpha","prelu"),i={x:n,alpha:o};return r["a"].runKernel(a["ic"],i)}const c=Object(o["b"])({prelu_:i})},"526c":function(e,t,n){"use strict";n.d(t,"d",(function(){return a})),n.d(t,"e",(function(){return s})),n.d(t,"f",(function(){return o})),n.d(t,"b",(function(){return i})),n.d(t,"g",(function(){return u})),n.d(t,"c",(function(){return l})),n.d(t,"a",(function(){return d}));var r=n("fa11");
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function a(e,t,n,a,o){const i=t.inputParams[e];if(i&&void 0!==i.inputIndexStart){const e=i.inputIndexStart,c=0===i.inputIndexEnd?void 0:void 0===i.inputIndexEnd?e+1:i.inputIndexEnd;if("tensor"===i.type)return s(t.inputNames[i.inputIndexStart],n,a,o);if("tensors"===i.type){const r=t.inputNames.slice(e,c);return r.map(e=>s(e,n,a,o))}const u=s(t.inputNames.slice(e)[0],n,a,o),l=u.dataSync();return"number"===i.type?l[0]:r["util"].toNestedArray(u.shape,l)}const c=t.attrParams[e];return c&&c.value}function s(e,t,n,r){const[a,s]=u(e);if(null!=r){const e=r.getHashTableHandleByName(a);if(null!=e)return e}const o=n.currentContextIds.find(e=>!!t[c(a,e)]);return void 0!==o?t[c(a,o)][s]:void 0}function o(e,t,n){return t[c(e,n.currentContextId)]}function i(e,t){const[n,r,a]=u(e);return[c(n,t&&t.currentContextId),r,a]}function c(e,t){return t?`${e}-${t}`:e}function u(e){const t=e.split(":");if(1===t.length)return[e,0,void 0];const n=t[0],r=3===t.length?t[1]:void 0,a=Number(t[t.length-1]);return[n,a,r]}function l(e,t,n){let r=a("pad",e,t,n);if("explicit"===r){r=a("explicitPaddings",e,t,n);const s=[[0,0],[0,0],[0,0],[0,0]];for(let e=0;e<4;e++)s[e][0]=r[2*e],s[e][1]=r[2*e+1];return s}return r}function d(e){return e.kept?e:Object(r["clone"])(e)}},"526f":function(e,t,n){"use strict";
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function r(e,t){const n=e.length,r=[];for(let a=0;a<n;a++){const s=n-1-a,o=e[s]||1,i=t[t.length-1-a]||1;i>1&&1===o&&r.unshift(s)}return r}function a(e,t){const n=[];for(let r=0;r<t.length;r++){const a=e[e.length-r-1],s=t.length-r-1,o=t[s];(null==a||1===a&&o>1)&&n.unshift(s)}return n}function s(e,t){const n=[],r=Math.max(e.length,t.length);for(let a=0;a<r;a++){let r=e[e.length-a-1];null==r&&(r=1);let s=t[t.length-a-1];if(null==s&&(s=1),1===r)n.unshift(s);else if(1===s)n.unshift(r);else{if(r!==s){const n=`Operands could not be broadcast together with shapes ${e} and ${t}.`;throw Error(n)}n.unshift(r)}}return n}n.d(t,"b",(function(){return r})),n.d(t,"c",(function(){return a})),n.d(t,"a",(function(){return s}))},"538e":function(e,t,n){"use strict";n.d(t,"a",(function(){return p})),n.d(t,"f",(function(){return d})),n.d(t,"d",(function(){return u})),n.d(t,"e",(function(){return l})),n.d(t,"b",(function(){return i})),n.d(t,"c",(function(){return c}));var r=n("6ae2"),a=n("34d7"),s=n("a3f7"),o=n("6ad5");
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function i(e){return o["b"](o["u"](e),()=>"The f passed in grad(f) must be a function"),(t,n)=>{const a=Object(s["a"])(t,"x","tf.grad","string_or_numeric"),i=null!=n?Object(s["a"])(n,"dy","tf.grad"):null;return r["a"].tidy(()=>{const{value:t,grads:n}=r["a"].gradients(()=>e(a),[a],i);return null!=i&&o["e"](t.shape,i.shape,"The shape of dy passed in grad(f)(x, dy) must match the shape returned by f(x)"),h(n),n[0]})}}function c(e){return o["b"](o["u"](e),()=>"The f passed in grads(f) must be a function"),(t,n)=>{o["b"](Array.isArray(t),()=>"The args passed in grads(f)(args) must be an array of `Tensor`s or `TensorLike`s");const a=Object(s["b"])(t,"args","tf.grads","string_or_numeric"),i=null!=n?Object(s["a"])(n,"dy","tf.grads"):null;return r["a"].tidy(()=>{const{value:t,grads:n}=r["a"].gradients(()=>e(...a),a,i);return null!=i&&o["e"](t.shape,i.shape,"The shape of dy passed in grads(f)([x1,...], dy) must match the shape returned by f([x1,...])"),h(n),n})}}function u(e){return o["b"](o["u"](e),()=>"The f passed in valueAndGrad(f) must be a function"),(t,n)=>{o["b"](t instanceof a["a"],()=>"The x passed in valueAndGrad(f)(x) must be a tensor"),o["b"](null==n||n instanceof a["a"],()=>"The dy passed in valueAndGrad(f)(x, dy) must be a tensor");const{grads:s,value:i}=r["a"].gradients(()=>e(t),[t],n);return h(s),{grad:s[0],value:i}}}function l(e){return o["b"](o["u"](e),()=>"The f passed in valueAndGrads(f) must be a function"),(t,n)=>{o["b"](Array.isArray(t)&&t.every(e=>e instanceof a["a"]),()=>"The args passed in valueAndGrads(f)(args) must be array of tensors"),o["b"](null==n||n instanceof a["a"],()=>"The dy passed in valueAndGrads(f)(args, dy) must be a tensor");const s=r["a"].gradients(()=>e(...t),t,n);return null!=n&&o["e"](s.value.shape,n.shape,"The shape of dy passed in valueAndGrads(f)([x1,...], dy) must match the shape returned by f([x1,...])"),h(s.grads),s}}function d(e,t){o["b"](o["u"](e),()=>"The f passed in variableGrads(f) must be a function"),o["b"](null==t||Array.isArray(t)&&t.every(e=>e instanceof a["c"]),()=>"The varList passed in variableGrads(f, varList) must be an array of variables");const n=null!=t;if(!n){t=[];for(const e in r["a"].registeredVariables)t.push(r["a"].registeredVariables[e])}const s=n?t.filter(e=>!e.trainable):null,i=t.length;t=t.filter(e=>e.trainable),o["b"](t.length>0,()=>`variableGrads() expects at least one of the input variables to be trainable, but none of the ${i} variables is trainable.`);const c=!0,{value:u,grads:l}=r["a"].gradients(e,t,null,c);o["b"](l.some(e=>null!=e),()=>"Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize()."),o["b"](0===u.rank,()=>`The f passed in variableGrads(f) must return a scalar, but it returned a rank-${u.rank} tensor`);const d={};return t.forEach((e,t)=>{null!=l[t]&&(d[e.name]=l[t])}),null!=s&&s.forEach(e=>d[e.name]=null),{value:u,grads:d}}function p(e){return r["a"].customGrad(e)}function h(e){const t=e.filter(e=>null==e).length;if(t>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that\n    the f you passed encloses all operations that lead from x to y.")}},"53fd":function(e,t,n){"use strict";n.d(t,"a",(function(){return l}));var r=n("6ae2"),a=n("c05b"),s=n("a3f7"),o=n("6ad5"),i=n("54ef"),c=n("35c9");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function u(e,t=[1,1,1],n,i,u,l="NDHWC"){const d=Object(s["a"])(e,"x","maxPool3d");let p=d,h=!1;4===d.rank&&(h=!0,p=Object(c["a"])(d,[1,d.shape[0],d.shape[1],d.shape[2],d.shape[3]])),o["b"](5===p.rank,()=>`Error in maxPool3d: x must be rank 5 but got rank ${p.rank}.`),o["b"]("NDHWC"===l,()=>"Error in maxPool3d: Only NDHWC is currently supported, but got dataFormat of "+l),null!=u&&o["b"](o["v"](i),()=>`Error in maxPool3d: pad must be an integer when using, dimRoundingMode ${u} but got pad ${i}.`);const f={x:p},m={filterSize:t,strides:n,pad:i,dimRoundingMode:u,dataFormat:l},b=r["a"].runKernel(a["Lb"],f,m);return h?Object(c["a"])(b,[b.shape[1],b.shape[2],b.shape[3],b.shape[4]]):b}const l=Object(i["b"])({maxPool3d_:u})},"54ef":function(e,t,n){"use strict";n.d(t,"a",(function(){return s})),n.d(t,"b",(function(){return o}));var r=n("6ae2"),a=n("6ad5");
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const s="__op";function o(e){const t=Object.keys(e);if(1!==t.length)throw new Error("Please provide an object with a single key (operation name) mapping to a function. Got an object with "+t.length+" keys.");let n=t[0];const o=e[n];n.endsWith("_")&&(n=n.substring(0,n.length-1)),n+=s;const i=(...e)=>{r["a"].startScope(n);try{const t=o(...e);return Object(a["x"])(t)&&console.error("Cannot return a Promise inside of tidy."),r["a"].endScope(t),t}catch(t){throw r["a"].endScope(null),t}};return Object.defineProperty(i,"name",{value:n,configurable:!0}),i}},5616:function(e,t,n){"use strict";n.d(t,"a",(function(){return c}));var r=n("6ae2"),a=n("c05b"),s=n("a3f7"),o=n("54ef");
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function i(e,t=1,n=!0){const o=Object(s["a"])(e,"x","topk");if(0===o.rank)throw new Error("topk() expects the input to be of rank 1 or higher");const i=o.shape[o.shape.length-1];if(t<0)throw new Error("'k' passed to topk() must be >= 0 but got "+t);if(t>i)throw new Error(`'k' passed to topk() must be <= the last dimension (${i}) but got `+t);const c={x:o},u={k:t,sorted:n},[l,d]=r["a"].runKernel(a["dd"],c,u);return{values:l,indices:d}}const c=Object(o["b"])({topk_:i})},"57e0":function(e,t,n){"use strict";
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
var r;n.d(t,"a",(function(){return r})),function(e){e[e["NONE"]=0]="NONE",e[e["MEAN"]=1]="MEAN",e[e["SUM"]=2]="SUM",e[e["SUM_BY_NONZERO_WEIGHTS"]=3]="SUM_BY_NONZERO_WEIGHTS"}(r||(r={}))},5874:function(e,t,n){"use strict";n.r(t),n.d(t,"json",(function(){return r}));const r=[{tfOpName:"EmptyTensorList",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"maxNumElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"LoopCond",category:"control",inputs:[{start:0,name:"pred",type:"tensor"}]},{tfOpName:"Switch",category:"control",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"pred",type:"tensor"}]},{tfOpName:"Merge",category:"control",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"Enter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"frame_name",name:"frameName",type:"string"},{tfName:"is_constant",name:"isConstant",type:"bool"}]},{tfOpName:"Exit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NextIteration",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayV3",category:"control",inputs:[{start:0,name:"size",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"dynamic_size",name:"dynamicSize",type:"bool"},{tfName:"clear_after_read",name:"clearAfterRead",type:"bool"},{tfName:"identical_element_shapes",name:"identicalElementShapes",type:"bool"},{tfName:"tensor_array_name",name:"name",type:"string"}]},{tfOpName:"TensorArrayWriteV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayReadV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayGatherV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"}]},{tfOpName:"TensorArrayScatterV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArrayConcatV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape_except0",name:"elementShapeExcept0",type:"shape",notSupported:!0}]},{tfOpName:"TensorArraySplitV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"tensor",type:"tensor"},{start:2,name:"lengths",type:"number[]"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArraySizeV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}]},{tfOpName:"TensorArrayCloseV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"}]},{tfOpName:"StatelessIf",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"If",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"StatelessWhile",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"While",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"TensorListScatter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListScatterV2",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"},{start:3,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGather",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListSetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListReserve",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListFromTensor",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListStack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"},{tfName:"num_elements",name:"numElements",type:"dtype"}]},{tfOpName:"TensorListSplit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"},{start:2,name:"lengths",type:"number[]"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcat",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPopBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPushBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]}]},5894:function(e,t,n){"use strict";n.d(t,"a",(function(){return s}));var r=n("6ae2"),a=n("c05b");
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function s(e,t,n){if(n<=0)throw new Error("The number of values should be positive.");const s={start:e,stop:t,num:n};return r["a"].runKernel(a["Cb"],{},s)}},5959:function(e,t,n){"use strict";n.d(t,"a",(function(){return o}));var r=n("6ae2"),a=n("6ad5"),s=n("eb7e");
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function o(e,t,n,o){if(null==o&&(o=Object(a["r"])(e)),"complex64"===o)throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");if(!Object(a["A"])(e)&&!Array.isArray(e)&&"number"!==typeof e&&"boolean"!==typeof e&&"string"!==typeof e)throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");if(null!=t){Object(a["c"])(t);const e=Object(a["O"])(t),r=Object(a["O"])(n);Object(a["b"])(e===r,()=>`Based on the provided shape, [${t}], the tensor should have ${e} values but has ${r}`);for(let s=0;s<n.length;++s){const e=n[s],r=s!==n.length-1||e!==Object(a["O"])(t.slice(s));Object(a["b"])(n[s]===t[s]||!r,()=>`Error creating a new Tensor. Inferred shape (${n}) does not match the provided shape (${t}). `)}}return Object(a["A"])(e)||Array.isArray(e)||(e=[e]),t=t||n,e="string"!==o?Object(s["toTypedArray"])(e,o):Object(a["m"])(e,[],!0),r["a"].makeTensor(e,t,o)}},5960:function(e,t,n){"use strict";n.d(t,"a",(function(){return c}));var r=n("6ae2"),a=n("c05b"),s=n("a3f7"),o=n("54ef");
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function i(e){const t=Object(s["a"])(e,"x","ceil"),n={x:t};return r["a"].runKernel(a["y"],n)}const c=Object(o["b"])({ceil_:i})},"5a2c":function(e,t,n){"use strict";n.d(t,"a",(function(){return o}));var r=n("6ae2"),a=n("6ad5"),s=n("0777");
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function o(e,t="float32"){if("complex64"===t){const t=o(e,"float32"),n=o(e,"float32");return Object(s["a"])(t,n)}const n=Object(a["F"])(Object(a["O"])(e),t);return r["a"].makeTensor(n,e,t)}},"5dc4":function(e,t,n){"use strict";n.d(t,"a",(function(){return c}));var r=n("6ae2"),a=n("c05b"),s=n("a3f7"),o=n("54ef");
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function i(e){const t=Object(s["a"])(e,"x","sinh"),n={x:t};return r["a"].runKernel(a["Fc"],n)}const c=Object(o["b"])({sinh_:i})},"5f2a":function(e,t,n){"use strict";n.d(t,"a",(function(){return c}));var r=n("6ae2"),a=n("c05b"),s=n("a3f7"),o=n("54ef");
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function i(e){const t=Object(s["a"])(e,"x","rsqrt"),n={x:t};return r["a"].runKernel(a["yc"],n)}const c=Object(o["b"])({rsqrt_:i})},"5f44":function(e,t,n){"use strict";n.r(t),n.d(t,"json",(function(){return r}));
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const r=[{tfOpName:"SparseFillEmptyRows",category:"sparse",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"denseShape",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}]},{tfOpName:"SparseReshape",category:"sparse",inputs:[{start:0,name:"inputIndices",type:"tensor"},{start:1,name:"inputShape",type:"tensor"},{start:2,name:"newShape",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SparseSegmentMean",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]},{tfOpName:"SparseSegmentSum",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]}]},"5f87":function(e,t,n){"use strict";n.d(t,"a",(function(){return c}));var r=n("6ae2"),a=n("c05b"),s=n("a3f7"),o=n("54ef");
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function i(e,t=-1){const n=Object(s["a"])(e,"logits","softmax","float32");if(-1===t&&(t=n.rank-1),t!==n.rank-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${n.rank} and dim was ${t}`);const o={logits:n},i={dim:t};return r["a"].runKernel(a["Hc"],o,i)}const c=Object(o["b"])({softmax_:i})},6:function(e,t){},6002:function(e,t,n){"use strict";n.d(t,"a",(function(){return u}));var r=n("6ae2"),a=n("c05b"),s=n("76c2"),o=n("a3f7"),i=n("54ef");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function c(e,t){let n=Object(o["a"])(e,"a","atan2"),i=Object(o["a"])(t,"b","atan2");[n,i]=Object(s["makeTypesMatch"])(n,i);const c={a:n,b:i};return r["a"].runKernel(a["m"],c)}const u=Object(i["b"])({atan2_:c})},6125:function(e,t,n){var r=n("1212"),a=n("b838"),s=n("a49e"),o=n("cae0"),i=n("7aec"),c=n("89ed"),u=n("a49d");u.alea=r,u.xor128=a,u.xorwow=s,u.xorshift7=o,u.xor4096=i,u.tychei=c,e.exports=u},"649e":function(e,t,n){"use strict";n.d(t,"a",(function(){return l}));var r=n("6ae2"),a=n("c05b"),s=n("a3f7"),o=n("6ad5"),i=n("f0a9"),c=n("54ef");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function u(e,t=0){Object(o["b"])(e.length>=1,()=>"Pass at least one tensor to concat");const n=Object(s["b"])(e,"tensors","concat","string_or_numeric");if("complex64"===n[0].dtype&&n.forEach(e=>{if("complex64"!==e.dtype)throw new Error(`Cannot concatenate complex64 tensors with a tensor\n          with dtype ${e.dtype}. `)}),1===n.length)return Object(i["a"])(n[0]);const c=n,u={axis:t};return r["a"].runKernel(a["C"],c,u)}const l=Object(c["b"])({concat_:u})},"673d":function(e,t,n){"use strict";n.r(t),n.d(t,"json",(function(){return r}));
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const r=[{tfOpName:"_FusedMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMulV2",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Transpose",category:"matrices",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"perm",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Einsum",category:"matrices",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"equation",name:"equation",type:"string"},{tfName:"N",name:"n",type:"number",defaultValue:2},{tfName:"T",name:"dtype",type:"dtype"}]}]},6791:function(e,t,n){"use strict";n.d(t,"a",(function(){return l}));var r=n("6ae2"),a=n("c05b"),s=n("a3f7"),o=n("48db"),i=n("526f"),c=n("54ef");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function u(e,t,n){const c=Object(s["a"])(t,"a","where"),u=Object(s["a"])(n,"b","where"),l=Object(s["a"])(e,"condition","where","bool"),d=Object(i["a"])(Object(i["a"])(l.shape,c.shape),u.shape),p=Object(o["a"])(l,d),h=Object(o["a"])(c,d),f=Object(o["a"])(u,d),m={condition:p,t:h,e:f};return r["a"].runKernel(a["Ac"],m)}const l=Object(c["b"])({where_:u})},6932:function(e,t,n){"use strict";n.d(t,"a",(function(){return c}));var r=n("6ae2"),a=n("c05b"),s=n("a3f7"),o=n("54ef");
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function i(e){const t=Object(s["a"])(e,"x","sin"),n={x:t};return r["a"].runKernel(a["Ec"],n)}const c=Object(o["b"])({sin_:i})},"69dc":function(e,t,n){"use strict";n.d(t,"a",(function(){return m}));var r=n("0777"),a=n("649e"),s=n("24b0"),o=n("a5aa"),i=n("54ef"),c=n("d7b0"),u=n("35c9"),l=n("d08e"),d=n("015f"),p=n("6d3c"),h=n("4c7a");
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function f(e){const t=e.shape[e.shape.length-1],n=e.size/t;let i;if(t<=2){const r=Object(u["a"])(e,[n,t]);i=Object(h["a"])(r)}else{const f=[n,2*(t-1)],m=Object(u["a"])(Object(c["a"])(e),[n,t]),b=Object(u["a"])(Object(s["a"])(e),[n,t]),g=Object(l["a"])(Object(p["a"])(m,[0,1],[n,t-2]),1),y=Object(o["a"])(Object(l["a"])(Object(p["a"])(b,[0,1],[n,t-2]),1),Object(d["a"])(-1)),x=Object(a["a"])([m,g],1),O=Object(a["a"])([b,y],1),v=Object(u["a"])(Object(r["a"])(x,O),[f[0],f[1]]);i=Object(h["a"])(v)}if(i=Object(c["a"])(i),3===e.rank&&0!==e.shape[0]){const t=i,n=e.shape[0];i=Object(u["a"])(i,[n,i.shape[0]/n,i.shape[1]]),t.dispose()}return i}const m=Object(i["b"])({irfft_:f})},"6ad5":function(e,t,n){"use strict";
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function r(e){let t=e.length,n=0;while(t>0)n=Math.random()*t|0,t--,i(e,t,n)}function a(e,t){if(e.length!==t.length)throw new Error("Array sizes must match to be shuffled together First array length was "+e.length+"Second array length was "+t.length);let n=e.length,r=0;while(n>0)r=Math.random()*n|0,n--,i(e,n,r),i(t,n,r)}function s(e,t,n){return Math.max(e,Math.min(t,n))}function o(e){return e%2===0?e:e+1}function i(e,t,n){const r=e[t];e[t]=e[n],e[n]=r}function c(e){let t=0;for(let n=0;n<e.length;n++)t+=e[n];return t}function u(e,t){const n=Math.random();return t*n+(1-n)*e}function l(e,t){let n=0;for(let r=0;r<e.length;r++){const a=Number(e[r])-Number(t[r]);n+=a*a}return n}function d(e,t){if(!e)throw new Error("string"===typeof t?t:t())}function p(e,t,n=""){d(g(e,t),()=>n+` Shapes ${e} and ${t} must match`)}function h(e){d(null!=e,()=>"The input to the tensor constructor must be a non-null value.")}function f(e,t=[],n=!1){if(null==t&&(t=[]),Array.isArray(e)||A(e)&&!n)for(let r=0;r<e.length;++r)f(e[r],t,n);else t.push(e);return t}function m(e){if(0===e.length)return 1;let t=e[0];for(let n=1;n<e.length;n++)t*=e[n];return t}function b(e){return 0===e.length}function g(e,t){if(e===t)return!0;if(null==e||null==t)return!1;if(e.length!==t.length)return!1;for(let n=0;n<e.length;n++)if(e[n]!==t[n])return!1;return!0}function y(e){return e%1===0}function x(e){if(null!=Math.tanh)return Math.tanh(e);if(e===1/0)return 1;if(e===-1/0)return-1;{const t=Math.exp(2*e);return(t-1)/(t+1)}}function O(e){const t=Math.ceil(Math.sqrt(e));return[t,Math.ceil(e/t)]}function v(e){const t=new Uint32Array(e);for(let n=0;n<e;++n)t[n]=n;return r(t),t}function w(e,t){return t<=e.length?e:e+" ".repeat(t-e.length)}function k(e,t=(e=>0),n){return new Promise((r,a)=>{let s=0;const o=()=>{if(e())return void r();s++;const i=t(s);null!=n&&s>=n?a():setTimeout(o,i)};o()})}function j(e,t){let n=1,r=-1;for(let s=0;s<e.length;++s)if(e[s]>=0)n*=e[s];else if(-1===e[s]){if(-1!==r)throw Error(`Shapes can only have 1 implicit size. Found -1 at dim ${r} and dim ${s}`);r=s}else if(e[s]<0)throw Error(`Shapes can not be < 0. Found ${e[s]} at dim ${s}`);if(-1===r){if(t>0&&t!==n)throw Error(`Size(${t}) must match the product of shape ${e}`);return e}if(0===n)throw Error(`Cannot infer the missing size in [${e}] when there are 0 elements`);if(t%n!==0)throw Error(`The implicit shape can't be a fractional number. Got ${t} / ${n}`);const a=e.slice();return a[r]=t/n,a}function S(e,t){const n=t.length;return e=null==e?t.map((e,t)=>t):[].concat(e),d(e.every(e=>e>=-n&&e<n),()=>`All values in axis param must be in range [-${n}, ${n}) but got axis `+e),d(e.every(e=>y(e)),()=>"All values in axis param must be integers but got axis "+e),e.map(e=>e<0?n+e:e)}function N(e,t){const n=[],r=[],a=null!=t&&Array.isArray(t)&&0===t.length,s=null==t||a?null:S(t,e).sort();let o=0;for(let i=0;i<e.length;++i){if(null!=s){if(s[o]===i&&1!==e[i])throw new Error(`Can't squeeze axis ${i} since its dim '${e[i]}' is not 1`);(null==s[o]||s[o]>i)&&1===e[i]&&(n.push(e[i]),r.push(i)),s[o]<=i&&o++}1!==e[i]&&(n.push(e[i]),r.push(i))}return{newShape:n,keptDims:r}}function C(e,t){let n=null;if(null==e||"float32"===e)n=new Float32Array(t);else if("int32"===e)n=new Int32Array(t);else{if("bool"!==e)throw new Error("Unknown data type "+e);n=new Uint8Array(t)}return n}function I(e,t){let n=null;if(null==e||"float32"===e)n=new Float32Array(t);else if("int32"===e)n=new Int32Array(t);else if("bool"===e)n=new Uint8Array(t);else{if("string"!==e)throw new Error("Unknown data type "+e);n=new Array(t)}return n}function T(e,t){for(let n=0;n<e.length;n++){const r=e[n];if(isNaN(r)||!isFinite(r))throw Error(`A tensor of type ${t} being uploaded contains ${r}.`)}}function $(e){return"bool"===e||"complex64"===e||"float32"===e||"int32"===e||"string"===e}function E(e,t){return"complex64"!==t&&(("float32"!==t||"complex64"===e)&&(("int32"!==t||"float32"===e||"complex64"===e)&&("bool"!==t||"bool"!==e)))}function A(e){return e instanceof Float32Array||e instanceof Int32Array||e instanceof Uint8Array}function R(e){if("float32"===e||"int32"===e)return 4;if("complex64"===e)return 8;if("bool"===e)return 1;throw new Error("Unknown dtype "+e)}function _(e){if(null==e)return 0;let t=0;return e.forEach(e=>t+=e.length),t}function F(e){return"string"===typeof e||e instanceof String}function D(e){return"boolean"===typeof e}function M(e){return"number"===typeof e}function L(e){return Array.isArray(e)?L(e[0]):e instanceof Float32Array?"float32":e instanceof Int32Array||e instanceof Uint8Array?"int32":M(e)?"float32":F(e)?"string":D(e)?"bool":"float32"}function P(e){return!!(e&&e.constructor&&e.call&&e.apply)}function B(e,t){for(let n=t;n<e;++n)if(e%n===0)return n;return e}function V(e){const t=e.length;if(t<2)return[];const n=new Array(t-1);n[t-2]=e[t-1];for(let r=t-3;r>=0;--r)n[r]=n[r+1]*e[r+1];return n}function z(e,t,n,r=!1){const a=new Array;if(1===t.length){const s=t[0]*(r?2:1);for(let t=0;t<s;t++)a[t]=n[e+t]}else{const s=t[0],o=t.slice(1),i=o.reduce((e,t)=>e*t)*(r?2:1);for(let t=0;t<s;t++)a[t]=z(e+t*i,o,n,r)}return a}function W(e,t,n=!1){if(0===e.length)return t[0];const r=e.reduce((e,t)=>e*t)*(n?2:1);if(0===r)return[];if(r!==t.length)throw new Error(`[${e}] does not match the input size ${t.length}${n?" for a complex tensor":""}.`);return z(0,e,t,n)}function U(e,t){const n=G(e,t);for(let r=0;r<n.length;r++)n[r]=1;return n}function G(e,t){if(null==t||"float32"===t||"complex64"===t)return new Float32Array(e);if("int32"===t)return new Int32Array(e);if("bool"===t)return new Uint8Array(e);throw new Error("Unknown data type "+t)}function H(e,t){const n=e.reduce((e,t)=>e*t,1);if(null==t||"float32"===t)return W(e,new Float32Array(n));if("int32"===t)return W(e,new Int32Array(n));if("bool"===t)return W(e,new Uint8Array(n));throw new Error("Unknown data type "+t)}function q(e){e.forEach(t=>{d(Number.isInteger(t)&&t>=0,()=>`Tensor must have a shape comprised of positive integers but got shape [${e}].`)})}function K(e,t,n){if(0===t)return 0;if(1===t)return e[0];let r=e[e.length-1];for(let a=0;a<e.length-1;++a)r+=n[a]*e[a];return r}function X(e,t,n){if(0===t)return[];if(1===t)return[e];const r=new Array(t);for(let a=0;a<r.length-1;++a)r[a]=Math.floor(e/n[a]),e-=r[a]*n[a];return r[r.length-1]=e,r}function Y(e){return e&&e.then&&"function"===typeof e.then}n.d(t,"M",(function(){return r})),n.d(t,"N",(function(){return a})),n.d(t,"i",(function(){return s})),n.d(t,"H",(function(){return o})),n.d(t,"S",(function(){return i})),n.d(t,"R",(function(){return c})),n.d(t,"J",(function(){return u})),n.d(t,"l",(function(){return l})),n.d(t,"b",(function(){return d})),n.d(t,"e",(function(){return p})),n.d(t,"d",(function(){return h})),n.d(t,"m",(function(){return f})),n.d(t,"O",(function(){return m})),n.d(t,"y",(function(){return b})),n.d(t,"a",(function(){return g})),n.d(t,"v",(function(){return y})),n.d(t,"T",(function(){return x})),n.d(t,"P",(function(){return O})),n.d(t,"k",(function(){return v})),n.d(t,"L",(function(){return w})),n.d(t,"K",(function(){return k})),n.d(t,"s",(function(){return j})),n.d(t,"I",(function(){return S})),n.d(t,"Q",(function(){return N})),n.d(t,"o",(function(){return C})),n.d(t,"n",(function(){return I})),n.d(t,"h",(function(){return T})),n.d(t,"B",(function(){return $})),n.d(t,"p",(function(){return E})),n.d(t,"A",(function(){return A})),n.d(t,"g",(function(){return R})),n.d(t,"f",(function(){return _})),n.d(t,"z",(function(){return F})),n.d(t,"t",(function(){return D})),n.d(t,"w",(function(){return M})),n.d(t,"r",(function(){return L})),n.d(t,"u",(function(){return P})),n.d(t,"G",(function(){return B})),n.d(t,"j",(function(){return V})),n.d(t,"U",(function(){return W})),n.d(t,"D",(function(){return U})),n.d(t,"F",(function(){return G})),n.d(t,"E",(function(){return H})),n.d(t,"c",(function(){return q})),n.d(t,"C",(function(){return K})),n.d(t,"q",(function(){return X})),n.d(t,"x",(function(){return Y}))},"6ae2":function(e,t,n){"use strict";n.d(t,"b",(function(){return w})),n.d(t,"a",(function(){return k}));var r=n("8b87"),a=n("b333"),s=n("f490"),o=n("c05b"),i=n("73b8"),c=n("eb7e"),u=n("6ad5");
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class l{constructor(e,t){this.backendTimer=e,this.logger=t,null==t&&(this.logger=new p)}profileKernel(e,t,n){let r;const s=()=>{r=n()};let o;const i=c["now"]();if(this.backendTimer.timerAvailable())o=this.backendTimer.time(s);else{s();for(const e of r)e.dataSync();o=Promise.resolve({kernelMs:c["now"]()-i})}if(Object(a["c"])().getBool("CHECK_COMPUTATION_FOR_ERRORS"))for(let a=0;a<r.length;a++){const t=r[a];t.data().then(n=>{d(n,t.dtype,e)})}const u={kernelName:e,outputs:r,inputs:t,timeMs:o.then(e=>e.kernelMs),extraInfo:o.then(e=>null!=e.getExtraProfileInfo?e.getExtraProfileInfo():"")};return u}logKernelProfile(e){const{kernelName:t,outputs:n,timeMs:r,inputs:a,extraInfo:s}=e;n.forEach(e=>{Promise.all([e.data(),r,s]).then(n=>{this.logger.logKernelProfile(t,e,n[0],n[1],a,n[2])})})}}function d(e,t,n){if("float32"!==t)return!1;for(let r=0;r<e.length;r++){const t=e[r];if(isNaN(t)||!isFinite(t))return console.warn(`Found ${t} in the result of '${n}'`),!0}return!1}class p{logKernelProfile(e,t,n,r,a,s){const o="number"===typeof r?u["L"](r+"ms",9):r["error"],i=u["L"](e,25),c=t.rank,l=t.size,d=u["L"](t.shape.toString(),14);let p="";for(const u in a){const e=a[u];if(null!=e){const n=e.shape||t.shape,r=n.length;p+=`${u}: ${r}D ${r>0?n:""} `}}console.log(`%c${i}\t%c${o}\t%c${c}D ${d}\t%c${l}\t%c${p}\t%c${s}`,"font-weight:bold","color:red","color:blue","color: orange","color: green","color: steelblue")}}
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function h(e,t,n){const r={},a={};for(let c=0;c<t.length;c++)r[t[c].id]=!0;for(let c=0;c<e.length;c++){const n=e[c],s=n.inputs;for(const e in s){const o=s[e];let i=!1;for(let e=0;e<t.length;e++)if(r[o.id]){n.outputs.forEach(e=>r[e.id]=!0),i=!0,a[n.id]=!0;break}if(i)break}}const s={};s[n.id]=!0;const o={};for(let c=e.length-1;c>=0;c--){const t=e[c],n=t.inputs;for(let e=0;e<t.outputs.length;e++)if(s[t.outputs[e].id]){for(const e in n)s[n[e].id]=!0,o[t.id]=!0;break}}const i=[];for(let c=0;c<e.length;c++){const t=e[c];if(a[t.id]&&o[t.id]){const e={};for(const a in t.inputs){const n=t.inputs[a];r[n.id]&&(e[a]=n)}const n=Object.assign({},t);n.inputs=e,n.outputs=t.outputs,i.push(n)}}return i}function f(e,t,n,r){for(let a=t.length-1;a>=0;a--){const s=t[a],o=[];if(s.outputs.forEach(t=>{const n=e[t.id];null!=n?o.push(n):o.push(null)}),null==s.gradient)throw new Error(`Cannot compute gradient: gradient function not found for ${s.kernelName}.`);const i=s.gradient(o);for(const t in s.inputs){if(!(t in i))throw new Error(`Cannot backprop through input ${t}. Available gradients found: ${Object.keys(i)}.`);const a=n(()=>i[t]());if("float32"!==a.dtype)throw new Error(`Error in gradient for op ${s.kernelName}. The gradient of input ${t} must have 'float32' dtype, but has '${a.dtype}'`);const o=s.inputs[t];if(!u["a"](a.shape,o.shape))throw new Error(`Error in gradient for op ${s.kernelName}. The gradient of input '${t}' has shape '${a.shape}', which does not match the shape of the input '${o.shape}'`);if(null==e[o.id])e[o.id]=a;else{const t=e[o.id];e[o.id]=r(t,a),t.dispose()}}}}var m=n("34d7"),b=n("76c2"),g=n("b294");
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function y(e){return null!=e.kernelName}class x{constructor(){this.registeredVariables={},this.nextTapeNodeId=0,this.numBytes=0,this.numTensors=0,this.numStringTensors=0,this.numDataBuffers=0,this.gradientDepth=0,this.kernelDepth=0,this.scopeStack=[],this.numDataMovesStack=[],this.nextScopeId=0,this.tensorInfo=new WeakMap,this.profiling=!1,this.activeProfile={newBytes:0,newTensors:0,peakBytes:0,kernels:[],result:null,get kernelNames(){return Array.from(new Set(this.kernels.map(e=>e.name)))}}}dispose(){for(const e in this.registeredVariables)this.registeredVariables[e].dispose()}}class O{constructor(e){this.ENV=e,this.registry={},this.registryFactory={},this.pendingBackendInitId=0,this.state=new x}async ready(){if(null!=this.pendingBackendInit)return this.pendingBackendInit.then(()=>{});if(null!=this.backendInstance)return;const e=this.getSortedBackends();for(let t=0;t<e.length;t++){const n=e[t],r=await this.initializeBackend(n).success;if(r)return void await this.setBackend(n)}throw new Error("Could not initialize any backends, all backend initializations failed.")}get backend(){if(null!=this.pendingBackendInit)throw new Error(`Backend '${this.backendName}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);if(null==this.backendInstance){const{name:e,asyncInit:t}=this.initializeBackendsAndReturnBest();if(t)throw new Error(`The highest priority backend '${e}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);this.setBackend(e)}return this.backendInstance}backendNames(){return Object.keys(this.registryFactory)}findBackend(e){if(!(e in this.registry)){if(!(e in this.registryFactory))return null;{const{asyncInit:t}=this.initializeBackend(e);if(t)return null}}return this.registry[e]}findBackendFactory(e){return e in this.registryFactory?this.registryFactory[e].factory:null}registerBackend(e,t,n=1){return e in this.registryFactory?(g["b"](e+" backend was already registered. Reusing existing backend factory."),!1):(this.registryFactory[e]={factory:t,priority:n},!0)}async setBackend(e){if(null==this.registryFactory[e])throw new Error(`Backend name '${e}' not found in registry`);if(this.backendName=e,null==this.registry[e]){this.backendInstance=null;const{success:t,asyncInit:n}=this.initializeBackend(e),r=n?await t:t;if(!r)return!1}return this.backendInstance=this.registry[e],this.setupRegisteredKernels(),this.profiler=new l(this.backendInstance),!0}setupRegisteredKernels(){const e=Object(i["d"])(this.backendName);e.forEach(e=>{null!=e.setupFunc&&e.setupFunc(this.backendInstance)})}disposeRegisteredKernels(e){const t=Object(i["d"])(e);t.forEach(t=>{null!=t.disposeFunc&&t.disposeFunc(this.registry[e])})}initializeBackend(e){const t=this.registryFactory[e];if(null==t)throw new Error(`Cannot initialize backend ${e}, no registration found.`);try{const n=t.factory();if(!n||n instanceof r["b"]||"function"!==typeof n.then)return this.registry[e]=n,{success:!0,asyncInit:!1};{const t=++this.pendingBackendInitId,r=n.then(n=>!(t<this.pendingBackendInitId)&&(this.registry[e]=n,this.pendingBackendInit=null,!0)).catch(n=>(t<this.pendingBackendInitId||(this.pendingBackendInit=null,g["b"](`Initialization of backend ${e} failed`),g["b"](n.stack||n.message)),!1));return this.pendingBackendInit=r,{success:r,asyncInit:!0}}}catch(n){return g["b"](`Initialization of backend ${e} failed`),g["b"](n.stack||n.message),{success:!1,asyncInit:!1}}}removeBackend(e){if(!(e in this.registryFactory))throw new Error(e+" backend not found in registry");this.backendName===e&&null!=this.pendingBackendInit&&this.pendingBackendInitId++,e in this.registry&&(this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e]),delete this.registryFactory[e],this.backendName===e&&(this.pendingBackendInit=null,this.backendName=null,this.backendInstance=null)}getSortedBackends(){if(0===Object.keys(this.registryFactory).length)throw new Error("No backend found in registry.");return Object.keys(this.registryFactory).sort((e,t)=>this.registryFactory[t].priority-this.registryFactory[e].priority)}initializeBackendsAndReturnBest(){const e=this.getSortedBackends();for(let t=0;t<e.length;t++){const n=e[t],{success:r,asyncInit:a}=this.initializeBackend(n);if(a||r)return{name:n,asyncInit:a}}throw new Error("Could not initialize any backends, all backend initializations failed.")}moveData(e,t){const n=this.state.tensorInfo.get(t),r=n.backend,a=this.readSync(t),s=r.refCount(t);r.disposeData(t,!0),n.backend=e,e.move(t,a,n.shape,n.dtype,s),this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack[this.state.numDataMovesStack.length-1]++}tidy(e,t){let n,r=null;if(null==t){if("function"!==typeof e)throw new Error("Please provide a function to tidy()");t=e}else{if("string"!==typeof e&&!(e instanceof String))throw new Error("When calling with two arguments, the first argument to tidy() must be a string");if("function"!==typeof t)throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");r=e}return this.scopedRun(()=>this.startScope(r),()=>this.endScope(n),()=>(n=t(),n instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),n))}scopedRun(e,t,n){e();try{const e=n();return t(),e}catch(r){throw t(),r}}nextTensorId(){return O.nextTensorId++}nextVariableId(){return O.nextVariableId++}clone(e){const t=k.runKernel(o["sb"],{x:e}),n={x:e},r=e=>({x:()=>{const t="float32",n={x:e},r={dtype:t};return k.runKernel(o["x"],n,r)}}),a=[];return this.addTapeNode(this.state.activeScope.name,n,[t],r,a,{}),t}runKernel(e,t,n){null==this.backendName&&this.backend;const r=null!=Object(i["c"])(e,this.backendName);if(!r)throw new Error(`Kernel '${e}' not registered for backend '${this.backendName}'`);return this.runKernelFunc({kernelName:e,inputs:t,attrs:n})}shouldCheckForMemLeaks(){return this.ENV.getBool("IS_TEST")}checkKernelForMemLeak(e,t,n){const r=this.backend.numDataIds();let a=0;n.forEach(e=>{a+="complex64"===e.dtype?3:1});const s=this.state.numDataMovesStack[this.state.numDataMovesStack.length-1],o=r-t-a-s;if(o>0)throw new Error(`Backend '${this.backendName}' has an internal memory leak (${o} data ids) after running '${e}'`)}runKernelFunc(e){let t,n=[];const r=this.isTapeOn(),a=this.state.numBytes,s=this.state.numTensors;let o,c;this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack.push(0),null==this.backendName&&this.backend;const l=y(e)?e.kernelName:null!=this.state.activeScope?this.state.activeScope.name:"";if(y(e)){const{kernelName:t,inputs:a,attrs:s}=e;null==this.backendName&&this.backend;const l=Object(i["c"])(t,this.backendName);u["b"](null!=l,()=>`Cannot find registered kernel '${t}' for backend '${this.backendName}'`),o=()=>{const e=this.backend.numDataIds();c=l.kernelFunc({inputs:a,attrs:s,backend:this.backend});const o=Array.isArray(c)?c:[c];this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(t,e,o);const i=o.map(e=>{if(null!=e.rank)return e;const{dataId:t,shape:n,dtype:r}=e;return this.makeTensorFromDataId(t,n,r)});if(r){const e=this.getTensorsForGradient(t,a,i);n=this.saveTensorsForBackwardMode(e)}return i}}else{const{forwardFunc:t}=e,a=e=>{r&&(n=e.map(e=>this.keep(this.clone(e))))};o=()=>{const e=this.backend.numDataIds();c=this.tidy(()=>t(this.backend,a));const n=Array.isArray(c)?c:[c];return this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(l,e,n),n}}const{inputs:d,attrs:p}=e,h=y(e)?null:e.backwardsFunc;let f;return this.scopedRun(()=>this.state.kernelDepth++,()=>this.state.kernelDepth--,()=>{this.ENV.getBool("DEBUG")||this.state.profiling?(f=this.profiler.profileKernel(l,d,()=>o()),this.ENV.getBool("DEBUG")&&this.profiler.logKernelProfile(f),t=f.outputs):t=o()}),r&&this.addTapeNode(l,d,t,h,n,p),this.state.profiling&&this.state.activeProfile.kernels.push({name:l,bytesAdded:this.state.numBytes-a,totalBytesSnapshot:this.state.numBytes,tensorsAdded:this.state.numTensors-s,totalTensorsSnapshot:this.state.numTensors,inputShapes:Object.keys(d).map(e=>null!=d[e]?d[e].shape:null),outputShapes:t.map(e=>e.shape),kernelTimeMs:f.timeMs,extraInfo:f.extraInfo}),Array.isArray(c)?t:t[0]}saveTensorsForBackwardMode(e){const t=e.map(e=>this.keep(this.clone(e)));return t}getTensorsForGradient(e,t,n){const r=Object(i["b"])(e);if(null!=r){const e=r.inputsToSave||[],a=r.outputsToSave||[];let s;r.saveAllInputs?(u["b"](Array.isArray(t),()=>"saveAllInputs is true, expected inputs to be an array."),s=Object.keys(t).map(e=>t[e])):s=e.map(e=>t[e]);const o=n.filter((e,t)=>a[t]);return s.concat(o)}return[]}makeTensor(e,t,n,r){if(null==e)throw new Error("Values passed to engine.makeTensor() are null");n=n||"float32",r=r||this.backend;let a=e;"string"===n&&u["z"](e[0])&&(a=e.map(e=>c["encodeString"](e)));const s=r.write(a,t,n),o=new m["a"](t,n,s,this.nextTensorId());if(this.trackTensor(o,r),"string"===n){const e=this.state.tensorInfo.get(s),t=Object(u["f"])(a);this.state.numBytes+=t-e.bytes,e.bytes=t}return o}makeTensorFromDataId(e,t,n,r){n=n||"float32";const a=new m["a"](t,n,e,this.nextTensorId());return this.trackTensor(a,r),a}makeVariable(e,t=!0,n,r){n=n||this.nextVariableId().toString(),null!=r&&r!==e.dtype&&(e=e.cast(r));const a=new m["c"](e,t,n,this.nextTensorId());if(null!=this.state.registeredVariables[a.name])throw new Error(`Variable with name ${a.name} was already registered`);return this.state.registeredVariables[a.name]=a,this.incRef(a,this.backend),a}trackTensor(e,t){this.state.numTensors++,"string"===e.dtype&&this.state.numStringTensors++;let n=0;"complex64"!==e.dtype&&"string"!==e.dtype&&(n=e.size*u["g"](e.dtype)),this.state.numBytes+=n,this.state.tensorInfo.has(e.dataId)||(this.state.numDataBuffers++,this.state.tensorInfo.set(e.dataId,{backend:t||this.backend,dtype:e.dtype,shape:e.shape,bytes:n})),e instanceof m["c"]||this.track(e)}incRef(e,t){this.trackTensor(e,t),this.backend.incRef(e.dataId)}removeDataId(e,t){this.state.tensorInfo.has(e)&&this.state.tensorInfo.get(e).backend===t&&(this.state.tensorInfo.delete(e),this.state.numDataBuffers--)}disposeTensor(e){if(!this.state.tensorInfo.has(e.dataId))return;const t=this.state.tensorInfo.get(e.dataId);if(this.state.numTensors--,"string"===e.dtype&&(this.state.numStringTensors--,this.state.numBytes-=t.bytes),"complex64"!==e.dtype&&"string"!==e.dtype){const t=e.size*u["g"](e.dtype);this.state.numBytes-=t}t.backend.disposeData(e.dataId)&&this.removeDataId(e.dataId,t.backend)}disposeVariables(){for(const e in this.state.registeredVariables){const t=this.state.registeredVariables[e];this.disposeVariable(t)}}disposeVariable(e){this.disposeTensor(e),null!=this.state.registeredVariables[e.name]&&delete this.state.registeredVariables[e.name]}memory(){const e=this.backend.memory();return e.numTensors=this.state.numTensors,e.numDataBuffers=this.state.numDataBuffers,e.numBytes=this.state.numBytes,this.state.numStringTensors>0&&(e.unreliable=!0,null==e.reasons&&(e.reasons=[]),e.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")),e}async profile(e){this.state.profiling=!0;const t=this.state.numBytes,n=this.state.numTensors;this.state.activeProfile.kernels=[],this.state.activeProfile.result=await e(),this.state.profiling=!1,this.state.activeProfile.peakBytes=Math.max(...this.state.activeProfile.kernels.map(e=>e.totalBytesSnapshot)),this.state.activeProfile.newBytes=this.state.numBytes-t,this.state.activeProfile.newTensors=this.state.numTensors-n;for(const r of this.state.activeProfile.kernels)r.kernelTimeMs=await r.kernelTimeMs,r.extraInfo=await r.extraInfo;return this.state.activeProfile}isTapeOn(){return this.state.gradientDepth>0&&0===this.state.kernelDepth}addTapeNode(e,t,n,r,a,s){const o={id:this.state.nextTapeNodeId++,kernelName:e,inputs:t,outputs:n,saved:a},c=Object(i["b"])(e);null!=c&&(r=c.gradFunc),null!=r&&(o.gradient=e=>(e=e.map((e,t)=>{if(null==e){const e=n[t],r=u["F"](e.size,e.dtype);return this.makeTensor(r,e.shape,e.dtype)}return e}),r(e.length>1?e:e[0],a,s))),this.state.activeTape.push(o)}keep(e){return e.kept=!0,e}startTape(){0===this.state.gradientDepth&&(this.state.activeTape=[]),this.state.gradientDepth++}endTape(){this.state.gradientDepth--}startScope(e){const t={track:[],name:"unnamed scope",id:this.state.nextScopeId++};e&&(t.name=e),this.state.scopeStack.push(t),this.state.activeScope=t}endScope(e){const t=Object(b["getTensorsInContainer"])(e),n=new Set(t.map(e=>e.id));for(let a=0;a<this.state.activeScope.track.length;a++){const e=this.state.activeScope.track[a];e.kept||n.has(e.id)||e.dispose()}const r=this.state.scopeStack.pop();this.state.activeScope=0===this.state.scopeStack.length?null:this.state.scopeStack[this.state.scopeStack.length-1],t.forEach(e=>{e.kept||e.scopeId!==r.id||this.track(e)})}gradients(e,t,n,r=!1){if(u["b"](t.length>0,()=>"gradients() received an empty list of xs."),null!=n&&"float32"!==n.dtype)throw new Error(`dy must have 'float32' dtype, but has '${n.dtype}'`);const a=this.scopedRun(()=>this.startTape(),()=>this.endTape(),()=>this.tidy("forward",e));u["b"](a instanceof m["a"],()=>"The result y returned by f() must be a tensor.");const s=h(this.state.activeTape,t,a);if(!r&&0===s.length&&t.length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");return this.tidy("backward",()=>{const e={};e[a.id]=null==n?v(a.shape):n,f(e,s,e=>this.tidy(e),j);const r=t.map(t=>e[t.id]);return 0===this.state.gradientDepth&&(this.state.activeTape.forEach(e=>{for(const t of e.saved)t.dispose()}),this.state.activeTape=null),{value:a,grads:r}})}customGrad(e){return u["b"](u["u"](e),()=>"The f passed in customGrad(f) must be a function."),(...t)=>{let n;u["b"](t.every(e=>e instanceof m["a"]),()=>"The args passed in customGrad(f)(x1, x2,...) must all be tensors");const r={};t.forEach((e,t)=>{r[t]=e});const a=(r,a)=>(n=e(...t,a),u["b"](n.value instanceof m["a"],()=>"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor"),u["b"](u["u"](n.gradFunc),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function."),n.value),s=(e,r)=>{const a=n.gradFunc(e,r),s=Array.isArray(a)?a:[a];u["b"](s.length===t.length,()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...)."),u["b"](s.every(e=>e instanceof m["a"]),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors.");const o={};return s.forEach((e,t)=>{o[t]=()=>e}),o};return this.runKernelFunc({forwardFunc:a,backwardsFunc:s,inputs:r})}}readSync(e){const t=this.state.tensorInfo.get(e);return t.backend.readSync(e)}read(e){const t=this.state.tensorInfo.get(e);return t.backend.read(e)}async time(e){const t=Object(c["now"])(),n=await this.backend.time(e);return n.wallMs=Object(c["now"])()-t,n}track(e){return null!=this.state.activeScope&&(e.scopeId=this.state.activeScope.id,this.state.activeScope.track.push(e)),e}get registeredVariables(){return this.state.registeredVariables}reset(){this.pendingBackendInitId++,this.state.dispose(),this.ENV.reset(),this.state=new x;for(const e in this.registry)this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e];this.backendName=null,this.backendInstance=null,this.pendingBackendInit=null}}function v(e){const t=Object(u["D"])(Object(u["O"])(e),"float32");return k.makeTensor(t,e,"float32")}function w(){const e=Object(s["b"])();if(null==e._tfengine){const t=new a["b"](e);e._tfengine=new O(t)}return Object(a["d"])(e._tfengine.ENV),Object(m["f"])(()=>e._tfengine),e._tfengine}O.nextTensorId=0,O.nextVariableId=0;const k=w();function j(e,t){const n={a:e,b:t};return k.runKernel(o["d"],n)}},"6d3c":function(e,t,n){"use strict";n.d(t,"a",(function(){return c}));var r=n("6ae2"),a=n("c05b"),s=n("a3f7"),o=n("54ef");
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function i(e,t,n){const o=Object(s["a"])(e,"x","slice","string_or_numeric");if(0===o.rank)throw new Error("Slicing scalar is not possible");const i={x:o},c={begin:t,size:n};return r["a"].runKernel(a["Gc"],i,c)}const c=Object(o["b"])({slice_:i})},"6e83":function(e,t,n){"use strict";n.r(t),n.d(t,"json",(function(){return r}));const r=[{tfOpName:"HashTable",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"HashTableV2",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"LookupTableImport",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableImportV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFind",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFindV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableSize",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"LookupTableSizeV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]}]},"6f37":function(e,t,n){"use strict";n.d(t,"a",(function(){return c}));var r=n("6ae2"),a=n("c05b"),s=n("a3f7"),o=n("54ef");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function i(e,t=.2){const n=Object(s["a"])(e,"x","leakyRelu"),o={x:n},i={alpha:t};return r["a"].runKernel(a["zb"],o,i)}const c=Object(o["b"])({leakyRelu_:i})},"6fef":function(e,t,n){"use strict";n.d(t,"a",(function(){return c}));var r=n("6ae2"),a=n("c05b"),s=n("a3f7"),o=n("54ef");
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function i(e){const t=Object(s["a"])(e,"x","isNaN"),n={x:t};return r["a"].runKernel(a["wb"],n)}const c=Object(o["b"])({isNaN_:i})},"71db":function(e,t,n){"use strict";n.d(t,"a",(function(){return d}));var r=n("6ae2"),a=n("c05b"),s=n("a3f7"),o=n("6ad5"),i=n("35c9");function c(e){let t;return t=0===e.rank||1===e.rank?Object(i["a"])(e,[1,1,1,e.size]):2===e.rank?Object(i["a"])(e,[1,1,e.shape[0],e.shape[1]]):3===e.rank?Object(i["a"])(e,[1,e.shape[0],e.shape[1],e.shape[2]]):e,t}var u=n("54ef");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function l(e,t,n,u,l,d){null==d&&(d=.001);const p=Object(s["a"])(e,"x","batchNorm"),h=Object(s["a"])(t,"mean","batchNorm"),f=Object(s["a"])(n,"variance","batchNorm");let m,b;null!=l&&(m=Object(s["a"])(l,"scale","batchNorm")),null!=u&&(b=Object(s["a"])(u,"offset","batchNorm")),o["b"](h.rank===f.rank,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),o["b"](null==b||h.rank===b.rank,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),o["b"](null==m||h.rank===m.rank,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");const g=c(p),y={x:g,scale:m,offset:b,mean:h,variance:f},x={varianceEpsilon:d},O=r["a"].runKernel(a["kb"],y,x);return Object(i["a"])(O,p.shape)}const d=Object(u["b"])({batchNorm_:l})},"732a":function(e,t,n){"use strict";n.r(t);var r={};n.r(r),n.d(r,"load",(function(){return Gn})),n.d(r,"version",(function(){return Vn}));var a={};n.r(a),n.d(a,"simpleAbsImpl",(function(){return Vs})),n.d(a,"addImpl",(function(){return Qs})),n.d(a,"bincountImpl",(function(){return eo})),n.d(a,"bincountReduceImpl",(function(){return to})),n.d(a,"ceilImpl",(function(){return so})),n.d(a,"concatImpl",(function(){return io})),n.d(a,"equalImpl",(function(){return co})),n.d(a,"expImpl",(function(){return lo})),n.d(a,"expm1Impl",(function(){return ho})),n.d(a,"floorImpl",(function(){return mo})),n.d(a,"gatherNdImpl",(function(){return go})),n.d(a,"gatherV2Impl",(function(){return yo})),n.d(a,"greaterImpl",(function(){return xo})),n.d(a,"greaterEqualImpl",(function(){return vo})),n.d(a,"lessImpl",(function(){return ko})),n.d(a,"lessEqualImpl",(function(){return So})),n.d(a,"linSpaceImpl",(function(){return Co})),n.d(a,"logImpl",(function(){return Io})),n.d(a,"maxImpl",(function(){return $o})),n.d(a,"maximumImpl",(function(){return Eo})),n.d(a,"minimumImpl",(function(){return Ro})),n.d(a,"multiplyImpl",(function(){return Fo})),n.d(a,"negImpl",(function(){return Lo})),n.d(a,"notEqualImpl",(function(){return Bo})),n.d(a,"prodImpl",(function(){return Uo})),n.d(a,"rangeImpl",(function(){return Ho})),n.d(a,"rsqrtImpl",(function(){return qo})),n.d(a,"sigmoidImpl",(function(){return Xo})),n.d(a,"sliceImpl",(function(){return Qo})),n.d(a,"sparseFillEmptyRowsImpl",(function(){return Jo})),n.d(a,"sparseReshapeImpl",(function(){return ei})),n.d(a,"sparseSegmentReductionImpl",(function(){return ti})),n.d(a,"sqrtImpl",(function(){return ni})),n.d(a,"squaredDifferenceImpl",(function(){return ai})),n.d(a,"stridedSliceImpl",(function(){return oi})),n.d(a,"stringNGramsImpl",(function(){return ci})),n.d(a,"stringSplitImpl",(function(){return li})),n.d(a,"stringToHashBucketFastImpl",(function(){return di})),n.d(a,"subImpl",(function(){return pi})),n.d(a,"tileImpl",(function(){return mi})),n.d(a,"topKImpl",(function(){return yi})),n.d(a,"transposeImpl",(function(){return zo})),n.d(a,"uniqueImpl",(function(){return xi}));var s=function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("div",{directives:[{name:"loading",rawName:"v-loading",value:e.loading,expression:"loading"}],staticClass:"page-container"},[n("div",{staticClass:"container"},[n("p",{staticStyle:{"line-height":"50px"}},[e._v("运行该项目示例可能需要科学上网(由于使用的是mobileNet模型,资源在外网)")]),n("img",{attrs:{id:"img",src:e.imageUrl,alt:""}}),n("p",[e._v("正在搞...(不过你可以体验基本功能)")])]),n("div",{staticClass:"side-bar"},[n("el-input",{staticClass:"input-with-select",staticStyle:{width:"95%",margin:"10px"},attrs:{placeholder:"请输入图片地址"},model:{value:e.imageUrl,callback:function(t){e.imageUrl=t},expression:"imageUrl"}},[n("el-button",{attrs:{slot:"append"},slot:"append"},[e._v("确定")])],1),n("el-button",{staticStyle:{width:"95%",margin:"10px"},attrs:{type:"primary",size:"default"},on:{click:e.selectFile}},[e._v("选取文件")]),n("el-button",{staticStyle:{width:"95%",margin:"10px"},attrs:{type:"success",size:"default"},on:{click:e.identify}},[e._v("识别")]),e._l(e.infoList,(function(t,r){return n("p",{key:r,staticClass:"discern-content"},[e._v(" 图中为: "),n("span",[e._v(e._s(t.className))]),e._v(" ,概率: "),n("span",{style:"color:"+(t.probability>.5?"green":"red")},[e._v(e._s(t.probability))])])}))],2)])},o=[],i=n("1da1"),c=(n("96cf"),n("fa11")),u=n("f8bb"),l=n("526c");
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class d{constructor(e,t,n){this.node=e,this.tensorMap=t,this.context=n,this.inputs=[],this.attrs={},this.inputs=e.inputNames.map(e=>this.getInput(e)),null!=e.rawAttrs&&(this.attrs=Object.keys(e.rawAttrs).reduce((e,t)=>(e[t]=this.getAttr(t),e),{}))}getInput(e){return Object(l["e"])(e,this.tensorMap,this.context)}getAttr(e,t){const n=this.node.rawAttrs[e];if(null!=n.tensor)return Object(l["e"])(e,this.tensorMap,this.context);if(null!=n.i||null!=n.f)return Object(u["f"])(this.node.rawAttrs,e,t);if(null!=n.s)return Object(u["i"])(this.node.rawAttrs,e,t);if(null!=n.b)return Object(u["c"])(this.node.rawAttrs,e,t);if(null!=n.shape)return Object(u["k"])(this.node.rawAttrs,e,t);if(null!=n.type)return Object(u["e"])(this.node.rawAttrs,e,t);if(null!=n.list){if(null!=n.list.i||null!=n.list.f)return Object(u["g"])(this.node.rawAttrs,e,t);if(null!=n.list.s)return Object(u["h"])(this.node.rawAttrs,e,t);if(null!=n.list.shape)return Object(u["j"])(this.node.rawAttrs,e,t);if(null!=n.list.b)return Object(u["b"])(this.node.rawAttrs,e,t);if(null!=n.list.type)return Object(u["d"])(this.node.rawAttrs,e,t)}return t}}var p=n("d303"),h=n("9117"),f=n("4850"),m=n("4611"),b=n("a5aa"),g=n("c77c"),y=n("011b"),x=n("508f"),O=n("a009"),v=n("f0e5"),w=n("09f4"),k=n("c9f1"),j=n("4184");
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const S=(e,t,n)=>{switch(e.op){case"BiasAdd":case"AddV2":case"Add":return[h["a"](Object(l["d"])("a",e,t,n),Object(l["d"])("b",e,t,n))];case"AddN":return[f["a"](Object(l["d"])("tensors",e,t,n))];case"FloorMod":case"Mod":return[m["a"](Object(l["d"])("a",e,t,n),Object(l["d"])("b",e,t,n))];case"Mul":return[b["a"](Object(l["d"])("a",e,t,n),Object(l["d"])("b",e,t,n))];case"RealDiv":case"Div":return[g["a"](Object(l["d"])("a",e,t,n),Object(l["d"])("b",e,t,n))];case"DivNoNan":return[y["a"](Object(l["d"])("a",e,t,n),Object(l["d"])("b",e,t,n))];case"FloorDiv":return[x["a"](Object(l["d"])("a",e,t,n),Object(l["d"])("b",e,t,n))];case"Sub":return[O["a"](Object(l["d"])("a",e,t,n),Object(l["d"])("b",e,t,n))];case"Minimum":return[v["a"](Object(l["d"])("a",e,t,n),Object(l["d"])("b",e,t,n))];case"Maximum":return[w["a"](Object(l["d"])("a",e,t,n),Object(l["d"])("b",e,t,n))];case"Pow":return[k["a"](Object(l["d"])("a",e,t,n),Object(l["d"])("b",e,t,n))];case"SquaredDifference":return[j["a"](Object(l["d"])("a",e,t,n),Object(l["d"])("b",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}};var N=n("8ae0"),C=n("a374"),I=n("4615"),T=n("220f"),$=n("dc59"),E=n("7e36"),A=n("6002"),R=n("d1a8"),_=n("5960"),F=n("0777"),D=n("eff7"),M=n("c1a2"),L=n("9e38"),P=n("8e05"),B=n("4f20"),V=n("1ba2"),z=n("d369"),W=n("1359"),U=n("46b1"),G=n("24b0"),H=n("3bb7"),q=n("b500"),K=n("d7b0"),X=n("917a"),Y=n("08a9"),Q=n("b39e"),Z=n("ffb3"),J=n("6932"),ee=n("1df6"),te=n("5dc4"),ne=n("9ffd"),re=n("163a"),ae=n("93b2"),se=n("8888"),oe=n("d30a"),ie=n("c08f"),ce=n("46a8"),ue=n("5f2a"),le=n("f3ae"),de=n("6f37"),pe=n("520f"),he=n("6fef");
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const fe=(e,t,n)=>{switch(e.op){case"Abs":case"ComplexAbs":return[N["a"](Object(l["d"])("x",e,t,n))];case"Acos":return[C["a"](Object(l["d"])("x",e,t,n))];case"Acosh":return[I["a"](Object(l["d"])("x",e,t,n))];case"Asin":return[T["a"](Object(l["d"])("x",e,t,n))];case"Asinh":return[$["a"](Object(l["d"])("x",e,t,n))];case"Atan":return[E["a"](Object(l["d"])("x",e,t,n))];case"Atan2":return[A["a"](Object(l["d"])("x",e,t,n),Object(l["d"])("y",e,t,n))];case"Atanh":return[R["a"](Object(l["d"])("x",e,t,n))];case"Ceil":return[_["a"](Object(l["d"])("x",e,t,n))];case"Complex":return[F["a"](Object(l["d"])("real",e,t,n),Object(l["d"])("imag",e,t,n))];case"Cos":return[D["a"](Object(l["d"])("x",e,t,n))];case"Cosh":return[M["a"](Object(l["d"])("x",e,t,n))];case"Elu":return[L["a"](Object(l["d"])("x",e,t,n))];case"Erf":return[P["a"](Object(l["d"])("x",e,t,n))];case"Exp":return[B["a"](Object(l["d"])("x",e,t,n))];case"Expm1":return[V["a"](Object(l["d"])("x",e,t,n))];case"Floor":return[z["a"](Object(l["d"])("x",e,t,n))];case"Log":return[W["a"](Object(l["d"])("x",e,t,n))];case"Log1p":return[U["a"](Object(l["d"])("x",e,t,n))];case"Imag":return[G["a"](Object(l["d"])("x",e,t,n))];case"Neg":return[H["a"](Object(l["d"])("x",e,t,n))];case"Reciprocal":return[q["a"](Object(l["d"])("x",e,t,n))];case"Real":return[K["a"](Object(l["d"])("x",e,t,n))];case"Relu":return[X["a"](Object(l["d"])("x",e,t,n))];case"Round":return[Y["a"](Object(l["d"])("x",e,t,n))];case"Selu":return[Q["a"](Object(l["d"])("x",e,t,n))];case"Sigmoid":return[Z["a"](Object(l["d"])("x",e,t,n))];case"Sin":return[J["a"](Object(l["d"])("x",e,t,n))];case"Sign":return[ee["a"](Object(l["d"])("x",e,t,n))];case"Sinh":return[te["a"](Object(l["d"])("x",e,t,n))];case"Softplus":return[ne["a"](Object(l["d"])("x",e,t,n))];case"Sqrt":return[re["a"](Object(l["d"])("x",e,t,n))];case"Square":return[ae["a"](Object(l["d"])("x",e,t,n))];case"Tanh":return[se["a"](Object(l["d"])("x",e,t,n))];case"Tan":return[oe["a"](Object(l["d"])("x",e,t,n))];case"ClipByValue":return[ie["a"](Object(l["d"])("x",e,t,n),Object(l["d"])("clipValueMin",e,t,n),Object(l["d"])("clipValueMax",e,t,n))];case"Relu6":return[ce["a"](Object(l["d"])("x",e,t,n))];case"Rsqrt":return[ue["a"](Object(l["e"])(e.inputNames[0],t,n))];case"Prod":return[le["a"](Object(l["d"])("x",e,t,n),Object(l["d"])("axes",e,t,n))];case"LeakyRelu":return[de["a"](Object(l["d"])("x",e,t,n),Object(l["d"])("alpha",e,t,n))];case"Prelu":return[pe["a"](Object(l["d"])("x",e,t,n),Object(l["d"])("alpha",e,t,n))];case"IsNan":return[he["a"](Object(l["e"])(e.inputNames[0],t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function me(e,t,n=""){if("number"!==typeof e&&"number"!==typeof t){c["util"].assert(e.length===t.length,()=>n+` Shapes ${e} and ${t} must match`);for(let r=0;r<e.length;r++){const a=e[r],s=t[r];c["util"].assert(a<0||s<0||a===s,()=>n+` Shapes ${e} and ${t} must match`)}}}function be(e){return"number"!==typeof e&&!e.some(e=>e<0)}function ge(e,t,n){let r=ye(e,n);const a=!be(r);if(a&&0===t.length)throw new Error("Tried to calculate elements of an empty list with non-fully-defined elementShape: "+r);if(a&&t.forEach(e=>{r=ye(e.shape,r)}),!be(r))throw new Error("Non-fully-defined elementShape: "+r);return r}function ye(e,t){if("number"===typeof e)return t;if("number"===typeof t)return e;if(e.length!==t.length)throw new Error(`Incompatible ranks during merge: ${e} vs. ${t}`);const n=[];for(let r=0;r<e.length;++r){const a=e[r],s=t[r];if(a>=0&&s>=0&&a!==s)throw new Error(`Incompatible shape during merge: ${e} vs. ${t}`);n[r]=a>=0?a:s}return n}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class xe{constructor(e,t,n,r,a,s,o){this.name=e,this.dtype=t,this.maxSize=n,this.elementShape=r,this.identicalElementShapes=a,this.dynamicSize=s,this.clearAfterRead=o,this.tensors=[],this.closed_=!1,this.idTensor=Object(c["scalar"])(0),Object(c["keep"])(this.idTensor)}get id(){return this.idTensor.id}get closed(){return this.closed_}clearAndClose(e){this.tensors.forEach(t=>{null!=e&&e.has(t.tensor.id)||t.tensor.dispose()}),this.tensors=[],this.closed_=!0,this.idTensor.dispose()}size(){return this.tensors.length}read(e){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(e<0||e>=this.size())throw new Error(`Tried to read from index ${e}, but array size is: ${this.size()}`);const t=this.tensors[e];if(t.cleared)throw new Error(`TensorArray ${this.name}: Could not read index ${e} twice because it was cleared after a previous read (perhaps try setting clear_after_read = false?).`);return this.clearAfterRead&&(t.cleared=!0),t.read=!0,t.tensor}readMany(e){return e.map(e=>this.read(e))}write(e,t){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(e<0||!this.dynamicSize&&e>=this.maxSize)throw new Error(`Tried to write to index ${e}, but array is not resizeable and size is: ${this.maxSize}`);const n=this.tensors[e]||{};if(t.dtype!==this.dtype)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e},\n          because the value dtype is ${t.dtype}, but TensorArray dtype is ${this.dtype}.`);if(0!==this.size()||null!=this.elementShape&&0!==this.elementShape.length||(this.elementShape=t.shape),me(this.elementShape,t.shape,`TensorArray ${this.name}: Could not write to TensorArray index ${e}.`),n.read)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e}, because it has already been read.`);if(n.written)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e}, because it has already been written.`);n.tensor=t,Object(c["keep"])(t),n.written=!0,this.tensors[e]=n}writeMany(e,t){if(e.length!==t.length)throw new Error(`TensorArray ${this.name}: could not write multiple tensors,because the index size: ${e.length} is not the same as tensors size: ${t.length}.`);e.forEach((e,n)=>this.write(e,t[n]))}gather(e,t){if(t&&t!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but gather requested dtype ${t}`);if(e)e=e.slice(0,this.size());else{e=[];for(let t=0;t<this.size();t++)e.push(t)}if(0===e.length)return Object(c["tensor"])([],[0].concat(this.elementShape));const n=this.readMany(e);return me(this.elementShape,n[0].shape,"TensorArray shape mismatch: "),Object(c["stack"])(n,0)}concat(e){if(e&&e!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but concat requested dtype ${e}`);if(0===this.size())return Object(c["tensor"])([],[0].concat(this.elementShape));const t=[];for(let r=0;r<this.size();r++)t.push(r);const n=this.readMany(t);return me(this.elementShape,n[0].shape,`TensorArray shape mismatch: tensor array shape (${this.elementShape}) vs first tensor shape (${n[0].shape})`),Object(c["concat"])(n,0)}scatter(e,t){if(t.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${t.dtype}`);if(e.length!==t.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${e.length} vs. ${t.shape[0]}`);const n=Math.max(...e);if(!this.dynamicSize&&n>=this.maxSize)throw new Error(`Max index must be < array size (${n}  vs. ${this.maxSize})`);this.writeMany(e,Object(c["unstack"])(t,0))}split(e,t){if(t.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${t.dtype}`);let n=0;const r=e.map(e=>(n+=e,n));if(n!==t.shape[0])throw new Error(`Expected sum of lengths to be equal to\n          tensor.shape[0], but sum of lengths is\n        ${n}, and tensor's shape is: ${t.shape}`);if(!this.dynamicSize&&e.length!==this.maxSize)throw new Error(`TensorArray's size is not equal to the size of lengths (${this.maxSize} vs. ${e.length}), and the TensorArray is not marked as dynamically resizeable`);const a=0===n?0:t.size/n,s=[];Object(c["tidy"])(()=>{t=Object(c["reshape"])(t,[1,n,a]);for(let n=0;n<e.length;++n){const o=0===n?0:r[n-1],i=[0,o,0],u=[1,e[n],a];s[n]=Object(c["reshape"])(Object(c["slice"])(t,i,u),this.elementShape)}return s});const o=[];for(let i=0;i<e.length;i++)o[i]=i;this.writeMany(o,s)}}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Oe{constructor(e,t,n,r=-1){this.tensors=e,this.elementShape=t,this.elementDtype=n,null!=e&&e.forEach(e=>{if(n!==e.dtype)throw new Error(`Invalid data types; op elements ${n}, but list elements ${e.dtype}`);me(t,e.shape,"TensorList shape mismatch: "),Object(c["keep"])(e)}),this.idTensor=Object(c["scalar"])(0),this.maxNumElements=r,Object(c["keep"])(this.idTensor)}get id(){return this.idTensor.id}copy(){return new Oe([...this.tensors],this.elementShape,this.elementDtype)}clearAndClose(e){this.tensors.forEach(t=>{null!=e&&e.has(t.id)||t.dispose()}),this.tensors.length=0,this.idTensor.dispose()}size(){return this.tensors.length}stack(e,t,n=-1){if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);if(-1!==n&&this.tensors.length!==n)throw new Error(`Operation expected a list with ${n} elements but got a list with ${this.tensors.length} elements.`);me(e,this.elementShape,"TensorList shape mismatch: ");const r=ge(this.elementShape,this.tensors,e);return Object(c["tidy"])(()=>{const e=this.tensors.map(e=>Object(c["reshape"])(e,r));return Object(c["stack"])(e,0)})}popBack(e,t){if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);if(0===this.size())throw new Error("Trying to pop from an empty list.");const n=ge(this.elementShape,this.tensors,e),r=this.tensors.pop();return me(r.shape,e,"TensorList shape mismatch: "),Object(c["reshape"])(r,n)}pushBack(e){if(e.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${e.dtype}, but list elements ${this.elementDtype}`);if(me(e.shape,this.elementShape,"TensorList shape mismatch: "),this.maxNumElements===this.size())throw new Error("Trying to push element into a full list.");Object(c["keep"])(e),this.tensors.push(e)}resize(e){if(e<0)throw new Error("TensorListResize expects size to be non-negative. Got: "+e);if(-1!==this.maxNumElements&&e>this.maxNumElements)throw new Error(`TensorListResize input size ${e} is greater maxNumElement ${this.maxNumElements}.`);this.tensors.length=e}getItem(e,t,n){if(n!==this.elementDtype)throw new Error(`Invalid data types; op elements ${n}, but list elements ${this.elementDtype}`);if(e<0||e>this.tensors.length)throw new Error(`Trying to access element ${e} in a list with ${this.tensors.length} elements.`);if(null==this.tensors[e])throw new Error(`element at index ${e} is null.`);me(this.tensors[e].shape,t,"TensorList shape mismatch: ");const r=ge(this.elementShape,this.tensors,t);return Object(c["reshape"])(this.tensors[e],r)}setItem(e,t){if(t.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t.dtype}, but list elements ${this.elementDtype}`);if(e<0||-1!==this.maxNumElements&&e>=this.maxNumElements)throw new Error(`Trying to set element ${e} in a list with max ${this.maxNumElements} elements.`);me(this.elementShape,t.shape,"TensorList shape mismatch: "),Object(c["keep"])(t),this.tensors[e]=t}gather(e,t,n){if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);me(this.elementShape,n,"TensorList shape mismatch: "),e=e.slice(0,this.size());const r=ge(this.elementShape,this.tensors,n);return 0===e.length?Object(c["tensor"])([],[0].concat(r)):Object(c["tidy"])(()=>{const t=e.map(e=>Object(c["reshape"])(this.tensors[e],r));return Object(c["stack"])(t,0)})}concat(e,t){if(e&&e!==this.elementDtype)throw new Error(`TensorList dtype is ${this.elementDtype} but concat requested dtype ${e}`);me(this.elementShape,t,"TensorList shape mismatch: ");const n=ge(this.elementShape,this.tensors,t);return 0===this.size()?Object(c["tensor"])([],[0].concat(n)):Object(c["tidy"])(()=>{const e=this.tensors.map(e=>Object(c["reshape"])(e,n));return Object(c["concat"])(e,0)})}}function ve(e,t,n){const r=e.dtype;if(e.shape.length<1)throw new Error("Tensor must be at least a vector, but saw shape: "+e.shape);if(e.dtype!==n)throw new Error(`Invalid data types; op elements ${e.dtype}, but list elements ${n}`);const a=e.shape.slice(1);me(a,t,"TensorList shape mismatch: ");const s=Object(c["unstack"])(e);return new Oe(s,t,r)}function we(e,t,n){return new Oe([],e,t,n)}function ke(e,t,n,r){if(t.length!==e.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${t.length} vs. ${e.shape[0]}`);const a=Math.max(...t);if(null!=r&&-1!==r&&a>=r)throw new Error(`Max index must be < array size (${a}  vs. ${r})`);const s=new Oe([],n,e.dtype,r),o=Object(c["unstack"])(e,0);return t.forEach((e,t)=>{s.setItem(e,o[t])}),s}function je(e,t,n){let r=0;const a=t.map(e=>(r+=e,r));if(r!==e.shape[0])throw new Error(`Expected sum of lengths to be equal to\n          tensor.shape[0], but sum of lengths is\n        ${r}, and tensor's shape is: ${e.shape}`);const s=e.shape.slice(1),o=ye(s,n),i=0===r?0:e.size/r,u=Object(c["tidy"])(()=>{const n=[];e=Object(c["reshape"])(e,[1,r,i]);for(let r=0;r<t.length;++r){const s=0===r?0:a[r-1],u=[0,s,0],l=[1,t[r],i];n[r]=Object(c["reshape"])(Object(c["slice"])(e,u,l),o)}return e.dispose(),n}),l=new Oe([],n,e.dtype,t.length);for(let c=0;c<u.length;c++)l.setItem(c,u[c]);return l}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Se=async(e,t,n)=>{switch(e.op){case"If":case"StatelessIf":{const r=Object(l["d"])("thenBranch",e,t,n),a=Object(l["d"])("elseBranch",e,t,n),s=Object(l["d"])("cond",e,t,n),o=Object(l["d"])("args",e,t,n),i=await s.data();return i[0]?n.functionMap[r].executeFunctionAsync(o,n.tensorArrayMap,n.tensorListMap):n.functionMap[a].executeFunctionAsync(o,n.tensorArrayMap,n.tensorListMap)}case"While":case"StatelessWhile":{const r=Object(l["d"])("body",e,t,n),a=Object(l["d"])("cond",e,t,n),s=Object(l["d"])("args",e,t,n),o=await n.functionMap[a].executeFunctionAsync(s,n.tensorArrayMap,n.tensorListMap),i=s.map(e=>e.id);let c=await o[0].data();o.forEach(e=>{e.kept||-1!==i.indexOf(e.id)||e.dispose()});let u=s;while(c[0]){const e=u;u=await n.functionMap[r].executeFunctionAsync(u,n.tensorArrayMap,n.tensorListMap);const t=u.map(e=>e.id);e.forEach(e=>{e.kept||-1!==i.indexOf(e.id)||-1!==t.indexOf(e.id)||e.dispose()});const s=await n.functionMap[a].executeFunctionAsync(u,n.tensorArrayMap,n.tensorListMap);c=await s[0].data(),s.forEach(e=>{e.kept||-1!==i.indexOf(e.id)||-1!==t.indexOf(e.id)||e.dispose()})}return u}case"LoopCond":{const r=Object(l["d"])("pred",e,t,n);return[Object(l["a"])(r)]}case"Switch":{const r=Object(l["d"])("pred",e,t,n);let a=Object(l["d"])("data",e,t,n);return a.kept||(a=Object(l["a"])(a)),(await r.data())[0]?[void 0,a]:[a,void 0]}case"Merge":{const r=e.inputNames.find(e=>void 0!==Object(l["e"])(e,t,n));if(r){const e=Object(l["e"])(r,t,n);return[Object(l["a"])(e)]}return}case"Enter":{const r=Object(l["d"])("frameName",e,t,n),a=Object(l["d"])("tensor",e,t,n);return n.enterFrame(r),[Object(l["a"])(a)]}case"Exit":{const r=Object(l["d"])("tensor",e,t,n);return n.exitFrame(),[Object(l["a"])(r)]}case"NextIteration":{const r=Object(l["d"])("tensor",e,t,n);return n.nextIteration(),[Object(l["a"])(r)]}case"TensorArrayV3":{const r=Object(l["d"])("size",e,t,n),a=Object(l["d"])("dtype",e,t,n),s=Object(l["d"])("elementShape",e,t,n),o=Object(l["d"])("dynamicSize",e,t,n),i=Object(l["d"])("clearAfterRead",e,t,n),u=Object(l["d"])("identicalElementShapes",e,t,n),d=Object(l["d"])("name",e,t,n),p=new xe(d,a,r,s,u,o,i);return n.addTensorArray(p),[p.idTensor,Object(c["scalar"])(1)]}case"TensorArrayWriteV3":{const r=Object(l["d"])("tensorArrayId",e,t,n),a=Object(l["d"])("index",e,t,n),s=Object(l["d"])("tensor",e,t,n),o=n.getTensorArray(r.id);return o.write(a,s),[o.idTensor]}case"TensorArrayReadV3":{const r=Object(l["d"])("tensorArrayId",e,t,n),a=Object(l["d"])("index",e,t,n),s=n.getTensorArray(r.id);return[s.read(a)]}case"TensorArrayGatherV3":{const r=Object(l["d"])("tensorArrayId",e,t,n),a=Object(l["d"])("indices",e,t,n),s=Object(l["d"])("dtype",e,t,n),o=n.getTensorArray(r.id);return[o.gather(a,s)]}case"TensorArrayScatterV3":{const r=Object(l["d"])("tensorArrayId",e,t,n),a=Object(l["d"])("indices",e,t,n),s=Object(l["d"])("tensor",e,t,n),o=n.getTensorArray(r.id);return o.scatter(a,s),[o.idTensor]}case"TensorArrayConcatV3":{const r=Object(l["d"])("tensorArrayId",e,t,n),a=n.getTensorArray(r.id),s=Object(l["d"])("dtype",e,t,n);return[a.concat(s)]}case"TensorArraySplitV3":{const r=Object(l["d"])("tensorArrayId",e,t,n),a=Object(l["d"])("tensor",e,t,n),s=Object(l["d"])("lengths",e,t,n),o=n.getTensorArray(r.id);return o.split(s,a),[o.idTensor]}case"TensorArraySizeV3":{const r=Object(l["d"])("tensorArrayId",e,t,n),a=n.getTensorArray(r.id);return[Object(c["scalar"])(a.size(),"int32")]}case"TensorArrayCloseV3":{const r=Object(l["d"])("tensorArrayId",e,t,n),a=n.getTensorArray(r.id);return a.clearAndClose(),[a.idTensor]}case"TensorListSetItem":{const r=Object(l["d"])("tensorListId",e,t,n),a=Object(l["d"])("index",e,t,n),s=Object(l["d"])("tensor",e,t,n),o=n.getTensorList(r.id);return o.setItem(a,s),[o.idTensor]}case"TensorListGetItem":{const r=Object(l["d"])("tensorListId",e,t,n),a=Object(l["d"])("index",e,t,n),s=Object(l["d"])("elementShape",e,t,n),o=Object(l["d"])("elementDType",e,t,n),i=n.getTensorList(r.id);return[i.getItem(a,s,o)]}case"TensorListScatterV2":case"TensorListScatter":{const r=Object(l["d"])("indices",e,t,n),a=Object(l["d"])("tensor",e,t,n),s=Object(l["d"])("elementShape",e,t,n),o=Object(l["d"])("numElements",e,t,n),i=ke(a,r,s,o);return n.addTensorList(i),[i.idTensor]}case"TensorListReserve":case"EmptyTensorList":{const r=Object(l["d"])("elementShape",e,t,n),a=Object(l["d"])("elementDType",e,t,n);let s;s="TensorListReserve"===e.op?"numElements":"maxNumElements";const o=Object(l["d"])(s,e,t,n),i=we(r,a,o);return n.addTensorList(i),[i.idTensor]}case"TensorListGather":{const r=Object(l["d"])("tensorListId",e,t,n),a=Object(l["d"])("indices",e,t,n),s=Object(l["d"])("elementShape",e,t,n),o=Object(l["d"])("elementDType",e,t,n),i=n.getTensorList(r.id);return[i.gather(a,o,s)]}case"TensorListStack":{const r=Object(l["d"])("tensorListId",e,t,n),a=Object(l["d"])("elementShape",e,t,n),s=Object(l["d"])("elementDType",e,t,n),o=Object(l["d"])("numElements",e,t,n),i=n.getTensorList(r.id);return[i.stack(a,s,o)]}case"TensorListFromTensor":{const r=Object(l["d"])("tensor",e,t,n),a=Object(l["d"])("elementShape",e,t,n),s=Object(l["d"])("elementDType",e,t,n),o=ve(r,a,s);return n.addTensorList(o),[o.idTensor]}case"TensorListConcat":{const r=Object(l["d"])("tensorListId",e,t,n),a=n.getTensorList(r.id),s=Object(l["d"])("dtype",e,t,n),o=Object(l["d"])("elementShape",e,t,n);return[a.concat(s,o)]}case"TensorListPushBack":{const r=Object(l["d"])("tensorListId",e,t,n),a=Object(l["d"])("tensor",e,t,n),s=n.getTensorList(r.id);return s.pushBack(a),[s.idTensor]}case"TensorListPopBack":{const r=Object(l["d"])("tensorListId",e,t,n),a=Object(l["d"])("elementShape",e,t,n),s=Object(l["d"])("elementDType",e,t,n),o=n.getTensorList(r.id);return[o.popBack(a,s)]}case"TensorListSplit":{const r=Object(l["d"])("tensor",e,t,n),a=Object(l["d"])("elementShape",e,t,n),s=Object(l["d"])("lengths",e,t,n),o=je(r,s,a);return n.addTensorList(o),[o.idTensor]}default:throw TypeError(`Node type ${e.op} is not implemented`)}};var Ne=n("7675"),Ce=n("dd7e"),Ie=n("132b"),Te=n("cd1f"),$e=n("838f"),Ee=n("1590"),Ae=n("9748"),Re=n("9fe6"),_e=n("8bc9"),Fe=n("ba53"),De=n("53fd"),Me=n("c170");
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Le(e,t,n){const[r,a]=Object(l["d"])("fusedOps",e,t,n),s="biasadd"===r,o=!s,i="prelu"===a,c="fusedbatchnorm"===r,u=Object(l["d"])("numArgs",e,t,n);if(s){if(i&&2!==u)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!i&&s&&1!==u)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd must have one extra argument: bias.")}if(c)throw new Error("FusedConv2d and DepthwiseConv2d with FusedBatchNorm is not supported");const d=Object(l["d"])("strides",e,t,n),p=Object(l["c"])(e,t,n),h=Object(l["d"])("dataFormat",e,t,n).toUpperCase(),f=Object(l["d"])("dilations",e,t,n);let[m,b]=Object(l["d"])("args",e,t,n);o&&(b=m,m=void 0);const g=Object(l["d"])("leakyreluAlpha",e,t,n);return{stride:d,pad:p,dataFormat:h,dilations:f,biasArg:m,preluArg:b,activationFunc:a,leakyreluAlpha:g}}const Pe=(e,t,n)=>{switch(e.op){case"Conv1D":{const r=Object(l["d"])("stride",e,t,n),a=Object(l["d"])("pad",e,t,n),s=Object(l["d"])("dataFormat",e,t,n).toUpperCase(),o=Object(l["d"])("dilation",e,t,n);return[Ne["a"](Object(l["d"])("x",e,t,n),Object(l["d"])("filter",e,t,n),r,a,s,o)]}case"Conv2D":{const r=Object(l["d"])("strides",e,t,n),a=Object(l["c"])(e,t,n),s=Object(l["d"])("dataFormat",e,t,n).toUpperCase(),o=Object(l["d"])("dilations",e,t,n);return[Ce["a"](Object(l["d"])("x",e,t,n),Object(l["d"])("filter",e,t,n),[r[1],r[2]],a,s,[o[1],o[2]])]}case"_FusedConv2D":{const{stride:r,pad:a,dataFormat:s,dilations:o,biasArg:i,preluArg:c,activationFunc:u,leakyreluAlpha:d}=Le(e,t,n);return[Ie["rb"].conv2d({x:Object(l["d"])("x",e,t,n),filter:Object(l["d"])("filter",e,t,n),strides:[r[1],r[2]],pad:a,dataFormat:s,dilations:[o[1],o[2]],bias:i,activation:u,preluActivationWeights:c,leakyreluAlpha:d})]}case"FusedDepthwiseConv2dNative":{const{stride:r,pad:a,dataFormat:s,dilations:o,biasArg:i,preluArg:c,activationFunc:u,leakyreluAlpha:d}=Le(e,t,n);return[Ie["rb"].depthwiseConv2d({x:Object(l["d"])("x",e,t,n),filter:Object(l["d"])("filter",e,t,n),strides:[r[1],r[2]],pad:a,dataFormat:s,dilations:[o[1],o[2]],bias:i,activation:u,preluActivationWeights:c,leakyreluAlpha:d})]}case"Conv2DBackpropInput":case"Conv2dTranspose":{const r=Object(l["d"])("outputShape",e,t,n),a=Object(l["d"])("strides",e,t,n),s=Object(l["c"])(e,t,n);return[Te["a"](Object(l["d"])("x",e,t,n),Object(l["d"])("filter",e,t,n),r,[a[1],a[2]],s)]}case"DepthwiseConv2dNative":case"DepthwiseConv2d":{const r=Object(l["d"])("strides",e,t,n),a=Object(l["c"])(e,t,n),s=Object(l["d"])("dilations",e,t,n),o=Object(l["d"])("dataFormat",e,t,n).toUpperCase();return[$e["a"](Object(l["d"])("input",e,t,n),Object(l["d"])("filter",e,t,n),[r[1],r[2]],a,o,[s[1],s[2]])]}case"Conv3D":{const r=Object(l["d"])("strides",e,t,n),a=Object(l["d"])("pad",e,t,n),s=Object(l["d"])("dataFormat",e,t,n).toUpperCase(),o=Object(l["d"])("dilations",e,t,n);return[Ee["a"](Object(l["d"])("x",e,t,n),Object(l["d"])("filter",e,t,n),[r[1],r[2],r[3]],a,s,[o[1],o[2],o[3]])]}case"AvgPool":{const r=Object(l["d"])("strides",e,t,n),a=Object(l["d"])("pad",e,t,n),s=Object(l["d"])("kernelSize",e,t,n);return[Ae["a"](Object(l["d"])("x",e,t,n),[s[1],s[2]],[r[1],r[2]],a)]}case"MaxPool":{const r=Object(l["d"])("strides",e,t,n),a=Object(l["d"])("pad",e,t,n),s=Object(l["d"])("kernelSize",e,t,n);return[Re["a"](Object(l["d"])("x",e,t,n),[s[1],s[2]],[r[1],r[2]],a)]}case"MaxPoolWithArgmax":{const r=Object(l["d"])("strides",e,t,n),a=Object(l["d"])("pad",e,t,n),s=Object(l["d"])("kernelSize",e,t,n),o=Object(l["d"])("includeBatchInIndex",e,t,n),{result:i,indexes:c}=_e["a"](Object(l["d"])("x",e,t,n),[s[1],s[2]],[r[1],r[2]],a,o);return[i,c]}case"AvgPool3D":{const r=Object(l["d"])("strides",e,t,n),a=Object(l["d"])("pad",e,t,n),s=Object(l["d"])("kernelSize",e,t,n);return[Fe["a"](Object(l["d"])("x",e,t,n),[s[1],s[2],s[3]],[r[1],r[2],r[3]],a)]}case"MaxPool3D":{const r=Object(l["d"])("strides",e,t,n),a=Object(l["d"])("pad",e,t,n),s=Object(l["d"])("kernelSize",e,t,n);return[De["a"](Object(l["d"])("x",e,t,n),[s[1],s[2],s[3]],[r[1],r[2],r[3]],a)]}case"Dilation2D":{const r=Object(l["d"])("strides",e,t,n),a=Object(l["d"])("pad",e,t,n),s=Object(l["d"])("dilations",e,t,n),o=r[1],i=r[2],c=s[1],u=s[2];return[Me["a"](Object(l["d"])("x",e,t,n),Object(l["d"])("filter",e,t,n),[o,i],a,[c,u],"NHWC")]}default:throw TypeError(`Node type ${e.op} is not implemented`)}};var Be=n("46b8"),Ve=n("5894"),ze=n("3efc"),We=n("e22c"),Ue=n("c22a"),Ge=n("0db5"),He=n("8629"),qe=n("84d6"),Ke=n("7e6a"),Xe=n("5a2c"),Ye=n("a09b");
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const Qe=(e,t,n)=>{switch(e.op){case"Fill":{const r=Object(l["d"])("shape",e,t,n),a=Object(l["d"])("dtype",e,t,n),s=Object(l["d"])("value",e,t,n);return[Be["a"](r,s,a)]}case"LinSpace":{const r=Object(l["d"])("start",e,t,n),a=Object(l["d"])("stop",e,t,n),s=Object(l["d"])("num",e,t,n);return[Ve["a"](r,a,s)]}case"Multinomial":{const r=Object(l["d"])("logits",e,t,n),a=Object(l["d"])("numSamples",e,t,n),s=Object(l["d"])("seed",e,t,n);return[ze["a"](r,a,s)]}case"OneHot":{const r=Object(l["d"])("indices",e,t,n),a=Object(l["d"])("depth",e,t,n),s=Object(l["d"])("onValue",e,t,n),o=Object(l["d"])("offValue",e,t,n);return[We["a"](r,a,s,o)]}case"Ones":return[Ue["a"](Object(l["d"])("shape",e,t,n),Object(l["d"])("dtype",e,t,n))];case"OnesLike":return[Ge["a"](Object(l["d"])("x",e,t,n))];case"RandomUniform":return[He["a"](Object(l["d"])("shape",e,t,n),Object(l["d"])("minval",e,t,n),Object(l["d"])("maxval",e,t,n),Object(l["d"])("dtype",e,t,n))];case"Range":{const r=Object(l["d"])("start",e,t,n),a=Object(l["d"])("stop",e,t,n),s=Object(l["d"])("step",e,t,n);return[qe["a"](r,a,s,Object(l["d"])("dtype",e,t,n))]}case"TruncatedNormal":{const r=Object(l["d"])("shape",e,t,n),a=Object(l["d"])("mean",e,t,n),s=Object(l["d"])("stdDev",e,t,n),o=Object(l["d"])("seed",e,t,n);return[Ke["a"](r,a,s,Object(l["d"])("dtype",e,t,n),o)]}case"Zeros":return[Xe["a"](Object(l["d"])("shape",e,t,n),Object(l["d"])("dtype",e,t,n))];case"ZerosLike":return[Ye["a"](Object(l["d"])("x",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}};var Ze=n("deb3"),Je=n("a780"),et=n("f74c");
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function tt(e,t,n){const r=Object(l["d"])("boxes",e,t,n),a=Object(l["d"])("scores",e,t,n),s=Object(l["d"])("maxOutputSize",e,t,n),o=Object(l["d"])("iouThreshold",e,t,n),i=Object(l["d"])("scoreThreshold",e,t,n),c=Object(l["d"])("softNmsSigma",e,t,n);return{boxes:r,scores:a,maxOutputSize:s,iouThreshold:o,scoreThreshold:i,softNmsSigma:c}}const nt=async(e,t,n)=>{switch(e.op){case"NonMaxSuppressionV5":{const{boxes:r,scores:a,maxOutputSize:s,iouThreshold:o,scoreThreshold:i,softNmsSigma:c}=tt(e,t,n),u=await Ie["yb"].nonMaxSuppressionWithScoreAsync(r,a,s,o,i,c);return[u.selectedIndices,u.selectedScores]}case"NonMaxSuppressionV4":{const{boxes:r,scores:a,maxOutputSize:s,iouThreshold:o,scoreThreshold:i}=tt(e,t,n),c=Object(l["d"])("padToMaxOutputSize",e,t,n),u=await Ie["yb"].nonMaxSuppressionPaddedAsync(r,a,s,o,i,c);return[u.selectedIndices,u.validOutputs]}case"NonMaxSuppressionV3":case"NonMaxSuppressionV2":{const{boxes:r,scores:a,maxOutputSize:s,iouThreshold:o,scoreThreshold:i}=tt(e,t,n);return[await Ie["yb"].nonMaxSuppressionAsync(r,a,s,o,i)]}case"Where":{const r=Ze["a"](Object(l["d"])("condition",e,t,n),"bool"),a=[await Je["a"](r)];return r.dispose(),a}case"ListDiff":return et["a"](Object(l["d"])("x",e,t,n),Object(l["d"])("y",e,t,n));default:throw TypeError(`Node type ${e.op} is not implemented`)}};var rt=n("5616"),at=n("853e");
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const st=(e,t,n)=>{switch(e.op){case"TopKV2":{const r=Object(l["d"])("x",e,t,n),a=Object(l["d"])("k",e,t,n),s=Object(l["d"])("sorted",e,t,n),o=rt["a"](r,a,s);return[o.values,o.indices]}case"Unique":{const r=Object(l["d"])("x",e,t,n),a=at["a"](r);return[a.values,a.indices]}case"UniqueV2":{const r=Object(l["d"])("x",e,t,n),a=Object(l["d"])("axis",e,t,n),s=at["a"](r,a);return[s.values,s.indices]}default:throw TypeError(`Node type ${e.op} is not implemented`)}};var ot=n("960f"),it=n("015f");
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const ct=(e,t,n)=>{switch(e.op){case"Const":return t[e.name];case"PlaceholderWithDefault":const r=Object(l["d"])("default",e,t,n);return[Object(l["e"])(e.name,t,n)||r];case"Placeholder":return[Object(l["e"])(e.name,t,n)];case"Identity":case"StopGradient":case"FakeQuantWithMinMaxVars":{const r=Object(l["d"])("x",e,t,n);return[Object(l["a"])(r)]}case"IdentityN":return Object(l["d"])("x",e,t,n).map(e=>Object(l["a"])(e));case"Snapshot":const a=Object(l["d"])("x",e,t,n);return[Object(l["a"])(a)];case"Shape":return[ot["a"](Object(l["d"])("x",e,t,n).shape,"int32")];case"ShapeN":return Object(l["d"])("x",e,t,n).map(e=>ot["a"](e.shape));case"Size":return[it["a"](Object(l["d"])("x",e,t,n).size,"int32")];case"Rank":return[it["a"](Object(l["d"])("x",e,t,n).rank,"int32")];case"NoOp":return[it["a"](1)];case"Print":const s=Object(l["d"])("x",e,t,n),o=Object(l["d"])("data",e,t,n),i=Object(l["d"])("message",e,t,n),c=Object(l["d"])("summarize",e,t,n);console.warn("The graph has a tf.print() operation,usually used for debugging, which slows down performance."),console.log(i);for(let e=0;e<o.length;e++)console.log(Array.prototype.slice.call(o[e].dataSync()).slice(0,c));return[s];default:throw TypeError(`Node type ${e.op} is not implemented`)}};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class ut{constructor(e,t){this.keyDType=e,this.valueDType=t,this.handle=Object(c["scalar"])(0),this.tensorMap=new Map,Object(c["keep"])(this.handle)}get id(){return this.handle.id}clearAndClose(){this.tensorMap.forEach(e=>e.dispose()),this.tensorMap.clear(),this.handle.dispose()}size(){return this.tensorMap.size}tensorSize(){return it["a"](this.size(),"int32")}async import(e,t){this.checkKeyAndValueTensor(e,t);const n=await e.data();return this.tensorMap.forEach(e=>e.dispose()),this.tensorMap.clear(),Object(c["tidy"])(()=>{const e=Object(c["unstack"])(t),r=n.length,a=e.length;c["util"].assert(r===a,()=>`The number of elements doesn't match, keys has ${r} elements, the values has ${a} elements.`);for(let t=0;t<r;t++){const r=n[t],a=e[t];Object(c["keep"])(a),this.tensorMap.set(r,a)}return this.handle})}async find(e,t){this.checkKeyAndValueTensor(e,t);const n=await e.data();return Object(c["tidy"])(()=>{const e=[];for(let r=0;r<n.length;r++){const a=n[r],s=this.findWithDefault(a,t);e.push(s)}return Object(c["stack"])(e)})}findWithDefault(e,t){const n=this.tensorMap.get(e);return null!=n?n:t}checkKeyAndValueTensor(e,t){if(e.dtype!==this.keyDType)throw new Error(`Expect key dtype ${this.keyDType}, but got `+e.dtype);if(t.dtype!==this.valueDType)throw new Error(`Expect value dtype ${this.valueDType}, but got `+t.dtype)}}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const lt=async(e,t,n,r)=>{switch(e.op){case"HashTable":case"HashTableV2":{const a=Object(l["d"])("keyDType",e,t,n),s=Object(l["d"])("valueDType",e,t,n),o=new ut(a,s);return r.addHashTable(e.name,o),[o.handle]}case"LookupTableImport":case"LookupTableImportV2":{const a=Object(l["d"])("tableHandle",e,t,n,r),s=Object(l["d"])("keys",e,t,n),o=Object(l["d"])("values",e,t,n),i=r.getHashTableById(a.id);return[await i.import(s,o)]}case"LookupTableFind":case"LookupTableFindV2":{const a=Object(l["d"])("tableHandle",e,t,n,r),s=Object(l["d"])("keys",e,t,n),o=Object(l["d"])("defaultValue",e,t,n),i=r.getHashTableById(a.id);return[await i.find(s,o)]}case"LookupTableSize":case"LookupTableSizeV2":{const a=Object(l["d"])("tableHandle",e,t,n,r),s=r.getHashTableById(a.id);return[s.tensorSize()]}default:throw TypeError(`Node type ${e.op} is not implemented`)}},dt=(e,t,n)=>{switch(e.op){case"ResizeBilinear":{const r=Object(l["d"])("images",e,t,n),a=Object(l["d"])("size",e,t,n),s=Object(l["d"])("alignCorners",e,t,n),o=Object(l["d"])("halfPixelCenters",e,t,n);return[Ie["yb"].resizeBilinear(r,[a[0],a[1]],s,o)]}case"ResizeNearestNeighbor":{const r=Object(l["d"])("images",e,t,n),a=Object(l["d"])("size",e,t,n),s=Object(l["d"])("alignCorners",e,t,n),o=Object(l["d"])("halfPixelCenters",e,t,n);return[Ie["yb"].resizeNearestNeighbor(r,[a[0],a[1]],s,o)]}case"CropAndResize":{const r=Object(l["d"])("image",e,t,n),a=Object(l["d"])("boxes",e,t,n),s=Object(l["d"])("boxInd",e,t,n),o=Object(l["d"])("cropSize",e,t,n),i=Object(l["d"])("method",e,t,n),c=Object(l["d"])("extrapolationValue",e,t,n);return[Ie["yb"].cropAndResize(r,a,s,o,i,c)]}default:throw TypeError(`Node type ${e.op} is not implemented`)}};var pt=n("b9b9"),ht=n("d4de"),ft=n("cef0"),mt=n("bb2d"),bt=n("e1fd"),gt=n("b21c"),yt=n("e333"),xt=n("ef00"),Ot=n("f183"),vt=n("6791");
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const wt=(e,t,n)=>{switch(e.op){case"Equal":return[pt["a"](Object(l["d"])("a",e,t,n),Object(l["d"])("b",e,t,n))];case"NotEqual":return[ht["a"](Object(l["d"])("a",e,t,n),Object(l["d"])("b",e,t,n))];case"Greater":return[ft["a"](Object(l["d"])("a",e,t,n),Object(l["d"])("b",e,t,n))];case"GreaterEqual":return[mt["a"](Object(l["d"])("a",e,t,n),Object(l["d"])("b",e,t,n))];case"Less":return[bt["a"](Object(l["d"])("a",e,t,n),Object(l["d"])("b",e,t,n))];case"LessEqual":return[gt["a"](Object(l["d"])("a",e,t,n),Object(l["d"])("b",e,t,n))];case"LogicalAnd":return[yt["a"](Object(l["d"])("a",e,t,n),Object(l["d"])("b",e,t,n))];case"LogicalNot":return[xt["a"](Object(l["d"])("a",e,t,n))];case"LogicalOr":return[Ot["a"](Object(l["d"])("a",e,t,n),Object(l["d"])("b",e,t,n))];case"Select":case"SelectV2":return[vt["a"](Object(l["d"])("condition",e,t,n),Object(l["d"])("a",e,t,n),Object(l["d"])("b",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}};var kt=n("487b"),jt=n("75ab"),St=n("c912");
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const Nt=(e,t,n)=>{switch(e.op){case"BatchMatMul":case"BatchMatMulV2":case"MatMul":return[kt["a"](Object(l["d"])("a",e,t,n),Object(l["d"])("b",e,t,n),Object(l["d"])("transposeA",e,t,n),Object(l["d"])("transposeB",e,t,n))];case"Einsum":return[jt["a"](Object(l["d"])("equation",e,t,n),...Object(l["d"])("tensors",e,t,n))];case"Transpose":return[St["a"](Object(l["d"])("x",e,t,n),Object(l["d"])("perm",e,t,n))];case"_FusedMatMul":const[r,a]=Object(l["d"])("fusedOps",e,t,n),s="biasadd"===r,o="prelu"===a,i=Object(l["d"])("numArgs",e,t,n),c=Object(l["d"])("leakyreluAlpha",e,t,n);if(s){if(o&&2!==i)throw new Error("Fused MatMul with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!o&&1!==i)throw new Error("Fused MatMul with BiasAdd must have one extra argument: bias.")}const[u,d]=Object(l["d"])("args",e,t,n);return[Ie["rb"].matMul({a:Object(l["d"])("a",e,t,n),b:Object(l["d"])("b",e,t,n),transposeA:Object(l["d"])("transposeA",e,t,n),transposeB:Object(l["d"])("transposeB",e,t,n),bias:u,activation:a,preluActivationWeights:d,leakyreluAlpha:c})];default:throw TypeError(`Node type ${e.op} is not implemented`)}};var Ct=n("71db"),It=n("e101"),Tt=n("5f87"),$t=n("804a"),Et=n("bc62");
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const At=(e,t,n)=>{switch(e.op){case"FusedBatchNorm":case"FusedBatchNormV2":return[Ct["a"](Object(l["d"])("x",e,t,n),Object(l["d"])("mean",e,t,n),Object(l["d"])("variance",e,t,n),Object(l["d"])("offset",e,t,n),Object(l["d"])("scale",e,t,n),Object(l["d"])("epsilon",e,t,n))];case"FusedBatchNormV3":return[Ct["a"](Object(l["d"])("x",e,t,n),Object(l["d"])("mean",e,t,n),Object(l["d"])("variance",e,t,n),Object(l["d"])("offset",e,t,n),Object(l["d"])("scale",e,t,n),Object(l["d"])("epsilon",e,t,n))];case"LRN":return[It["a"](Object(l["d"])("x",e,t,n),Object(l["d"])("radius",e,t,n),Object(l["d"])("bias",e,t,n),Object(l["d"])("alpha",e,t,n),Object(l["d"])("beta",e,t,n))];case"Softmax":return[Tt["a"](Object(l["d"])("x",e,t,n))];case"LogSoftmax":return[$t["a"](Object(l["d"])("x",e,t,n))];case"SparseToDense":return[Et["a"](Object(l["d"])("sparseIndices",e,t,n),Object(l["d"])("outputShape",e,t,n),Object(l["d"])("sparseValues",e,t,n),Object(l["d"])("defaultValue",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}};var Rt=n("c021"),_t=n("122e"),Ft=n("ae6d"),Dt=n("e053"),Mt=n("df81"),Lt=n("4516"),Pt=n("e89f"),Bt=n("db49"),Vt=n("1e68"),zt=n("04c4"),Wt=n("2f2c");
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const Ut=(e,t,n)=>{switch(e.op){case"Max":{const r=Object(l["d"])("axis",e,t,n),a=Object(l["d"])("keepDims",e,t,n);return[Rt["a"](Object(l["d"])("x",e,t,n),r,a)]}case"Mean":{const r=Object(l["d"])("axis",e,t,n),a=Object(l["d"])("keepDims",e,t,n);return[_t["a"](Object(l["d"])("x",e,t,n),r,a)]}case"Min":{const r=Object(l["d"])("axis",e,t,n),a=Object(l["d"])("keepDims",e,t,n);return[Ft["a"](Object(l["d"])("x",e,t,n),r,a)]}case"Sum":{const r=Object(l["d"])("axis",e,t,n),a=Object(l["d"])("keepDims",e,t,n);return[Dt["a"](Object(l["d"])("x",e,t,n),r,a)]}case"All":{const r=Object(l["d"])("axis",e,t,n),a=Object(l["d"])("keepDims",e,t,n);return[Mt["a"](Object(l["d"])("x",e,t,n),r,a)]}case"Any":{const r=Object(l["d"])("axis",e,t,n),a=Object(l["d"])("keepDims",e,t,n);return[Lt["a"](Object(l["d"])("x",e,t,n),r,a)]}case"ArgMax":{const r=Object(l["d"])("axis",e,t,n);return[Pt["a"](Object(l["d"])("x",e,t,n),r)]}case"ArgMin":{const r=Object(l["d"])("axis",e,t,n);return[Bt["a"](Object(l["d"])("x",e,t,n),r)]}case"Prod":{const r=Object(l["d"])("axis",e,t,n),a=Object(l["d"])("keepDims",e,t,n);return[le["a"](Object(l["d"])("x",e,t,n),r,a)]}case"Cumsum":{const r=Object(l["d"])("axis",e,t,n),a=Object(l["d"])("exclusive",e,t,n),s=Object(l["d"])("reverse",e,t,n);return[Vt["a"](Object(l["d"])("x",e,t,n),r,a,s)]}case"Bincount":const r=Object(l["d"])("x",e,t,n),a=Object(l["d"])("weights",e,t,n),s=Object(l["d"])("size",e,t,n);return[zt["a"](r,a,s)];case"DenseBincount":{const r=Object(l["d"])("x",e,t,n),a=Object(l["d"])("weights",e,t,n),s=Object(l["d"])("size",e,t,n),o=Object(l["d"])("binaryOutput",e,t,n);return[Wt["a"](r,a,s,o)]}default:throw TypeError(`Node type ${e.op} is not implemented`)}};var Gt=n("649e"),Ht=n("91a3"),qt=n("d08e"),Kt=n("6d3c"),Xt=n("de1a"),Yt=n("d1f4"),Qt=n("35c9"),Zt=n("d54d"),Jt=n("3a44"),en=n("8d71"),tn=n("45bb"),nn=n("8bfa"),rn=n("ba40");
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const an=(e,t,n)=>{switch(e.op){case"ConcatV2":case"Concat":{const r=Object(l["d"])("n",e,t,n),a=Object(l["d"])("axis",e,t,n);let s=Object(l["d"])("tensors",e,t,n);return s=s.slice(0,r),[Gt["a"](s,a)]}case"Gather":{const r=Object(l["d"])("x",e,t,n),a=Object(l["d"])("indices",e,t,n);return[Ht["a"](r,Ze["a"](a,"int32"),0)]}case"GatherV2":{const r=Object(l["d"])("axis",e,t,n),a=Object(l["d"])("batchDims",e,t,n),s=Object(l["d"])("x",e,t,n),o=Object(l["d"])("indices",e,t,n);return[Ht["a"](s,Ze["a"](o,"int32"),r,a)]}case"Reverse":{const r=Object(l["d"])("dims",e,t,n),a=[];for(let e=0;e<r.length;e++)r[e]&&a.push(e);const s=Object(l["d"])("x",e,t,n);return[qt["a"](s,a)]}case"ReverseV2":{const r=Object(l["d"])("axis",e,t,n),a=Object(l["d"])("x",e,t,n);return[qt["a"](a,r)]}case"Slice":{const r=Object(l["d"])("begin",e,t,n),a=Object(l["d"])("size",e,t,n);return[Kt["a"](Object(l["d"])("x",e,t,n),r,a)]}case"StridedSlice":{const r=Object(l["d"])("begin",e,t,n),a=Object(l["d"])("end",e,t,n),s=Object(l["d"])("strides",e,t,n),o=Object(l["d"])("beginMask",e,t,n),i=Object(l["d"])("endMask",e,t,n),c=Object(l["d"])("ellipsisMask",e,t,n),u=Object(l["d"])("newAxisMask",e,t,n),d=Object(l["d"])("shrinkAxisMask",e,t,n),p=Object(l["d"])("x",e,t,n);return[Xt["a"](p,r,a,s,o,i,c,u,d)]}case"Pack":return Object(c["tidy"])(()=>{const r=Object(l["d"])("axis",e,t,n),a=Object(l["d"])("tensors",e,t,n),s=a[0].shape,o=Yt["a"](a[0]).shape,i=a.map(e=>{const t=c["util"].arraysEqual(e.shape,s);if(!t&&!c["util"].arraysEqual(Yt["a"](e).shape,o))throw new Error("the input tensors shape does not match");return t?e:Qt["a"](e,s)});return[Zt["a"](i,r)]});case"Unpack":{const r=Object(l["d"])("axis",e,t,n),a=Object(l["d"])("tensor",e,t,n);return Jt["a"](a,r)}case"Tile":{const r=Object(l["d"])("reps",e,t,n);return[en["a"](Object(l["d"])("x",e,t,n),r)]}case"Split":case"SplitV":{const r=Object(l["d"])("axis",e,t,n),a=Object(l["d"])("numOrSizeSplits",e,t,n),s=Object(l["d"])("x",e,t,n);return tn["a"](s,a,r)}case"ScatterNd":{const r=Object(l["d"])("indices",e,t,n),a=Object(l["d"])("values",e,t,n),s=Object(l["d"])("shape",e,t,n);return[nn["a"](r,a,s)]}case"GatherNd":{const r=Object(l["d"])("x",e,t,n),a=Object(l["d"])("indices",e,t,n);return[rn["a"](r,a)]}case"SparseToDense":{const r=Object(l["d"])("sparseIndices",e,t,n),a=Object(l["d"])("outputShape",e,t,n),s=Object(l["d"])("sparseValues",e,t,n),o=Object(l["d"])("defaultValue",e,t,n);return[Et["a"](r,s,a,s.dtype===o.dtype?o:Ze["a"](o,s.dtype))]}default:throw TypeError(`Node type ${e.op} is not implemented`)}},sn=(e,t,n)=>{switch(e.op){case"SparseFillEmptyRows":{const{outputIndices:r,outputValues:a,emptyRowIndicator:s,reverseIndexMap:o}=Ie["nd"].sparseFillEmptyRows(Object(l["d"])("indices",e,t,n),Object(l["d"])("values",e,t,n),Object(l["d"])("denseShape",e,t,n),Object(l["d"])("defaultValue",e,t,n));return[r,a,s,o]}case"SparseReshape":{const{outputIndices:r,outputShape:a}=Ie["nd"].sparseReshape(Object(l["d"])("inputIndices",e,t,n),Object(l["d"])("inputShape",e,t,n),Object(l["d"])("newShape",e,t,n));return[r,a]}case"SparseSegmentMean":{const r=Ie["nd"].sparseSegmentMean(Object(l["d"])("data",e,t,n),Object(l["d"])("indices",e,t,n),Object(l["d"])("segmentIds",e,t,n));return[r]}case"SparseSegmentSum":{const r=Ie["nd"].sparseSegmentSum(Object(l["d"])("data",e,t,n),Object(l["d"])("indices",e,t,n),Object(l["d"])("segmentIds",e,t,n));return[r]}default:throw TypeError(`Node type ${e.op} is not implemented`)}};var on=n("1ab7"),cn=n("4c7a"),un=n("b61d"),ln=n("69dc");
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const dn=(e,t,n)=>{switch(e.op){case"FFT":return[on["a"](Object(l["d"])("x",e,t,n))];case"IFFT":return[cn["a"](Object(l["d"])("x",e,t,n))];case"RFFT":return[un["a"](Object(l["d"])("x",e,t,n))];case"IRFFT":return[ln["a"](Object(l["d"])("x",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}},pn=(e,t,n)=>{switch(e.op){case"StringNGrams":{const{nGrams:r,nGramsSplits:a}=Ie["yd"].stringNGrams(Object(l["d"])("data",e,t,n),Object(l["d"])("dataSplits",e,t,n),Object(l["d"])("separator",e,t,n),Object(l["d"])("nGramWidths",e,t,n),Object(l["d"])("leftPad",e,t,n),Object(l["d"])("rightPad",e,t,n),Object(l["d"])("padWidth",e,t,n),Object(l["d"])("preserveShortSequences",e,t,n));return[r,a]}case"StringSplit":{const{indices:r,values:a,shape:s}=Ie["yd"].stringSplit(Object(l["d"])("input",e,t,n),Object(l["d"])("delimiter",e,t,n),Object(l["d"])("skipEmpty",e,t,n));return[r,a,s]}case"StringToHashBucketFast":{const r=Ie["yd"].stringToHashBucketFast(Object(l["d"])("input",e,t,n),Object(l["d"])("numBuckets",e,t,n));return[r]}default:throw TypeError(`Node type ${e.op} is not implemented`)}};var hn=n("dae8"),fn=n("93db"),mn=n("0eb5"),bn=n("7580"),gn=n("3b28"),yn=n("364e"),xn=n("48db"),On=n("22e3");
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const vn=(e,t,n)=>{switch(e.op){case"Cast":return[Ze["a"](Object(l["d"])("x",e,t,n),Object(l["d"])("dtype",e,t,n))];case"ExpandDims":{const r=Object(l["d"])("axis",e,t,n);return[hn["a"](Object(l["d"])("x",e,t,n),r)]}case"Squeeze":{const r=Object(l["d"])("axis",e,t,n);return[Yt["a"](Object(l["d"])("x",e,t,n),r)]}case"Reshape":return[Qt["a"](Object(l["d"])("x",e,t,n),Object(l["d"])("shape",e,t,n))];case"MirrorPad":return[fn["a"](Object(l["d"])("x",e,t,n),Object(l["d"])("padding",e,t,n),Object(l["d"])("mode",e,t,n))];case"PadV2":case"Pad":return[mn["a"](Object(l["d"])("x",e,t,n),Object(l["d"])("padding",e,t,n),Object(l["d"])("constantValue",e,t,n))];case"SpaceToBatchND":{const r=Object(l["d"])("blockShape",e,t,n),a=Object(l["d"])("paddings",e,t,n);return[bn["a"](Object(l["d"])("x",e,t,n),r,a)]}case"BatchToSpaceND":{const r=Object(l["d"])("blockShape",e,t,n),a=Object(l["d"])("crops",e,t,n);return[gn["a"](Object(l["d"])("x",e,t,n),r,a)]}case"DepthToSpace":{const r=Object(l["d"])("blockSize",e,t,n),a=Object(l["d"])("dataFormat",e,t,n).toUpperCase();return[yn["a"](Object(l["d"])("x",e,t,n),r,a)]}case"BroadcastTo":return[xn["a"](Object(l["d"])("x",e,t,n),Object(l["d"])("shape",e,t,n))];case"BroadcastArgs":return[On["a"](Object(l["d"])("s0",e,t,n),Object(l["d"])("s1",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}};
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function wn(e,t,n,r){const a=((e,t,n)=>{switch(e.category){case"arithmetic":return c["tidy"](()=>S(e,t,n));case"basic_math":return c["tidy"](()=>fe(e,t,n));case"control":return Se(e,t,n);case"convolution":return c["tidy"](()=>Pe(e,t,n));case"creation":return c["tidy"](()=>Qe(e,t,n));case"dynamic":return nt(e,t,n);case"evaluation":return c["tidy"](()=>st(e,t,n));case"image":return c["tidy"](()=>dt(e,t,n));case"graph":return c["tidy"](()=>ct(e,t,n));case"logical":return c["tidy"](()=>wt(e,t,n));case"matrices":return c["tidy"](()=>Nt(e,t,n));case"normalization":return c["tidy"](()=>At(e,t,n));case"reduction":return c["tidy"](()=>Ut(e,t,n));case"slice_join":return c["tidy"](()=>an(e,t,n));case"sparse":return c["tidy"](()=>sn(e,t,n));case"spectral":return c["tidy"](()=>dn(e,t,n));case"string":return c["tidy"](()=>pn(e,t,n));case"transformation":return c["tidy"](()=>vn(e,t,n));case"hash_table":return lt(e,t,n,r);case"custom":const a=Object(p["a"])(e.op);if(a&&a.customExecutor)return a.customExecutor(new d(e,t,n));throw TypeError(`Custom op ${e.op} is not registered.`);default:throw TypeError(`Unknown op '${e.op}'. File an issue at https://github.com/tensorflow/tfjs/issues so we can add it, or register a custom execution with tf.registerOp()`)}})(e,t,n);return c["util"].isPromise(a)?a.then(e=>[].concat(e)):[].concat(a)}class kn{constructor(e={},t={},n={},r={}){this.weightMap=e,this.tensorArrayMap=t,this.tensorListMap=n,this.functionMap=r,this.rootContext={id:0,frameName:"",iterationId:0},this.contexts=[this.rootContext],this.lastId=0,this.generateCurrentContextIds()}newFrame(e,t){return{id:e,frameName:t,iterationId:0}}set currentContext(e){this.contexts!==e&&(this.contexts=e,this.generateCurrentContextIds())}get currentContext(){return this.contexts}get currentContextId(){return this._currentContextIds[0]}get currentContextIds(){return this._currentContextIds}generateCurrentContextIds(){const e=[];for(let t=0;t<this.contexts.length-1;t++){const n=this.contexts.slice(0,this.contexts.length-t);e.push(this.contextIdforContexts(n))}e.push(""),this._currentContextIds=e}contextIdforContexts(e){return e?e.map(e=>0===e.id&&0===e.iterationId?"":`${e.frameName}-${e.iterationId}`).join("/"):""}enterFrame(e){this.contexts&&(this.lastId++,this.contexts=this.contexts.slice(),this.contexts.push(this.newFrame(this.lastId,e)),this._currentContextIds.unshift(this.contextIdforContexts(this.contexts)))}exitFrame(){if(!(this.contexts&&this.contexts.length>1))throw new Error("Cannot exit frame, the context is empty");this.contexts=this.contexts.slice(),this.contexts.splice(-1),this.currentContextIds.shift()}nextIteration(){if(!(this.contexts&&this.contexts.length>0))throw new Error("Cannot increase frame iteration, the context is empty");{this.contexts=this.contexts.slice(),this.lastId++;const e=Object.assign({},this.contexts[this.contexts.length-1]);e.iterationId+=1,e.id=this.lastId,this.contexts.splice(-1,1,e),this._currentContextIds.splice(0,1,this.contextIdforContexts(this.contexts))}}getWeight(e){return this.weightMap[e]}addTensorArray(e){this.tensorArrayMap[e.id]=e}getTensorArray(e){return this.tensorArrayMap[e]}addTensorList(e){this.tensorListMap[e.id]=e}getTensorList(e){return this.tensorListMap[e]}dispose(e){for(const t in this.tensorArrayMap)this.tensorArrayMap[t].clearAndClose(e);for(const t in this.tensorListMap)this.tensorListMap[t].clearAndClose(e)}}
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jn(e,t,n,r){const a=new Set,s=[];let o=null,i=null;const c=new Set,u=Object.keys(e).map(e=>Object(l["g"])(e)[0]);let d=[];null!=r&&(d=r.map(e=>Object(l["g"])(e.name)[0]));const p=[...t];while(p.length>0){const e=p.pop();(Tn(e)||$n(e)||En(e))&&null==o&&(o=e,i=o.children.map(e=>e.name).filter(e=>a.has(e))),a.add(e.name),null==n[e.name]&&(-1===u.indexOf(e.name)&&-1===d.indexOf(e.name)&&(0!==e.inputs.length?e.inputs.forEach(e=>{c.has(e.name)||(c.add(e.name),p.push(e))}):s.push(e.name)))}return{inputs:e,outputs:t,usedNodes:a,missingInputs:s,dynamicNode:o,syncInputs:i}}function Sn(e,t,n){const{usedNodes:r,inputs:a}=n,s=[],o=Object.keys(a).map(e=>Object(l["g"])(e)[0]).map(t=>e.nodes[t]),i=e.initNodes;o.forEach(e=>{r.has(e.name)&&s.push(e)}),e.weights.forEach(e=>{r.has(e.name)&&s.push(e)}),null!=i&&i.forEach(e=>{r.has(e.name)&&s.push(e)});const c=new Set,u=[];while(s.length>0){const e=s.pop();c.add(e.name),t[e.name]||u.push(e),e.children.forEach(e=>{!c.has(e.name)&&r.has(e.name)&&e.inputs.every(e=>c.has(e.name))&&s.push(e)})}return u}const Nn=["Switch","Merge","Enter","Exit","NextIteration","StatelessIf","StatelessWhile","if","While"],Cn=["NonMaxSuppressionV2","NonMaxSuppressionV3","NonMaxSuppressionV5","Where"],In=["HashTable","HashTableV2","LookupTableImport","LookupTableImportV2","LookupTableFind","LookupTableFindV2","LookupTableSize","LookupTableSizeV2"];function Tn(e){return Nn.indexOf(e.op)>=0}function $n(e){return Cn.indexOf(e.op)>=0}function En(e){return In.indexOf(e.op)>=0}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class An{constructor(e,t){this.graph=e,this.parent=t,this.compiledMap=new Map,this._weightMap={},this.SEPERATOR=",",this._functions={},this._functionExecutorMap={},this._outputs=e.outputs,this._inputs=e.inputs,this._initNodes=e.initNodes,this._signature=e.signature,this._functions=e.functions,null!=e.functions&&Object.keys(e.functions).forEach(t=>{this._functionExecutorMap[t]=new An(e.functions[t],this)})}get weightIds(){return this.parent?this.parent.weightIds:this._weightIds}get functionExecutorMap(){return this.parent?this.parent.functionExecutorMap:this._functionExecutorMap}get weightMap(){return this.parent?this.parent.weightMap:this._weightMap}set weightMap(e){const t=Object.keys(e).map(t=>e[t].map(e=>e.id));this._weightIds=[].concat(...t),this._weightMap=e}set resourceManager(e){this._resourceManager=e}get inputs(){return this._inputs.map(e=>({name:e.name,shape:e.attrParams["shape"]?e.attrParams["shape"].value:void 0,dtype:e.attrParams["dtype"]?e.attrParams["dtype"].value:void 0}))}get outputs(){return this._outputs.map(e=>({name:e.name,shape:e.attrParams["shape"]?e.attrParams["shape"].value:void 0,dtype:e.attrParams["dtype"]?e.attrParams["dtype"].value:void 0}))}get inputNodes(){return this._inputs.map(e=>e.signatureKey||e.name)}get outputNodes(){return this._outputs.map(e=>{const t=e.signatureKey||e.name;return e.defaultOutput?`${t}:${e.defaultOutput}`:t})}get functions(){return Object.keys(this._functions).reduce((e,t)=>(e[t]=this._functions[t].signature,e),{})}getCompilationKey(e,t){const n=e.map(e=>e.name).sort(),r=t.map(e=>e.name).sort();return n.join(this.SEPERATOR)+"--"+r.join(this.SEPERATOR)}compile(e,t){const n=jn(e,t,this.weightMap,this._initNodes),{missingInputs:r,dynamicNode:a,syncInputs:s}=n;if(null!=a)throw new Error(`This execution contains the node '${a.name}', which has the dynamic op '${a.op}'. Please use model.executeAsync() instead. Alternatively, to avoid the dynamic ops, specify the inputs [${s}]`);if(r.length>0){const n=t.map(e=>e.name),a=Object.keys(e);throw new Error(`Cannot compute the outputs [${n}] from the provided inputs [${a}]. Missing the following inputs: [${r}]`)}return Sn(this.graph,this.weightMap,n)}execute(e,t){e=this.mapInputs(e);const n=Object.keys(e).sort();this.checkInputs(e),this.checkInputShapeAndType(e),t=this.mapOutputs(t),this.checkOutputs(t);const r=n.map(e=>this.graph.nodes[Object(l["g"])(e)[0]]),a=t.map(e=>Object(l["g"])(e)[0]);let s=a.map(e=>this.graph.nodes[e]);0===s.length&&(s=this._outputs);const o=this.getCompilationKey(r,s);let i=this.compiledMap.get(o);null==i&&(i=this.compile(e,s),this.compiledMap.set(o,i));const u={},d={};return Object(c["tidy"])(()=>{const n=new kn(this.weightMap,u,d,this.functionExecutorMap),r=Object.assign({},this.weightMap);Object.keys(e).forEach(t=>{const[n,a]=Object(l["g"])(t),s=[];s[a]=e[t],r[n]=s});const s=this.getFrozenTensorIds(r),o={};for(let e=0;e<i.length;e++){const t=i[e];if(!r[t.name]){const e=wn(t,r,n,this._resourceManager);if(c["util"].isPromise(e))throw new Error(`The execution of the op '${t.op}' returned a promise. Please use model.executeAsync() instead.`);r[t.name]=e,this.checkTensorForDisposal(t.name,t,r,n,s,a,o)}}return null==this.parent&&n.dispose(s),t.map(e=>Object(l["e"])(e,r,n))})}getFrozenTensorIds(e){const t=[].concat.apply([],Object.keys(e).map(t=>e[t]).map(e=>e.map(e=>e.id)));return new Set(t)}checkTensorForDisposal(e,t,n,r,a,s,o){"control"!==t.category&&-1===s.indexOf(e)&&(n[e].forEach(e=>{null!=e&&(o[e.id]=(o[e.id]||0)+t.children.length)}),t.inputs.forEach(e=>{if("control"!==e.category){const t=Object(l["f"])(e.name,n,r);null!=t&&t.forEach(e=>{if(e&&!e.kept&&!a.has(e.id)){const t=o[e.id];1===t?(e.dispose(),delete o[e.id]):null!=t&&o[e.id]--}})}}))}async executeAsync(e,t){return this._executeAsync(e,t)}async _executeAsync(e,t,n=!1,r={},a={}){n||(e=this.mapInputs(e),this.checkInputs(e),this.checkInputShapeAndType(e),t=this.mapOutputs(t),this.checkOutputs(t));const s=new kn(this.weightMap,r,a,this.functionExecutorMap),o=await this.executeWithControlFlow(e,s,t,n),i=t.map(e=>Object(l["e"])(e,o,s)),c=i.map(e=>e.id),u=Object.keys(e).map(t=>e[t].id),d=new Set([...c,...u,...this.weightIds]);return Object.keys(o).forEach(e=>{const t=o[e];t.forEach(e=>{!e||e.kept||e.isDisposed||d.has(e.id)||e.dispose()})}),null==this.parent&&s.dispose(d),i}async executeFunctionAsync(e,t,n){const r=e.reduce((e,t,n)=>(e[this.inputs[n].name]=t,e),{});return this._executeAsync(r,this.outputNodes,!0,t,n)}async executeWithControlFlow(e,t,n,r){const a=Object.keys(e),s=a.map(e=>this.graph.nodes[Object(l["g"])(e)[0]]),o=n.map(e=>Object(l["g"])(e)[0]);let i=o.map(e=>this.graph.nodes[e]);0===i.length&&(i=this._outputs);const{usedNodes:c,missingInputs:u,dynamicNode:d,syncInputs:p}=jn(e,i,this.weightMap,this._initNodes),h=[...s,...this.graph.weights,...this._initNodes||[]].map(e=>({node:e,contexts:t.currentContext})),f=Object.assign({},this.weightMap);Object.keys(e).forEach(t=>{const[n,r]=Object(l["g"])(t),a=[];a[r]=e[t],f[n]=a});const m={},b=this.getFrozenTensorIds(f),g={};while(h.length>0){const e=this.processStack(s,h,t,f,g,b,o,m,c);await Promise.all(e)}null!=d||r||console.warn("This model execution did not contain any nodes with control flow or dynamic output shapes. You can use model.execute() instead.");const y=i.filter(e=>!Tn(e)&&!Object(l["e"])(e.name,f,t)).map(e=>e.name);if(y.length>0){let e="";throw null!=d&&(e=`Alternatively, to avoid the dynamic ops, use model.execute() and specify the inputs [${p}]`),new Error(`Cannot compute the outputs [${y}] from the provided inputs [${a}]. Consider providing the following inputs: [${u}]. ${e}`)}return f}processStack(e,t,n,r,a,s,o,i,u){const d=[];while(t.length>0){const e=t.pop();n.currentContext=e.contexts;let p="";if("Enter"===e.node.op&&Object(l["d"])("isConstant",e.node,r,n)&&([p]=Object(l["b"])(e.node.name,n)),null==r[e.node.name]){const h=wn(e.node,r,n,this._resourceManager);p||([p]=Object(l["b"])(e.node.name,n));const f=n.currentContext;c["util"].isPromise(h)?d.push(h.then(c=>(r[p]=c,n.currentContext=f,this.checkTensorForDisposal(p,e.node,r,n,s,o,i),this.processChildNodes(e.node,t,n,r,a,u),c))):(r[p]=h,this.checkTensorForDisposal(p,e.node,r,n,s,o,i),this.processChildNodes(e.node,t,n,r,a,u))}else this.processChildNodes(e.node,t,n,r,a,u)}return d}processChildNodes(e,t,n,r,a,s){e.children.forEach(e=>{const[o]=Object(l["b"])(e.name,n);!a[o]&&s.has(e.name)&&("Merge"===e.op?e.inputNames.some(e=>!!Object(l["e"])(e,r,n))&&(a[o]=!0,t.push({contexts:n.currentContext,node:e})):e.inputNames.every(e=>!!Object(l["e"])(e,r,n))&&(a[o]=!0,t.push({contexts:n.currentContext,node:e})))})}dispose(){Object.keys(this.weightMap).forEach(e=>this.weightMap[e].forEach(e=>e.dispose()))}checkInputShapeAndType(e){Object.keys(e).forEach(t=>{const n=e[t],[r]=Object(l["g"])(t),a=this.graph.nodes[r];if(a.attrParams["shape"]&&a.attrParams["shape"].value){const e=a.attrParams["shape"].value,t=e.length===n.shape.length&&n.shape.every((t,n)=>-1===e[n]||e[n]===t);c["util"].assert(t,()=>`The shape of dict['${a.name}'] provided in model.execute(dict) must be [${e}], but was [${n.shape}]`)}a.attrParams["dtype"]&&a.attrParams["dtype"].value&&c["util"].assert(n.dtype===a.attrParams["dtype"].value,()=>`The dtype of dict['${a.name}'] provided in model.execute(dict) must be ${a.attrParams["dtype"].value}, but was ${n.dtype}`)})}mapInputs(e){const t={};for(const n in e)if(null!=this._signature&&null!=this._signature.inputs&&null!=this._signature.inputs[n]){const r=this._signature.inputs[n];t[r.name]=e[n]}else t[n]=e[n];return t}checkInputs(e){const t=Object.keys(e).filter(e=>{const[t]=Object(l["g"])(e);return null==this.graph.nodes[t]});if(t.length>0)throw new Error(`The dict provided in model.execute(dict) has keys: [${t}] that are not part of graph`)}mapOutputs(e){return e.map(e=>{if(null!=this._signature&&null!=this._signature.outputs&&null!=this._signature.outputs[e]){const t=this._signature.outputs[e];return t.name}return e},{})}checkOutputs(e){e.forEach(e=>{const[t]=Object(l["g"])(e);if(!this.graph.nodes[t])throw new Error(`The output '${e}' is not found in the graph`)})}}class Rn{constructor(e={},t={}){this.hashTableNameToHandle=e,this.hashTableMap=t}addHashTable(e,t){this.hashTableNameToHandle[e]=t.handle,this.hashTableMap[t.id]=t}getHashTableHandleByName(e){return this.hashTableNameToHandle[e]}getHashTableById(e){return this.hashTableMap[e]}dispose(){for(const e in this.hashTableMap)this.hashTableMap[e].clearAndClose(),delete this.hashTableMap[e];for(const e in this.hashTableNameToHandle)this.hashTableNameToHandle[e].dispose(),delete this.hashTableNameToHandle[e]}}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _n="?tfjs-format=file",Fn="model.json";class Dn{constructor(e,t={}){this.modelUrl=e,this.loadOptions=t,this.version="n/a",null==t&&(this.loadOptions={}),this.resourceManager=new Rn}get modelVersion(){return this.version}get inputNodes(){return this.executor.inputNodes}get outputNodes(){return this.executor.outputNodes}get inputs(){return this.executor.inputs}get outputs(){return this.executor.outputs}get weights(){return this.executor.weightMap}get metadata(){return this.artifacts.userDefinedMetadata}get modelSignature(){return this.signature}findIOHandler(){const e=this.modelUrl;if(null!=e.load)this.handler=e;else if(null!=this.loadOptions.requestInit)this.handler=c["io"].browserHTTPRequest(e,this.loadOptions);else{const t=c["io"].getLoadHandlers(e,this.loadOptions);if(0===t.length)t.push(c["io"].browserHTTPRequest(e,this.loadOptions));else if(t.length>1)throw new Error(`Found more than one (${t.length}) load handlers for URL '${[e]}'`);this.handler=t[0]}}async load(){if(this.findIOHandler(),null==this.handler.load)throw new Error("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");const e=await this.handler.load();return this.loadSync(e)}loadSync(e){this.artifacts=e;const t=this.artifacts.modelTopology;let n;n=null!=this.artifacts.userDefinedMetadata&&null!=this.artifacts.userDefinedMetadata.signature?this.artifacts.userDefinedMetadata.signature:this.artifacts.signature,this.signature=n,this.version=`${t.versions.producer}.${t.versions.minConsumer}`;const r=c["io"].decodeWeights(this.artifacts.weightData,this.artifacts.weightSpecs);if(this.executor=new An(u["a"].Instance.transformGraph(t,this.signature)),this.executor.weightMap=this.convertTensorMapToTensorsMap(r),this.executor.resourceManager=this.resourceManager,null!=e.modelInitializer&&null!=e.modelInitializer.node){const t=u["a"].Instance.transformGraph(e.modelInitializer);this.initializer=new An(t),this.initializer.weightMap=this.executor.weightMap,this.initializer.resourceManager=this.resourceManager,this.initializer.executeAsync({},[])}return!0}async save(e,t){if("string"===typeof e){const t=c["io"].getSaveHandlers(e);if(0===t.length)throw new Error(`Cannot find any save handlers for URL '${e}'`);if(t.length>1)throw new Error(`Found more than one (${t.length}) save handlers for URL '${e}'`);e=t[0]}if(null==e.save)throw new Error("GraphModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");return e.save(this.artifacts)}predict(e,t){return this.execute(e,this.outputNodes)}normalizeInputs(e){if(!(e instanceof c["Tensor"])&&!Array.isArray(e))return e;if(e=Array.isArray(e)?e:[e],e.length!==this.inputNodes.length)throw new Error(`Input tensor count mismatch,the graph model has ${this.inputNodes.length} placeholders, while there are ${e.length} input tensors.`);return this.inputNodes.reduce((t,n,r)=>(t[n]=e[r],t),{})}normalizeOutputs(e){return e=e||this.outputNodes,Array.isArray(e)?e:[e]}execute(e,t){e=this.normalizeInputs(e),t=this.normalizeOutputs(t);const n=this.executor.execute(e,t);return n.length>1?n:n[0]}async executeAsync(e,t){e=this.normalizeInputs(e),t=this.normalizeOutputs(t);const n=await this.executor.executeAsync(e,t);return n.length>1?n:n[0]}convertTensorMapToTensorsMap(e){return Object.keys(e).reduce((t,n)=>(t[n]=[e[n]],t),{})}dispose(){this.executor.dispose(),this.initializer&&this.initializer.dispose(),this.resourceManager.dispose()}}async function Mn(e,t={}){if(null==e)throw new Error("modelUrl in loadGraphModel() cannot be null. Please provide a url or an IOHandler that loads the model");null==t&&(t={}),t.fromTFHub&&null==e.load&&(e.endsWith("/")||(e+="/"),e=`${e}${Fn}${_n}`);const n=new Dn(e,t);return await n.load(),n}
/** @license See the LICENSE file. */
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
    * @license
    * Copyright 2021 Google LLC. All Rights Reserved.
    * Licensed under the Apache License, Version 2.0 (the "License");
    * you may not use this file except in compliance with the License.
    * You may obtain a copy of the License at
    *
    * http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing, software
    * distributed under the License is distributed on an "AS IS" BASIS,
    * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    * See the License for the specific language governing permissions and
    * limitations under the License.
    * =============================================================================
    */
function Ln(e,t,n,r){return new(n||(n=Promise))((function(a,s){function o(e){try{c(r.next(e))}catch(e){s(e)}}function i(e){try{c(r.throw(e))}catch(e){s(e)}}function c(e){e.done?a(e.value):new n((function(t){t(e.value)})).then(o,i)}c((r=r.apply(e,t||[])).next())}))}function Pn(e,t){var n,r,a,s,o={label:0,sent:function(){if(1&a[0])throw a[1];return a[1]},trys:[],ops:[]};return s={next:i(0),throw:i(1),return:i(2)},"function"==typeof Symbol&&(s[Symbol.iterator]=function(){return this}),s;function i(s){return function(i){return function(s){if(n)throw new TypeError("Generator is already executing.");for(;o;)try{if(n=1,r&&(a=2&s[0]?r.return:s[0]?r.throw||((a=r.return)&&a.call(r),0):r.next)&&!(a=a.call(r,s[1])).done)return a;switch(r=0,a&&(s=[2&s[0],a.value]),s[0]){case 0:case 1:a=s;break;case 4:return o.label++,{value:s[1],done:!1};case 5:o.label++,r=s[1],s=[0];continue;case 7:s=o.ops.pop(),o.trys.pop();continue;default:if(!(a=(a=o.trys).length>0&&a[a.length-1])&&(6===s[0]||2===s[0])){o=0;continue}if(3===s[0]&&(!a||s[1]>a[0]&&s[1]<a[3])){o.label=s[1];break}if(6===s[0]&&o.label<a[1]){o.label=a[1],a=s;break}if(a&&o.label<a[2]){o.label=a[2],o.ops.push(s);break}a[2]&&o.ops.pop(),o.trys.pop();continue}s=t.call(e,o)}catch(e){s=[6,e],r=0}finally{n=a=0}if(5&s[0])throw s[1];return{value:s[0]?s[1]:void 0,done:!0}}([s,i])}}}var Bn={0:"tench, Tinca tinca",1:"goldfish, Carassius auratus",2:"great white shark, white shark, man-eater, man-eating shark, Carcharodon carcharias",3:"tiger shark, Galeocerdo cuvieri",4:"hammerhead, hammerhead shark",5:"electric ray, crampfish, numbfish, torpedo",6:"stingray",7:"cock",8:"hen",9:"ostrich, Struthio camelus",10:"brambling, Fringilla montifringilla",11:"goldfinch, Carduelis carduelis",12:"house finch, linnet, Carpodacus mexicanus",13:"junco, snowbird",14:"indigo bunting, indigo finch, indigo bird, Passerina cyanea",15:"robin, American robin, Turdus migratorius",16:"bulbul",17:"jay",18:"magpie",19:"chickadee",20:"water ouzel, dipper",21:"kite",22:"bald eagle, American eagle, Haliaeetus leucocephalus",23:"vulture",24:"great grey owl, great gray owl, Strix nebulosa",25:"European fire salamander, Salamandra salamandra",26:"common newt, Triturus vulgaris",27:"eft",28:"spotted salamander, Ambystoma maculatum",29:"axolotl, mud puppy, Ambystoma mexicanum",30:"bullfrog, Rana catesbeiana",31:"tree frog, tree-frog",32:"tailed frog, bell toad, ribbed toad, tailed toad, Ascaphus trui",33:"loggerhead, loggerhead turtle, Caretta caretta",34:"leatherback turtle, leatherback, leathery turtle, Dermochelys coriacea",35:"mud turtle",36:"terrapin",37:"box turtle, box tortoise",38:"banded gecko",39:"common iguana, iguana, Iguana iguana",40:"American chameleon, anole, Anolis carolinensis",41:"whiptail, whiptail lizard",42:"agama",43:"frilled lizard, Chlamydosaurus kingi",44:"alligator lizard",45:"Gila monster, Heloderma suspectum",46:"green lizard, Lacerta viridis",47:"African chameleon, Chamaeleo chamaeleon",48:"Komodo dragon, Komodo lizard, dragon lizard, giant lizard, Varanus komodoensis",49:"African crocodile, Nile crocodile, Crocodylus niloticus",50:"American alligator, Alligator mississipiensis",51:"triceratops",52:"thunder snake, worm snake, Carphophis amoenus",53:"ringneck snake, ring-necked snake, ring snake",54:"hognose snake, puff adder, sand viper",55:"green snake, grass snake",56:"king snake, kingsnake",57:"garter snake, grass snake",58:"water snake",59:"vine snake",60:"night snake, Hypsiglena torquata",61:"boa constrictor, Constrictor constrictor",62:"rock python, rock snake, Python sebae",63:"Indian cobra, Naja naja",64:"green mamba",65:"sea snake",66:"horned viper, cerastes, sand viper, horned asp, Cerastes cornutus",67:"diamondback, diamondback rattlesnake, Crotalus adamanteus",68:"sidewinder, horned rattlesnake, Crotalus cerastes",69:"trilobite",70:"harvestman, daddy longlegs, Phalangium opilio",71:"scorpion",72:"black and gold garden spider, Argiope aurantia",73:"barn spider, Araneus cavaticus",74:"garden spider, Aranea diademata",75:"black widow, Latrodectus mactans",76:"tarantula",77:"wolf spider, hunting spider",78:"tick",79:"centipede",80:"black grouse",81:"ptarmigan",82:"ruffed grouse, partridge, Bonasa umbellus",83:"prairie chicken, prairie grouse, prairie fowl",84:"peacock",85:"quail",86:"partridge",87:"African grey, African gray, Psittacus erithacus",88:"macaw",89:"sulphur-crested cockatoo, Kakatoe galerita, Cacatua galerita",90:"lorikeet",91:"coucal",92:"bee eater",93:"hornbill",94:"hummingbird",95:"jacamar",96:"toucan",97:"drake",98:"red-breasted merganser, Mergus serrator",99:"goose",100:"black swan, Cygnus atratus",101:"tusker",102:"echidna, spiny anteater, anteater",103:"platypus, duckbill, duckbilled platypus, duck-billed platypus, Ornithorhynchus anatinus",104:"wallaby, brush kangaroo",105:"koala, koala bear, kangaroo bear, native bear, Phascolarctos cinereus",106:"wombat",107:"jelly fish",108:"sea anemone, anemone",109:"brain coral",110:"flatworm, platyhelminth",111:"nematode, nematode worm, roundworm",112:"conch",113:"snail",114:"slug",115:"sea slug, nudibranch",116:"chiton, coat-of-mail shell, sea cradle, polyplacophore",117:"chambered nautilus, pearly nautilus, nautilus",118:"Dungeness crab, Cancer magister",119:"rock crab, Cancer irroratus",120:"fiddler crab",121:"king crab, Alaska crab, Alaskan king crab, Alaska king crab, Paralithodes camtschatica",122:"American lobster, Northern lobster, Maine lobster, Homarus americanus",123:"spiny lobster, langouste, rock lobster, crawfish, crayfish, sea crawfish",124:"crayfish, crawfish, crawdad, crawdaddy",125:"hermit crab",126:"isopod",127:"white stork, Ciconia ciconia",128:"black stork, Ciconia nigra",129:"spoonbill",130:"flamingo",131:"little blue heron, Egretta caerulea",132:"American egret, great white heron, Egretta albus",133:"bittern",134:"crane",135:"limpkin, Aramus pictus",136:"European gallinule, Porphyrio porphyrio",137:"American coot, marsh hen, mud hen, water hen, Fulica americana",138:"bustard",139:"ruddy turnstone, Arenaria interpres",140:"red-backed sandpiper, dunlin, Erolia alpina",141:"redshank, Tringa totanus",142:"dowitcher",143:"oystercatcher, oyster catcher",144:"pelican",145:"king penguin, Aptenodytes patagonica",146:"albatross, mollymawk",147:"grey whale, gray whale, devilfish, Eschrichtius gibbosus, Eschrichtius robustus",148:"killer whale, killer, orca, grampus, sea wolf, Orcinus orca",149:"dugong, Dugong dugon",150:"sea lion",151:"Chihuahua",152:"Japanese spaniel",153:"Maltese dog, Maltese terrier, Maltese",154:"Pekinese, Pekingese, Peke",155:"Shih-Tzu",156:"Blenheim spaniel",157:"papillon",158:"toy terrier",159:"Rhodesian ridgeback",160:"Afghan hound, Afghan",161:"basset, basset hound",162:"beagle",163:"bloodhound, sleuthhound",164:"bluetick",165:"black-and-tan coonhound",166:"Walker hound, Walker foxhound",167:"English foxhound",168:"redbone",169:"borzoi, Russian wolfhound",170:"Irish wolfhound",171:"Italian greyhound",172:"whippet",173:"Ibizan hound, Ibizan Podenco",174:"Norwegian elkhound, elkhound",175:"otterhound, otter hound",176:"Saluki, gazelle hound",177:"Scottish deerhound, deerhound",178:"Weimaraner",179:"Staffordshire bullterrier, Staffordshire bull terrier",180:"American Staffordshire terrier, Staffordshire terrier, American pit bull terrier, pit bull terrier",181:"Bedlington terrier",182:"Border terrier",183:"Kerry blue terrier",184:"Irish terrier",185:"Norfolk terrier",186:"Norwich terrier",187:"Yorkshire terrier",188:"wire-haired fox terrier",189:"Lakeland terrier",190:"Sealyham terrier, Sealyham",191:"Airedale, Airedale terrier",192:"cairn, cairn terrier",193:"Australian terrier",194:"Dandie Dinmont, Dandie Dinmont terrier",195:"Boston bull, Boston terrier",196:"miniature schnauzer",197:"giant schnauzer",198:"standard schnauzer",199:"Scotch terrier, Scottish terrier, Scottie",200:"Tibetan terrier, chrysanthemum dog",201:"silky terrier, Sydney silky",202:"soft-coated wheaten terrier",203:"West Highland white terrier",204:"Lhasa, Lhasa apso",205:"flat-coated retriever",206:"curly-coated retriever",207:"golden retriever",208:"Labrador retriever",209:"Chesapeake Bay retriever",210:"German short-haired pointer",211:"vizsla, Hungarian pointer",212:"English setter",213:"Irish setter, red setter",214:"Gordon setter",215:"Brittany spaniel",216:"clumber, clumber spaniel",217:"English springer, English springer spaniel",218:"Welsh springer spaniel",219:"cocker spaniel, English cocker spaniel, cocker",220:"Sussex spaniel",221:"Irish water spaniel",222:"kuvasz",223:"schipperke",224:"groenendael",225:"malinois",226:"briard",227:"kelpie",228:"komondor",229:"Old English sheepdog, bobtail",230:"Shetland sheepdog, Shetland sheep dog, Shetland",231:"collie",232:"Border collie",233:"Bouvier des Flandres, Bouviers des Flandres",234:"Rottweiler",235:"German shepherd, German shepherd dog, German police dog, alsatian",236:"Doberman, Doberman pinscher",237:"miniature pinscher",238:"Greater Swiss Mountain dog",239:"Bernese mountain dog",240:"Appenzeller",241:"EntleBucher",242:"boxer",243:"bull mastiff",244:"Tibetan mastiff",245:"French bulldog",246:"Great Dane",247:"Saint Bernard, St Bernard",248:"Eskimo dog, husky",249:"malamute, malemute, Alaskan malamute",250:"Siberian husky",251:"dalmatian, coach dog, carriage dog",252:"affenpinscher, monkey pinscher, monkey dog",253:"basenji",254:"pug, pug-dog",255:"Leonberg",256:"Newfoundland, Newfoundland dog",257:"Great Pyrenees",258:"Samoyed, Samoyede",259:"Pomeranian",260:"chow, chow chow",261:"keeshond",262:"Brabancon griffon",263:"Pembroke, Pembroke Welsh corgi",264:"Cardigan, Cardigan Welsh corgi",265:"toy poodle",266:"miniature poodle",267:"standard poodle",268:"Mexican hairless",269:"timber wolf, grey wolf, gray wolf, Canis lupus",270:"white wolf, Arctic wolf, Canis lupus tundrarum",271:"red wolf, maned wolf, Canis rufus, Canis niger",272:"coyote, prairie wolf, brush wolf, Canis latrans",273:"dingo, warrigal, warragal, Canis dingo",274:"dhole, Cuon alpinus",275:"African hunting dog, hyena dog, Cape hunting dog, Lycaon pictus",276:"hyena, hyaena",277:"red fox, Vulpes vulpes",278:"kit fox, Vulpes macrotis",279:"Arctic fox, white fox, Alopex lagopus",280:"grey fox, gray fox, Urocyon cinereoargenteus",281:"tabby, tabby cat",282:"tiger cat",283:"Persian cat",284:"Siamese cat, Siamese",285:"Egyptian cat",286:"cougar, puma, catamount, mountain lion, painter, panther, Felis concolor",287:"lynx, catamount",288:"leopard, Panthera pardus",289:"snow leopard, ounce, Panthera uncia",290:"jaguar, panther, Panthera onca, Felis onca",291:"lion, king of beasts, Panthera leo",292:"tiger, Panthera tigris",293:"cheetah, chetah, Acinonyx jubatus",294:"brown bear, bruin, Ursus arctos",295:"American black bear, black bear, Ursus americanus, Euarctos americanus",296:"ice bear, polar bear, Ursus Maritimus, Thalarctos maritimus",297:"sloth bear, Melursus ursinus, Ursus ursinus",298:"mongoose",299:"meerkat, mierkat",300:"tiger beetle",301:"ladybug, ladybeetle, lady beetle, ladybird, ladybird beetle",302:"ground beetle, carabid beetle",303:"long-horned beetle, longicorn, longicorn beetle",304:"leaf beetle, chrysomelid",305:"dung beetle",306:"rhinoceros beetle",307:"weevil",308:"fly",309:"bee",310:"ant, emmet, pismire",311:"grasshopper, hopper",312:"cricket",313:"walking stick, walkingstick, stick insect",314:"cockroach, roach",315:"mantis, mantid",316:"cicada, cicala",317:"leafhopper",318:"lacewing, lacewing fly",319:"dragonfly, darning needle, devil's darning needle, sewing needle, snake feeder, snake doctor, mosquito hawk, skeeter hawk",320:"damselfly",321:"admiral",322:"ringlet, ringlet butterfly",323:"monarch, monarch butterfly, milkweed butterfly, Danaus plexippus",324:"cabbage butterfly",325:"sulphur butterfly, sulfur butterfly",326:"lycaenid, lycaenid butterfly",327:"starfish, sea star",328:"sea urchin",329:"sea cucumber, holothurian",330:"wood rabbit, cottontail, cottontail rabbit",331:"hare",332:"Angora, Angora rabbit",333:"hamster",334:"porcupine, hedgehog",335:"fox squirrel, eastern fox squirrel, Sciurus niger",336:"marmot",337:"beaver",338:"guinea pig, Cavia cobaya",339:"sorrel",340:"zebra",341:"hog, pig, grunter, squealer, Sus scrofa",342:"wild boar, boar, Sus scrofa",343:"warthog",344:"hippopotamus, hippo, river horse, Hippopotamus amphibius",345:"ox",346:"water buffalo, water ox, Asiatic buffalo, Bubalus bubalis",347:"bison",348:"ram, tup",349:"bighorn, bighorn sheep, cimarron, Rocky Mountain bighorn, Rocky Mountain sheep, Ovis canadensis",350:"ibex, Capra ibex",351:"hartebeest",352:"impala, Aepyceros melampus",353:"gazelle",354:"Arabian camel, dromedary, Camelus dromedarius",355:"llama",356:"weasel",357:"mink",358:"polecat, fitch, foulmart, foumart, Mustela putorius",359:"black-footed ferret, ferret, Mustela nigripes",360:"otter",361:"skunk, polecat, wood pussy",362:"badger",363:"armadillo",364:"three-toed sloth, ai, Bradypus tridactylus",365:"orangutan, orang, orangutang, Pongo pygmaeus",366:"gorilla, Gorilla gorilla",367:"chimpanzee, chimp, Pan troglodytes",368:"gibbon, Hylobates lar",369:"siamang, Hylobates syndactylus, Symphalangus syndactylus",370:"guenon, guenon monkey",371:"patas, hussar monkey, Erythrocebus patas",372:"baboon",373:"macaque",374:"langur",375:"colobus, colobus monkey",376:"proboscis monkey, Nasalis larvatus",377:"marmoset",378:"capuchin, ringtail, Cebus capucinus",379:"howler monkey, howler",380:"titi, titi monkey",381:"spider monkey, Ateles geoffroyi",382:"squirrel monkey, Saimiri sciureus",383:"Madagascar cat, ring-tailed lemur, Lemur catta",384:"indri, indris, Indri indri, Indri brevicaudatus",385:"Indian elephant, Elephas maximus",386:"African elephant, Loxodonta africana",387:"lesser panda, red panda, panda, bear cat, cat bear, Ailurus fulgens",388:"giant panda, panda, panda bear, coon bear, Ailuropoda melanoleuca",389:"barracouta, snoek",390:"eel",391:"coho, cohoe, coho salmon, blue jack, silver salmon, Oncorhynchus kisutch",392:"rock beauty, Holocanthus tricolor",393:"anemone fish",394:"sturgeon",395:"gar, garfish, garpike, billfish, Lepisosteus osseus",396:"lionfish",397:"puffer, pufferfish, blowfish, globefish",398:"abacus",399:"abaya",400:"academic gown, academic robe, judge's robe",401:"accordion, piano accordion, squeeze box",402:"acoustic guitar",403:"aircraft carrier, carrier, flattop, attack aircraft carrier",404:"airliner",405:"airship, dirigible",406:"altar",407:"ambulance",408:"amphibian, amphibious vehicle",409:"analog clock",410:"apiary, bee house",411:"apron",412:"ashcan, trash can, garbage can, wastebin, ash bin, ash-bin, ashbin, dustbin, trash barrel, trash bin",413:"assault rifle, assault gun",414:"backpack, back pack, knapsack, packsack, rucksack, haversack",415:"bakery, bakeshop, bakehouse",416:"balance beam, beam",417:"balloon",418:"ballpoint, ballpoint pen, ballpen, Biro",419:"Band Aid",420:"banjo",421:"bannister, banister, balustrade, balusters, handrail",422:"barbell",423:"barber chair",424:"barbershop",425:"barn",426:"barometer",427:"barrel, cask",428:"barrow, garden cart, lawn cart, wheelbarrow",429:"baseball",430:"basketball",431:"bassinet",432:"bassoon",433:"bathing cap, swimming cap",434:"bath towel",435:"bathtub, bathing tub, bath, tub",436:"beach wagon, station wagon, wagon, estate car, beach waggon, station waggon, waggon",437:"beacon, lighthouse, beacon light, pharos",438:"beaker",439:"bearskin, busby, shako",440:"beer bottle",441:"beer glass",442:"bell cote, bell cot",443:"bib",444:"bicycle-built-for-two, tandem bicycle, tandem",445:"bikini, two-piece",446:"binder, ring-binder",447:"binoculars, field glasses, opera glasses",448:"birdhouse",449:"boathouse",450:"bobsled, bobsleigh, bob",451:"bolo tie, bolo, bola tie, bola",452:"bonnet, poke bonnet",453:"bookcase",454:"bookshop, bookstore, bookstall",455:"bottlecap",456:"bow",457:"bow tie, bow-tie, bowtie",458:"brass, memorial tablet, plaque",459:"brassiere, bra, bandeau",460:"breakwater, groin, groyne, mole, bulwark, seawall, jetty",461:"breastplate, aegis, egis",462:"broom",463:"bucket, pail",464:"buckle",465:"bulletproof vest",466:"bullet train, bullet",467:"butcher shop, meat market",468:"cab, hack, taxi, taxicab",469:"caldron, cauldron",470:"candle, taper, wax light",471:"cannon",472:"canoe",473:"can opener, tin opener",474:"cardigan",475:"car mirror",476:"carousel, carrousel, merry-go-round, roundabout, whirligig",477:"carpenter's kit, tool kit",478:"carton",479:"car wheel",480:"cash machine, cash dispenser, automated teller machine, automatic teller machine, automated teller, automatic teller, ATM",481:"cassette",482:"cassette player",483:"castle",484:"catamaran",485:"CD player",486:"cello, violoncello",487:"cellular telephone, cellular phone, cellphone, cell, mobile phone",488:"chain",489:"chainlink fence",490:"chain mail, ring mail, mail, chain armor, chain armour, ring armor, ring armour",491:"chain saw, chainsaw",492:"chest",493:"chiffonier, commode",494:"chime, bell, gong",495:"china cabinet, china closet",496:"Christmas stocking",497:"church, church building",498:"cinema, movie theater, movie theatre, movie house, picture palace",499:"cleaver, meat cleaver, chopper",500:"cliff dwelling",501:"cloak",502:"clog, geta, patten, sabot",503:"cocktail shaker",504:"coffee mug",505:"coffeepot",506:"coil, spiral, volute, whorl, helix",507:"combination lock",508:"computer keyboard, keypad",509:"confectionery, confectionary, candy store",510:"container ship, containership, container vessel",511:"convertible",512:"corkscrew, bottle screw",513:"cornet, horn, trumpet, trump",514:"cowboy boot",515:"cowboy hat, ten-gallon hat",516:"cradle",517:"crane",518:"crash helmet",519:"crate",520:"crib, cot",521:"Crock Pot",522:"croquet ball",523:"crutch",524:"cuirass",525:"dam, dike, dyke",526:"desk",527:"desktop computer",528:"dial telephone, dial phone",529:"diaper, nappy, napkin",530:"digital clock",531:"digital watch",532:"dining table, board",533:"dishrag, dishcloth",534:"dishwasher, dish washer, dishwashing machine",535:"disk brake, disc brake",536:"dock, dockage, docking facility",537:"dogsled, dog sled, dog sleigh",538:"dome",539:"doormat, welcome mat",540:"drilling platform, offshore rig",541:"drum, membranophone, tympan",542:"drumstick",543:"dumbbell",544:"Dutch oven",545:"electric fan, blower",546:"electric guitar",547:"electric locomotive",548:"entertainment center",549:"envelope",550:"espresso maker",551:"face powder",552:"feather boa, boa",553:"file, file cabinet, filing cabinet",554:"fireboat",555:"fire engine, fire truck",556:"fire screen, fireguard",557:"flagpole, flagstaff",558:"flute, transverse flute",559:"folding chair",560:"football helmet",561:"forklift",562:"fountain",563:"fountain pen",564:"four-poster",565:"freight car",566:"French horn, horn",567:"frying pan, frypan, skillet",568:"fur coat",569:"garbage truck, dustcart",570:"gasmask, respirator, gas helmet",571:"gas pump, gasoline pump, petrol pump, island dispenser",572:"goblet",573:"go-kart",574:"golf ball",575:"golfcart, golf cart",576:"gondola",577:"gong, tam-tam",578:"gown",579:"grand piano, grand",580:"greenhouse, nursery, glasshouse",581:"grille, radiator grille",582:"grocery store, grocery, food market, market",583:"guillotine",584:"hair slide",585:"hair spray",586:"half track",587:"hammer",588:"hamper",589:"hand blower, blow dryer, blow drier, hair dryer, hair drier",590:"hand-held computer, hand-held microcomputer",591:"handkerchief, hankie, hanky, hankey",592:"hard disc, hard disk, fixed disk",593:"harmonica, mouth organ, harp, mouth harp",594:"harp",595:"harvester, reaper",596:"hatchet",597:"holster",598:"home theater, home theatre",599:"honeycomb",600:"hook, claw",601:"hoopskirt, crinoline",602:"horizontal bar, high bar",603:"horse cart, horse-cart",604:"hourglass",605:"iPod",606:"iron, smoothing iron",607:"jack-o'-lantern",608:"jean, blue jean, denim",609:"jeep, landrover",610:"jersey, T-shirt, tee shirt",611:"jigsaw puzzle",612:"jinrikisha, ricksha, rickshaw",613:"joystick",614:"kimono",615:"knee pad",616:"knot",617:"lab coat, laboratory coat",618:"ladle",619:"lampshade, lamp shade",620:"laptop, laptop computer",621:"lawn mower, mower",622:"lens cap, lens cover",623:"letter opener, paper knife, paperknife",624:"library",625:"lifeboat",626:"lighter, light, igniter, ignitor",627:"limousine, limo",628:"liner, ocean liner",629:"lipstick, lip rouge",630:"Loafer",631:"lotion",632:"loudspeaker, speaker, speaker unit, loudspeaker system, speaker system",633:"loupe, jeweler's loupe",634:"lumbermill, sawmill",635:"magnetic compass",636:"mailbag, postbag",637:"mailbox, letter box",638:"maillot",639:"maillot, tank suit",640:"manhole cover",641:"maraca",642:"marimba, xylophone",643:"mask",644:"matchstick",645:"maypole",646:"maze, labyrinth",647:"measuring cup",648:"medicine chest, medicine cabinet",649:"megalith, megalithic structure",650:"microphone, mike",651:"microwave, microwave oven",652:"military uniform",653:"milk can",654:"minibus",655:"miniskirt, mini",656:"minivan",657:"missile",658:"mitten",659:"mixing bowl",660:"mobile home, manufactured home",661:"Model T",662:"modem",663:"monastery",664:"monitor",665:"moped",666:"mortar",667:"mortarboard",668:"mosque",669:"mosquito net",670:"motor scooter, scooter",671:"mountain bike, all-terrain bike, off-roader",672:"mountain tent",673:"mouse, computer mouse",674:"mousetrap",675:"moving van",676:"muzzle",677:"nail",678:"neck brace",679:"necklace",680:"nipple",681:"notebook, notebook computer",682:"obelisk",683:"oboe, hautboy, hautbois",684:"ocarina, sweet potato",685:"odometer, hodometer, mileometer, milometer",686:"oil filter",687:"organ, pipe organ",688:"oscilloscope, scope, cathode-ray oscilloscope, CRO",689:"overskirt",690:"oxcart",691:"oxygen mask",692:"packet",693:"paddle, boat paddle",694:"paddlewheel, paddle wheel",695:"padlock",696:"paintbrush",697:"pajama, pyjama, pj's, jammies",698:"palace",699:"panpipe, pandean pipe, syrinx",700:"paper towel",701:"parachute, chute",702:"parallel bars, bars",703:"park bench",704:"parking meter",705:"passenger car, coach, carriage",706:"patio, terrace",707:"pay-phone, pay-station",708:"pedestal, plinth, footstall",709:"pencil box, pencil case",710:"pencil sharpener",711:"perfume, essence",712:"Petri dish",713:"photocopier",714:"pick, plectrum, plectron",715:"pickelhaube",716:"picket fence, paling",717:"pickup, pickup truck",718:"pier",719:"piggy bank, penny bank",720:"pill bottle",721:"pillow",722:"ping-pong ball",723:"pinwheel",724:"pirate, pirate ship",725:"pitcher, ewer",726:"plane, carpenter's plane, woodworking plane",727:"planetarium",728:"plastic bag",729:"plate rack",730:"plow, plough",731:"plunger, plumber's helper",732:"Polaroid camera, Polaroid Land camera",733:"pole",734:"police van, police wagon, paddy wagon, patrol wagon, wagon, black Maria",735:"poncho",736:"pool table, billiard table, snooker table",737:"pop bottle, soda bottle",738:"pot, flowerpot",739:"potter's wheel",740:"power drill",741:"prayer rug, prayer mat",742:"printer",743:"prison, prison house",744:"projectile, missile",745:"projector",746:"puck, hockey puck",747:"punching bag, punch bag, punching ball, punchball",748:"purse",749:"quill, quill pen",750:"quilt, comforter, comfort, puff",751:"racer, race car, racing car",752:"racket, racquet",753:"radiator",754:"radio, wireless",755:"radio telescope, radio reflector",756:"rain barrel",757:"recreational vehicle, RV, R.V.",758:"reel",759:"reflex camera",760:"refrigerator, icebox",761:"remote control, remote",762:"restaurant, eating house, eating place, eatery",763:"revolver, six-gun, six-shooter",764:"rifle",765:"rocking chair, rocker",766:"rotisserie",767:"rubber eraser, rubber, pencil eraser",768:"rugby ball",769:"rule, ruler",770:"running shoe",771:"safe",772:"safety pin",773:"saltshaker, salt shaker",774:"sandal",775:"sarong",776:"sax, saxophone",777:"scabbard",778:"scale, weighing machine",779:"school bus",780:"schooner",781:"scoreboard",782:"screen, CRT screen",783:"screw",784:"screwdriver",785:"seat belt, seatbelt",786:"sewing machine",787:"shield, buckler",788:"shoe shop, shoe-shop, shoe store",789:"shoji",790:"shopping basket",791:"shopping cart",792:"shovel",793:"shower cap",794:"shower curtain",795:"ski",796:"ski mask",797:"sleeping bag",798:"slide rule, slipstick",799:"sliding door",800:"slot, one-armed bandit",801:"snorkel",802:"snowmobile",803:"snowplow, snowplough",804:"soap dispenser",805:"soccer ball",806:"sock",807:"solar dish, solar collector, solar furnace",808:"sombrero",809:"soup bowl",810:"space bar",811:"space heater",812:"space shuttle",813:"spatula",814:"speedboat",815:"spider web, spider's web",816:"spindle",817:"sports car, sport car",818:"spotlight, spot",819:"stage",820:"steam locomotive",821:"steel arch bridge",822:"steel drum",823:"stethoscope",824:"stole",825:"stone wall",826:"stopwatch, stop watch",827:"stove",828:"strainer",829:"streetcar, tram, tramcar, trolley, trolley car",830:"stretcher",831:"studio couch, day bed",832:"stupa, tope",833:"submarine, pigboat, sub, U-boat",834:"suit, suit of clothes",835:"sundial",836:"sunglass",837:"sunglasses, dark glasses, shades",838:"sunscreen, sunblock, sun blocker",839:"suspension bridge",840:"swab, swob, mop",841:"sweatshirt",842:"swimming trunks, bathing trunks",843:"swing",844:"switch, electric switch, electrical switch",845:"syringe",846:"table lamp",847:"tank, army tank, armored combat vehicle, armoured combat vehicle",848:"tape player",849:"teapot",850:"teddy, teddy bear",851:"television, television system",852:"tennis ball",853:"thatch, thatched roof",854:"theater curtain, theatre curtain",855:"thimble",856:"thresher, thrasher, threshing machine",857:"throne",858:"tile roof",859:"toaster",860:"tobacco shop, tobacconist shop, tobacconist",861:"toilet seat",862:"torch",863:"totem pole",864:"tow truck, tow car, wrecker",865:"toyshop",866:"tractor",867:"trailer truck, tractor trailer, trucking rig, rig, articulated lorry, semi",868:"tray",869:"trench coat",870:"tricycle, trike, velocipede",871:"trimaran",872:"tripod",873:"triumphal arch",874:"trolleybus, trolley coach, trackless trolley",875:"trombone",876:"tub, vat",877:"turnstile",878:"typewriter keyboard",879:"umbrella",880:"unicycle, monocycle",881:"upright, upright piano",882:"vacuum, vacuum cleaner",883:"vase",884:"vault",885:"velvet",886:"vending machine",887:"vestment",888:"viaduct",889:"violin, fiddle",890:"volleyball",891:"waffle iron",892:"wall clock",893:"wallet, billfold, notecase, pocketbook",894:"wardrobe, closet, press",895:"warplane, military plane",896:"washbasin, handbasin, washbowl, lavabo, wash-hand basin",897:"washer, automatic washer, washing machine",898:"water bottle",899:"water jug",900:"water tower",901:"whiskey jug",902:"whistle",903:"wig",904:"window screen",905:"window shade",906:"Windsor tie",907:"wine bottle",908:"wing",909:"wok",910:"wooden spoon",911:"wool, woolen, woollen",912:"worm fence, snake fence, snake-rail fence, Virginia fence",913:"wreck",914:"yawl",915:"yurt",916:"web site, website, internet site, site",917:"comic book",918:"crossword puzzle, crossword",919:"street sign",920:"traffic light, traffic signal, stoplight",921:"book jacket, dust cover, dust jacket, dust wrapper",922:"menu",923:"plate",924:"guacamole",925:"consomme",926:"hot pot, hotpot",927:"trifle",928:"ice cream, icecream",929:"ice lolly, lolly, lollipop, popsicle",930:"French loaf",931:"bagel, beigel",932:"pretzel",933:"cheeseburger",934:"hotdog, hot dog, red hot",935:"mashed potato",936:"head cabbage",937:"broccoli",938:"cauliflower",939:"zucchini, courgette",940:"spaghetti squash",941:"acorn squash",942:"butternut squash",943:"cucumber, cuke",944:"artichoke, globe artichoke",945:"bell pepper",946:"cardoon",947:"mushroom",948:"Granny Smith",949:"strawberry",950:"orange",951:"lemon",952:"fig",953:"pineapple, ananas",954:"banana",955:"jackfruit, jak, jack",956:"custard apple",957:"pomegranate",958:"hay",959:"carbonara",960:"chocolate sauce, chocolate syrup",961:"dough",962:"meat loaf, meatloaf",963:"pizza, pizza pie",964:"potpie",965:"burrito",966:"red wine",967:"espresso",968:"cup",969:"eggnog",970:"alp",971:"bubble",972:"cliff, drop, drop-off",973:"coral reef",974:"geyser",975:"lakeside, lakeshore",976:"promontory, headland, head, foreland",977:"sandbar, sand bar",978:"seashore, coast, seacoast, sea-coast",979:"valley, vale",980:"volcano",981:"ballplayer, baseball player",982:"groom, bridegroom",983:"scuba diver",984:"rapeseed",985:"daisy",986:"yellow lady's slipper, yellow lady-slipper, Cypripedium calceolus, Cypripedium parviflorum",987:"corn",988:"acorn",989:"hip, rose hip, rosehip",990:"buckeye, horse chestnut, conker",991:"coral fungus",992:"agaric",993:"gyromitra",994:"stinkhorn, carrion fungus",995:"earthstar",996:"hen-of-the-woods, hen of the woods, Polyporus frondosus, Grifola frondosa",997:"bolete",998:"ear, spike, capitulum",999:"toilet tissue, toilet paper, bathroom tissue"},Vn="2.1.0",zn=224,Wn={"1.00":"module_apply_default/MobilenetV1/Logits/global_pool","2.00":"module_apply_default/MobilenetV2/Logits/AvgPool"},Un={"1.00":{.25:{url:"https://tfhub.dev/google/imagenet/mobilenet_v1_025_224/classification/1",inputRange:[0,1]},"0.50":{url:"https://tfhub.dev/google/imagenet/mobilenet_v1_050_224/classification/1",inputRange:[0,1]},.75:{url:"https://tfhub.dev/google/imagenet/mobilenet_v1_075_224/classification/1",inputRange:[0,1]},"1.00":{url:"https://tfhub.dev/google/imagenet/mobilenet_v1_100_224/classification/1",inputRange:[0,1]}},"2.00":{"0.50":{url:"https://tfhub.dev/google/imagenet/mobilenet_v2_050_224/classification/2",inputRange:[0,1]},.75:{url:"https://tfhub.dev/google/imagenet/mobilenet_v2_075_224/classification/2",inputRange:[0,1]},"1.00":{url:"https://tfhub.dev/google/imagenet/mobilenet_v2_100_224/classification/2",inputRange:[0,1]}}};function Gn(e){return void 0===e&&(e={version:1,alpha:1}),Ln(this,void 0,void 0,(function(){var t,n,r,a,s,o,i;return Pn(this,(function(u){switch(u.label){case 0:if(null==c)throw new Error("Cannot find TensorFlow.js. If you are using a <script> tag, please also include @tensorflow/tfjs on the page before using this model.");if(r=e.version.toFixed(2),a=e.alpha?e.alpha.toFixed(2):"",s=-1,o=1,null==e.modelUrl){if(!(r in Un))throw new Error("Invalid version of MobileNet. Valid versions are: "+Object.keys(Un));if(!(a in Un[r]))throw new Error("MobileNet constructed with invalid alpha "+e.alpha+". Valid multipliers for this version are: "+Object.keys(Un[r])+".");t=Un[r][a].inputRange,s=t[0],o=t[1]}return null!=e.inputRange&&(n=e.inputRange,s=n[0],o=n[1]),[4,(i=new Hn(r,a,e.modelUrl,s,o)).load()];case 1:return u.sent(),[2,i]}}))}))}var Hn=function(){function e(e,t,n,r,a){void 0===r&&(r=-1),void 0===a&&(a=1),this.version=e,this.alpha=t,this.modelUrl=n,this.inputMin=r,this.inputMax=a,this.normalizationConstant=(a-r)/255}return e.prototype.load=function(){return Ln(this,void 0,void 0,(function(){var e,t,n,r,a=this;return Pn(this,(function(s){switch(s.label){case 0:return this.modelUrl?(e=this,[4,Mn(this.modelUrl)]):[3,2];case 1:return e.model=s.sent(),[3,4];case 2:return t=Un[this.version][this.alpha].url,n=this,[4,Mn(t,{fromTFHub:!0})];case 3:n.model=s.sent(),s.label=4;case 4:return[4,(r=Object(c["tidy"])((function(){return a.model.predict(Object(c["zeros"])([1,zn,zn,3]))}))).data()];case 5:return s.sent(),r.dispose(),[2]}}))}))},e.prototype.infer=function(e,t){var n=this;return void 0===t&&(t=!1),Object(c["tidy"])((function(){e instanceof c["Tensor"]||(e=c["browser"].fromPixels(e));var r=Object(c["add"])(Object(c["mul"])(Object(c["cast"])(e,"float32"),n.normalizationConstant),n.inputMin),a=r;e.shape[0]===zn&&e.shape[1]===zn||(a=c["image"].resizeBilinear(r,[zn,zn],!0));var s,o=Object(c["reshape"])(a,[-1,zn,zn,3]);if(t){var i=Wn[n.version],u=n.model.execute(o,i);s=Object(c["squeeze"])(u,[1,2])}else{var l=n.model.predict(o);s=Object(c["slice"])(l,[0,1],[-1,1e3])}return s}))},e.prototype.classify=function(e,t){return void 0===t&&(t=3),Ln(this,void 0,void 0,(function(){var n,r;return Pn(this,(function(a){switch(a.label){case 0:return[4,qn(n=this.infer(e),t)];case 1:return r=a.sent(),n.dispose(),[2,r]}}))}))},e}();function qn(e,t){return Ln(this,void 0,void 0,(function(){var n,r,a,s,o,i,u;return Pn(this,(function(l){switch(l.label){case 0:return[4,(n=Object(c["softmax"])(e)).data()];case 1:for(r=l.sent(),n.dispose(),a=[],u=0;u<r.length;u++)a.push({value:r[u],index:u});for(a.sort((function(e,t){return t.value-e.value})),s=new Float32Array(t),o=new Int32Array(t),u=0;u<t;u++)s[u]=a[u].value,o[u]=a[u].index;for(i=[],u=0;u<o.length;u++)i.push({className:Bn[o[u]],probability:s[u]});return[2,i]}}))}))}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Kn={},Xn={alpha:!1,antialias:!1,premultipliedAlpha:!1,preserveDrawingBuffer:!1,depth:!1,stencil:!1,failIfMajorPerformanceCaveat:!0};function Yn(e,t){Kn[e]=t}function Qn(e){if(!(e in Kn)){const t=Jn(e);if(null===t)return console.log("Could not get context for WebGL version",e),null;Kn[e]=t}const t=Kn[e];return t.isContextLost()?(delete Kn[e],Qn(e)):(t.disable(t.DEPTH_TEST),t.disable(t.STENCIL_TEST),t.disable(t.BLEND),t.disable(t.DITHER),t.disable(t.POLYGON_OFFSET_FILL),t.disable(t.SAMPLE_COVERAGE),t.enable(t.SCISSOR_TEST),t.enable(t.CULL_FACE),t.cullFace(t.BACK),Kn[e])}function Zn(e){if("undefined"!==typeof OffscreenCanvas&&2===e)return new OffscreenCanvas(300,150);if("undefined"!==typeof document)return document.createElement("canvas");throw new Error("Cannot create a canvas in this context")}function Jn(e){if(1!==e&&2!==e)throw new Error("Cannot get WebGL rendering context, WebGL is disabled.");const t=Zn(e);return t.addEventListener("webglcontextlost",t=>{t.preventDefault(),delete Kn[e]},!1),1===e?t.getContext("webgl",Xn)||t.getContext("experimental-webgl",Xn):t.getContext("webgl2",Xn)}
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var er,tr,nr;function rr(e,t){return[t,e]}function ar(e,t){return e*t}function sr(e){const t=c["util"].sizeFromShape(e),n=Math.ceil(t/4);return c["util"].sizeToSquarishShape(n)}function or(e,t){return[Math.max(1,Math.ceil(t/2)),Math.max(1,Math.ceil(e/2))]}function ir(e,t){const[n,r]=or(e,t);return n*r*4}function cr(e,t){const n=e;let r,a,s,o,i,u,l,d,p,h;return 2===Object(c["env"])().getNumber("WEBGL_VERSION")?(r=n.R32F,a=n.R16F,s=n.RGBA16F,o=n.RGBA32F,i=n.RED,l=4,d=1,p=n.HALF_FLOAT,h=n.FLOAT):(r=e.RGBA,a=e.RGBA,s=e.RGBA,o=n.RGBA,i=e.RGBA,l=4,d=4,p=null!=t?t.HALF_FLOAT_OES:null,h=e.FLOAT),u=e.RGBA,{internalFormatFloat:r,internalFormatHalfFloat:a,internalFormatPackedHalfFloat:s,internalFormatPackedFloat:o,textureFormatFloat:i,downloadTextureFormat:u,downloadUnpackNumChannels:l,defaultNumChannels:d,textureTypeHalfFloat:p,textureTypeFloat:h}}
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ur(e,t){const n=t();return Object(c["env"])().getBool("DEBUG")&&lr(e),n}function lr(e){const t=e.getError();if(t!==e.NO_ERROR)throw new Error("WebGL Error: "+fr(e,t))}(function(e){e[e["DENSE"]=0]="DENSE",e[e["SHARED_BATCH"]=1]="SHARED_BATCH"})(er||(er={})),function(e){e[e["RENDER"]=0]="RENDER",e[e["UPLOAD"]=1]="UPLOAD",e[e["PIXELS"]=2]="PIXELS",e[e["DOWNLOAD"]=3]="DOWNLOAD"}(tr||(tr={})),function(e){e[e["UNPACKED_FLOAT16"]=0]="UNPACKED_FLOAT16",e[e["UNPACKED_FLOAT32"]=1]="UNPACKED_FLOAT32",e[e["PACKED_4X1_UNSIGNED_BYTE"]=2]="PACKED_4X1_UNSIGNED_BYTE",e[e["PACKED_2X2_FLOAT32"]=3]="PACKED_2X2_FLOAT32",e[e["PACKED_2X2_FLOAT16"]=4]="PACKED_2X2_FLOAT16"}(nr||(nr={}));const dr=5.96e-8,pr=65504;function hr(e){return!!(Object(c["env"])().getBool("WEBGL_RENDER_FLOAT32_ENABLED")||0===e||dr<Math.abs(e)&&Math.abs(e)<pr)}function fr(e,t){switch(t){case e.NO_ERROR:return"NO_ERROR";case e.INVALID_ENUM:return"INVALID_ENUM";case e.INVALID_VALUE:return"INVALID_VALUE";case e.INVALID_OPERATION:return"INVALID_OPERATION";case e.INVALID_FRAMEBUFFER_OPERATION:return"INVALID_FRAMEBUFFER_OPERATION";case e.OUT_OF_MEMORY:return"OUT_OF_MEMORY";case e.CONTEXT_LOST_WEBGL:return"CONTEXT_LOST_WEBGL";default:return"Unknown error code "+t}}function mr(e,t){return Mr(e,()=>e.getExtension(t),'Extension "'+t+'" not supported on this browser.')}function br(e,t){const n=Mr(e,()=>e.createShader(e.VERTEX_SHADER),"Unable to create vertex WebGLShader.");if(ur(e,()=>e.shaderSource(n,t)),ur(e,()=>e.compileShader(n)),!1===e.getShaderParameter(n,e.COMPILE_STATUS))throw console.log(e.getShaderInfoLog(n)),new Error("Failed to compile vertex shader.");return n}function gr(e,t){const n=Mr(e,()=>e.createShader(e.FRAGMENT_SHADER),"Unable to create fragment WebGLShader.");if(ur(e,()=>e.shaderSource(n,t)),ur(e,()=>e.compileShader(n)),!1===e.getShaderParameter(n,e.COMPILE_STATUS))throw xr(t,e.getShaderInfoLog(n)),new Error("Failed to compile fragment shader.");return n}const yr=/ERROR: [0-9]+:([0-9]+):/g;function xr(e,t){const n=yr.exec(t);if(null==n)return console.log("Couldn't parse line number in error: "+t),void console.log(e);const r=+n[1],a=e.split("\n"),s=a.length.toString().length+2,o=a.map((e,t)=>c["util"].rightPad((t+1).toString(),s)+e);let i=0;for(let c=0;c<o.length;c++)i=Math.max(o[c].length,i);const u=o.slice(0,r-1),l=o.slice(r-1,r),d=o.slice(r);console.log(u.join("\n")),console.log(t.split("\n")[0]),console.log("%c "+c["util"].rightPad(l[0],i),"border:1px solid red; background-color:#e3d2d2; color:#a61717"),console.log(d.join("\n"))}function Or(e){return Mr(e,()=>e.createProgram(),"Unable to create WebGLProgram.")}function vr(e,t){if(ur(e,()=>e.linkProgram(t)),!1===e.getProgramParameter(t,e.LINK_STATUS))throw console.log(e.getProgramInfoLog(t)),new Error("Failed to link vertex and fragment shaders.")}function wr(e,t){if(ur(e,()=>e.validateProgram(t)),!1===e.getProgramParameter(t,e.VALIDATE_STATUS))throw console.log(e.getProgramInfoLog(t)),new Error("Shader program validation failed.")}function kr(e,t){const n=Mr(e,()=>e.createBuffer(),"Unable to create WebGLBuffer");return ur(e,()=>e.bindBuffer(e.ARRAY_BUFFER,n)),ur(e,()=>e.bufferData(e.ARRAY_BUFFER,t,e.STATIC_DRAW)),n}function jr(e,t){const n=Mr(e,()=>e.createBuffer(),"Unable to create WebGLBuffer");return ur(e,()=>e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,n)),ur(e,()=>e.bufferData(e.ELEMENT_ARRAY_BUFFER,t,e.STATIC_DRAW)),n}function Sr(e){return Mr(e,()=>e.createTexture(),"Unable to create WebGLTexture.")}function Nr(e,t){const n=Object(c["env"])().getNumber("WEBGL_MAX_TEXTURE_SIZE");if(e<=0||t<=0){const n=`[${e}x${t}]`;throw new Error("Requested texture size "+n+" is invalid.")}if(e>n||t>n){const r=`[${e}x${t}]`,a=`[${n}x${n}]`;throw new Error("Requested texture size "+r+" greater than WebGL maximum on this browser / GPU "+a+".")}}function Cr(e){return Mr(e,()=>e.createFramebuffer(),"Unable to create WebGLFramebuffer.")}function Ir(e,t,n,r,a,s,o){const i=e.getAttribLocation(t,n);return-1!==i&&(ur(e,()=>e.bindBuffer(e.ARRAY_BUFFER,r)),ur(e,()=>e.vertexAttribPointer(i,a,e.FLOAT,!1,s,o)),ur(e,()=>e.enableVertexAttribArray(i)),!0)}function Tr(e,t,n){Lr(e,n),ur(e,()=>e.activeTexture(e.TEXTURE0+n)),ur(e,()=>e.bindTexture(e.TEXTURE_2D,t))}function $r(e,t,n){return Mr(e,()=>e.getUniformLocation(t,n),'uniform "'+n+'" not present in program.')}function Er(e,t,n){return e.getUniformLocation(t,n)}function Ar(e,t,n,r){ur(e,()=>Tr(e,t,r)),ur(e,()=>e.uniform1i(n,r))}function Rr(e,t,n){ur(e,()=>e.bindFramebuffer(e.FRAMEBUFFER,n)),ur(e,()=>e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,t,0))}function _r(e,t){ur(e,()=>e.bindFramebuffer(e.FRAMEBUFFER,t)),ur(e,()=>e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,null,0))}function Fr(e){const t=e.checkFramebufferStatus(e.FRAMEBUFFER);if(t!==e.FRAMEBUFFER_COMPLETE)throw new Error("Error binding framebuffer: "+Dr(e,t))}function Dr(e,t){switch(t){case e.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_ATTACHMENT";case e.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";case e.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:return"FRAMEBUFFER_INCOMPLETE_DIMENSIONS";case e.FRAMEBUFFER_UNSUPPORTED:return"FRAMEBUFFER_UNSUPPORTED";default:return"unknown error "+t}}function Mr(e,t,n){const r=ur(e,()=>t());if(null==r)throw new Error(n);return r}function Lr(e,t){const n=e.MAX_COMBINED_TEXTURE_IMAGE_UNITS-1,r=t+e.TEXTURE0;if(r<e.TEXTURE0||r>n){const e=`[gl.TEXTURE0, gl.TEXTURE${n}]`;throw new Error(`textureUnit must be in ${e}.`)}}function Pr(e,t=2){return c["util"].sizeFromShape(e.slice(0,e.length-t))}function Br(e){if(0===e.length)throw Error("Cannot get rows and columns of an empty shape array.");return[e.length>1?e[e.length-2]:1,e[e.length-1]]}function Vr(e){let t=[1,1,1];const n=0===e.length||1===e.length&&1===e[0];return n||(t=[Pr(e),...Br(e)]),t}function zr(e,t=!1){let n=Object(c["env"])().getNumber("WEBGL_MAX_TEXTURE_SIZE");if(t&&(n*=2,e=e.map((t,n)=>n>=e.length-2?c["util"].nearestLargerEven(e[n]):e[n]),1===e.length&&(e=[2,e[0]])),2!==e.length){const t=c["util"].squeezeShape(e);e=t.newShape}let r=c["util"].sizeFromShape(e);if(e.length<=1&&r<=n)return[1,r];if(2===e.length&&e[0]<=n&&e[1]<=n)return e;if(3===e.length&&e[0]*e[1]<=n&&e[2]<=n)return[e[0]*e[1],e[2]];if(3===e.length&&e[0]<=n&&e[1]*e[2]<=n)return[e[0],e[1]*e[2]];if(4===e.length&&e[0]*e[1]*e[2]<=n&&e[3]<=n)return[e[0]*e[1]*e[2],e[3]];if(4===e.length&&e[0]<=n&&e[1]*e[2]*e[3]<=n)return[e[0],e[1]*e[2]*e[3]];if(t){const t=Pr(e);let n=2,a=2;return e.length&&([n,a]=Br(e)),r=t*(n/2)*(a/2),c["util"].sizeToSquarishShape(r).map(e=>2*e)}return c["util"].sizeToSquarishShape(r)}function Wr(e){return e%2===0}function Ur(e,t){if(e=e.slice(-2),t=t.slice(-2),c["util"].arraysEqual(e,t))return!0;if(!e.length||!t.length)return!0;if(0===e[0]||0===e[1]||0===t[0]||0===t[1])return!0;if(e.length!==t.length){const n=e.slice(-1)[0],r=t.slice(-1)[0];if(n===r)return!0;if(Wr(n)&&Wr(r)&&(1===e[0]||1===t[0]))return!0}return e[1]===t[1]&&Wr(e[0])&&Wr(t[0])}let Gr,Hr;function qr(e){if(null==Gr){const t=Qn(e);Gr=t.getParameter(t.MAX_TEXTURE_SIZE)}return Gr}function Kr(e){if(null==Hr){const t=Qn(e);Hr=t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS)}return Math.min(16,Hr)}function Xr(e){if(0===e)return 0;let t;const n=Qn(e);return t=Yr(n,"EXT_disjoint_timer_query_webgl2")&&2===e?2:Yr(n,"EXT_disjoint_timer_query")?1:0,t}function Yr(e,t){const n=e.getExtension(t);return null!=n}function Qr(e){try{const t=Qn(e);if(null!=t)return!0}catch(t){return console.log("Error when getting WebGL context: ",t),!1}return!1}function Zr(e){if(0===e)return!1;const t=Qn(e);if(1===e){if(!Yr(t,"OES_texture_float"))return!1}else if(!Yr(t,"EXT_color_buffer_float"))return!1;const n=ea(t);return n}function Jr(e){if(0===e)return!1;const t=Qn(e);if(1!==e){if(Yr(t,"EXT_color_buffer_float"))return ea(t);const e="EXT_color_buffer_half_float";if(Yr(t,e)){const n=t.getExtension(e);return ta(t,n)}return!1}if(!Yr(t,"OES_texture_float"))return!1;if(!Yr(t,"WEBGL_color_buffer_float"))return!1;const n=ea(t);return n}function ea(e){const t=cr(e),n=e.createTexture();e.bindTexture(e.TEXTURE_2D,n);const r=1,a=1;e.texImage2D(e.TEXTURE_2D,0,t.internalFormatFloat,r,a,0,t.textureFormatFloat,t.textureTypeFloat,null);const s=e.createFramebuffer();e.bindFramebuffer(e.FRAMEBUFFER,s),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,n,0);const o=e.checkFramebufferStatus(e.FRAMEBUFFER)===e.FRAMEBUFFER_COMPLETE;return e.bindTexture(e.TEXTURE_2D,null),e.bindFramebuffer(e.FRAMEBUFFER,null),e.deleteTexture(n),e.deleteFramebuffer(s),o}function ta(e,t){const n=cr(e,t),r=e.createTexture();e.bindTexture(e.TEXTURE_2D,r);const a=1,s=1;e.texImage2D(e.TEXTURE_2D,0,n.internalFormatHalfFloat,a,s,0,n.textureFormatFloat,n.textureTypeHalfFloat,null);const o=e.createFramebuffer();e.bindFramebuffer(e.FRAMEBUFFER,o),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,r,0);const i=e.checkFramebufferStatus(e.FRAMEBUFFER)===e.FRAMEBUFFER_COMPLETE;return e.bindTexture(e.TEXTURE_2D,null),e.bindFramebuffer(e.FRAMEBUFFER,null),e.deleteTexture(r),e.deleteFramebuffer(o),i}function na(e){if(2!==e)return!1;const t=Qn(e),n=null!=t.fenceSync;return n}function ra(e,t){Array.isArray(e)||(e=[e]),e.forEach(e=>{null!=e&&c["util"].assert("complex64"!==e.dtype,()=>t+" does not support complex64 tensors in the WebGL backend.")})}
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const aa=Object(c["env"])();
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function sa(){let e,t,n,r,a,s,o,i,u,l;return 2===Object(c["env"])().getNumber("WEBGL_VERSION")?(e="#version 300 es",t="in",n="out",r="in",a="texture",s="outputColor",o="out vec4 outputColor;",i="\n      bool isnan_custom(float val) {\n        return (val > 0.0 || val < 0.0) ? false : val != 0.0;\n      }\n\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan_custom(val.x),\n          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));\n      }\n\n      #define isnan(value) isnan_custom(value)\n    ",u="",l="\n      #define round(value) newRound(value)\n      int newRound(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 newRound(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    "):(e="",t="attribute",n="varying",r="varying",a="texture2D",s="gl_FragColor",o="",i="\n      #define isnan(value) isnan_custom(value)\n      bool isnan_custom(float val) {\n        return (val > 0. || val < 1. || val == 0.) ? false : true;\n      }\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));\n      }\n    ",u="\n      uniform float INFINITY;\n\n      bool isinf(float val) {\n        return abs(val) == INFINITY;\n      }\n      bvec4 isinf(vec4 val) {\n        return equal(abs(val), vec4(INFINITY));\n      }\n    ",l="\n      int round(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 round(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    "),{version:e,attribute:t,varyingVs:n,varyingFs:r,texture2D:a,output:s,defineOutput:o,defineSpecialNaN:i,defineSpecialInf:u,defineRound:l}}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oa(e,t,n="index"){const r=c["util"].computeStrides(t);return r.map((t,a)=>{const s=`int ${e[a]} = ${n} / ${t}`,o=a===r.length-1?`int ${e[a+1]} = ${n} - ${e[a]} * ${t}`:`index -= ${e[a]} * ${t}`;return`${s}; ${o};`}).join("")}function ia(e,t,n="index"){const r=c["util"].computeStrides(t);return r.map((t,a)=>{const s=`int ${e[a]} = ${n} / outShapeStrides[${a}]`,o=a===r.length-1?`int ${e[a+1]} = ${n} - ${e[a]} * outShapeStrides[${a}]`:`index -= ${e[a]} * outShapeStrides[${a}]`;return`${s}; ${o};`}).join("")}function ca(e,t){const n=e.length,r=e.map(e=>`${t}[${e}]`),a=new Array(n-1);a[n-2]=r[n-1];for(let s=n-3;s>=0;--s)a[s]=`(${a[s+1]} * ${r[s+1]})`;return a}function ua(e,t,n="index"){const r=e.map((e,t)=>t),a=ca(r,t);return a.map((t,r)=>{const s=`int ${e[r]} = ${n} / ${a[r]}`,o=r===a.length-1?`int ${e[r+1]} = ${n} - ${e[r]} * ${a[r]}`:`index -= ${e[r]} * ${a[r]}`;return`${s}; ${o};`}).join("")}function la(e){const t=c["util"].computeStrides(e).map(e=>e.toString());return`\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * ${t[0]} + coords.y * ${t[1]} + coords.z;\n  }\n`}function da(){return"\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;\n  }\n"}aa.registerFlag("HAS_WEBGL",()=>aa.getNumber("WEBGL_VERSION")>0),aa.registerFlag("WEBGL_VERSION",()=>Qr(2)?2:Qr(1)?1:0),aa.registerFlag("WEBGL_CHECK_NUMERICAL_PROBLEMS",()=>!1),aa.registerFlag("WEBGL_BUFFER_SUPPORTED",()=>2===aa.get("WEBGL_VERSION")),aa.registerFlag("WEBGL_CPU_FORWARD",()=>!0),aa.registerFlag("WEBGL_FORCE_F16_TEXTURES",()=>!1),aa.registerFlag("WEBGL_PACK",()=>aa.getBool("HAS_WEBGL")),aa.registerFlag("WEBGL_PACK_NORMALIZATION",()=>aa.getBool("WEBGL_PACK")),aa.registerFlag("WEBGL_PACK_CLIP",()=>aa.getBool("WEBGL_PACK")),aa.registerFlag("WEBGL_PACK_DEPTHWISECONV",()=>aa.getBool("WEBGL_PACK")),aa.registerFlag("WEBGL_PACK_BINARY_OPERATIONS",()=>aa.getBool("WEBGL_PACK")),aa.registerFlag("WEBGL_PACK_UNARY_OPERATIONS",()=>aa.getBool("WEBGL_PACK")),aa.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS",()=>aa.getBool("WEBGL_PACK")),aa.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS",()=>aa.getBool("WEBGL_PACK")),aa.registerFlag("WEBGL_PACK_REDUCE",()=>aa.getBool("WEBGL_PACK")),aa.registerFlag("WEBGL_LAZILY_UNPACK",()=>aa.getBool("WEBGL_PACK")),aa.registerFlag("WEBGL_CONV_IM2COL",()=>aa.getBool("WEBGL_PACK")),aa.registerFlag("WEBGL_MAX_TEXTURE_SIZE",()=>qr(aa.getNumber("WEBGL_VERSION"))),aa.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER",()=>Kr(aa.getNumber("WEBGL_VERSION"))),aa.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION",()=>{const e=aa.getNumber("WEBGL_VERSION");return 0===e?0:Xr(e)}),aa.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE",()=>aa.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0&&!c["device_util"].isMobile()),aa.registerFlag("WEBGL_RENDER_FLOAT32_CAPABLE",()=>Zr(aa.getNumber("WEBGL_VERSION"))),aa.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED",()=>!aa.getBool("WEBGL_FORCE_F16_TEXTURES")&&aa.getBool("WEBGL_RENDER_FLOAT32_CAPABLE")),aa.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED",()=>Jr(aa.getNumber("WEBGL_VERSION"))),aa.registerFlag("WEBGL_FENCE_API_ENABLED",()=>na(aa.getNumber("WEBGL_VERSION"))),aa.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM",()=>{const e=aa.getBool("WEBGL_RENDER_FLOAT32_ENABLED");return e?4:0}),aa.registerFlag("WEBGL_DELETE_TEXTURE_THRESHOLD",()=>-1,e=>{if(e<0&&-1!==e)throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be -1 (indicating never delete) or at least 0, but got ${e}.`)}),aa.registerFlag("WEBGL_FLUSH_THRESHOLD",()=>c["device_util"].isMobile()&&aa.getBool("IS_CHROME")?1:-1,e=>{if(e<0&&-1!==e)throw new Error(`WEBGL_FLUSH_THRESHOLD must be -1 (indicating never manual flush) or at least 0, but got ${e}.`)}),aa.registerFlag("CPU_HANDOFF_SIZE_THRESHOLD",()=>128),aa.registerFlag("WEBGL_USE_SHAPES_UNIFORMS",()=>!1),aa.registerFlag("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD",()=>1e5),aa.registerFlag("TOPK_K_CPU_HANDOFF_THRESHOLD",()=>128);const pa="\n  const float FLOAT_MAX = 1.70141184e38;\n  const float FLOAT_MIN = 1.17549435e-38;\n\n  lowp vec4 encode_float(highp float v) {\n    if (isnan(v)) {\n      return vec4(255, 255, 255, 255);\n    }\n\n    highp float av = abs(v);\n\n    if(av < FLOAT_MIN) {\n      return vec4(0.0, 0.0, 0.0, 0.0);\n    } else if(v > FLOAT_MAX) {\n      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;\n    } else if(v < -FLOAT_MAX) {\n      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;\n    }\n\n    highp vec4 c = vec4(0,0,0,0);\n\n    highp float e = floor(log2(av));\n    highp float m = exp2(fract(log2(av))) - 1.0;\n\n    c[2] = floor(128.0 * m);\n    m -= c[2] / 128.0;\n    c[1] = floor(32768.0 * m);\n    m -= c[1] / 32768.0;\n    c[0] = floor(8388608.0 * m);\n\n    highp float ebias = e + 127.0;\n    c[3] = floor(ebias / 2.0);\n    ebias -= c[3] * 2.0;\n    c[2] += floor(ebias) * 128.0;\n\n    c[3] += 128.0 * step(0.0, -v);\n\n    return c / 255.0;\n  }\n",{getBroadcastDims:ha}=c["backend_util"];
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fa(e,t,n){const r=[];if(e.forEach(e=>{const t=c["util"].sizeFromShape(e.shapeInfo.logicalShape);if(e.shapeInfo.isUniform?r.push(`uniform float ${e.name}${t>1?`[${t}]`:""};`):(r.push(`uniform sampler2D ${e.name};`),r.push(`uniform int offset${e.name};`)),n.enableShapeUniforms){const{uniformShape:t}=ns(n.packedInputs,e.shapeInfo.logicalShape,e.shapeInfo.texShape);switch(t.length){case 1:r.push(`uniform int ${e.name}Shape;`);break;case 2:r.push(`uniform ivec2 ${e.name}Shape;`);break;case 3:r.push(`uniform ivec3 ${e.name}Shape;`);break;case 4:r.push(`uniform ivec4 ${e.name}Shape;`);break;default:break}r.push(`uniform ivec2 ${e.name}TexShape;`)}}),n.enableShapeUniforms){switch(t.logicalShape.length){case 1:r.push("uniform int outShape;");break;case 2:r.push("uniform ivec2 outShape;"),r.push("uniform int outShapeStrides;");break;case 3:r.push("uniform ivec3 outShape;"),r.push("uniform ivec2 outShapeStrides;");break;case 4:r.push("uniform ivec4 outShape;"),r.push("uniform ivec3 outShapeStrides;");break;default:break}r.push("uniform ivec2 outTexShape;")}n.customUniforms&&n.customUniforms.forEach(e=>{r.push(`uniform ${e.type} ${e.name}${e.arrayIndex?`[${e.arrayIndex}]`:""};`)});const a=r.join("\n"),s=e.map(e=>ga(e,t,n.packedInputs,n.enableShapeUniforms)).join("\n"),o=t.texShape,i=sa(),u=Oa(i);let l,d,p=ka(i);t.isPacked?(l=ya(t.logicalShape,o,n.enableShapeUniforms),d=wa(i)):(l=xa(t.logicalShape,o,n.enableShapeUniforms),d=va(i)),n.packedInputs&&(p+=Ca);const h=[p,u,d,a,l,s,n.userCode].join("\n");return h}function ma(e,t=!1){const n=e.shapeInfo.logicalShape;switch(n.length){case 0:return Va(e,t);case 1:return Wa(e,t);case 2:return Ga(e,t);case 3:return qa(e,t);case 4:return Xa(e,t);case 5:return Ya(e);case 6:return Qa(e);default:throw new Error(n.length+"-D input sampling is not yet supported")}}function ba(e,t){const n=e.shapeInfo.logicalShape;switch(n.length){case 0:return Ba(e);case 1:return za(e,t);case 2:return Ua(e,t);case 3:return Ha(e,t);default:return Ka(e,t)}}function ga(e,t,n=!1,r){let a="";a+=n?ba(e,r):ma(e,r);const s=e.shapeInfo.logicalShape,o=t.logicalShape;return s.length<=o.length&&(a+=n?Ja(e,t):es(e,t)),a}function ya(e,t,n){switch(e.length){case 0:return Ia();case 1:return Ta(e,t,n);case 2:return Ma(e,t,n);case 3:return Ea(e,t,n);default:return Ra(e,t,n)}}function xa(e,t,n){switch(e.length){case 0:return Ia();case 1:return $a(e,t,n);case 2:return La(e,t,n);case 3:return Aa(e,t,n);case 4:return _a(e,t,n);case 5:return Fa(e,t);case 6:return Da(e,t);default:throw new Error(e.length+"-D output sampling is not yet supported")}}function Oa(e){return`\n    float sampleTexture(sampler2D textureSampler, vec2 uv) {\n      return ${e.texture2D}(textureSampler, uv).r;\n    }\n  `}function va(e){return`\n    void setOutput(float val) {\n      ${e.output} = vec4(val, 0, 0, 0);\n    }\n  `}function wa(e){return`\n    void setOutput(vec4 val) {\n      ${e.output} = val;\n    }\n  `}function ka(e){const t=`${e.version}\n    precision highp float;\n    precision highp int;\n    precision highp sampler2D;\n    ${e.varyingFs} vec2 resultUV;\n    ${e.defineOutput}\n    const vec2 halfCR = vec2(0.5, 0.5);\n\n    struct ivec5\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n    };\n\n    struct ivec6\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n      int v;\n    };\n\n    uniform float NAN;\n    ${e.defineSpecialNaN}\n    ${e.defineSpecialInf}\n    ${e.defineRound}\n\n    int imod(int x, int y) {\n      return x - y * (x / y);\n    }\n\n    int idiv(int a, int b, float sign) {\n      int res = a / b;\n      int mod = imod(a, b);\n      if (sign < 0. && mod != 0) {\n        res -= 1;\n      }\n      return res;\n    }\n\n    //Based on the work of Dave Hoskins\n    //https://www.shadertoy.com/view/4djSRW\n    #define HASHSCALE1 443.8975\n    float random(float seed){\n      vec2 p = resultUV * seed;\n      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n      p3 += dot(p3, p3.yzx + 19.19);\n      return fract((p3.x + p3.y) * p3.z);\n    }\n\n    ${ja}\n    ${Sa}\n    ${Na}\n  `;return t}const ja="\nvec2 uvFromFlat(int texNumR, int texNumC, int index) {\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\nvec2 packedUVfrom1D(int texNumR, int texNumC, int index) {\n  int texelIndex = index / 2;\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",Sa="\nvec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,\n  int texNumC, int row, int col) {\n  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",Na="\nvec2 packedUVfrom3D(int texNumR, int texNumC,\n    int texelsInBatch, int texelsInLogicalRow, int b,\n    int row, int col) {\n  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",Ca="\n  float getChannel(vec4 frag, vec2 innerDims) {\n    vec2 modCoord = mod(innerDims, 2.);\n    return modCoord.x == 0. ?\n      (modCoord.y == 0. ? frag.r : frag.g) :\n      (modCoord.y == 0. ? frag.b : frag.a);\n  }\n  float getChannel(vec4 frag, int dim) {\n    float modCoord = mod(float(dim), 2.);\n    return modCoord == 0. ? frag.r : frag.g;\n  }\n";function Ia(){return"\n    int getOutputCoords() {\n      return 0;\n    }\n  "}function Ta(e,t,n){const r=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)];return 1===r[0]?n?"\n      int getOutputCoords() {\n        return 2 * int(resultUV.x * ceil(float(outTexShape[1]) / 2.0));\n      }\n    ":`\n      int getOutputCoords() {\n        return 2 * int(resultUV.x * ${r[1]}.0);\n      }\n    `:1===r[1]?n?"\n      int getOutputCoords() {\n        return 2 * int(resultUV.y * ceil(float(outTexShape[0]) / 2.0));\n      }\n    ":`\n      int getOutputCoords() {\n        return 2 * int(resultUV.y * ${r[0]}.0);\n      }\n    `:n?"\n    int getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      return 2 * (resTexRC.x * packedTexShape[1] + resTexRC.y);\n    }\n  ":`\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${r[0]}, ${r[1]}));\n      return 2 * (resTexRC.x * ${r[1]} + resTexRC.y);\n    }\n  `}function $a(e,t,n){return 1===t[0]?n?"\n      int getOutputCoords() {\n        return int(resultUV.x * float(outTexShape[1]));\n      }\n    ":`\n      int getOutputCoords() {\n        return int(resultUV.x * ${t[1]}.0);\n      }\n    `:1===t[1]?n?"\n      int getOutputCoords() {\n        return int(resultUV.y * float(outTexShape[0]));\n      }\n    ":`\n      int getOutputCoords() {\n        return int(resultUV.y * ${t[0]}.0);\n      }\n    `:n?"\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(outTexShape[0], outTexShape[1]));\n      return resTexRC.x * outTexShape[1] + resTexRC.y;\n    }\n  ":`\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${t[0]}, ${t[1]}));\n      return resTexRC.x * ${t[1]} + resTexRC.y;\n    }\n  `}function Ea(e,t,n){if(n)return"\n    ivec3 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      int texelsInLogicalRow = int(ceil(float(outShape[2]) / 2.0));\n      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n\n      int b = index / texelsInBatch;\n      index -= b * texelsInBatch;\n\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec3(b, r, c);\n    }\n  ";const r=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)],a=Math.ceil(e[2]/2),s=a*Math.ceil(e[1]/2);return`\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${r[0]}, ${r[1]}));\n      int index = resTexRC.x * ${r[1]} + resTexRC.y;\n\n      int b = index / ${s};\n      index -= b * ${s};\n\n      int r = 2 * (index / ${a});\n      int c = imod(index, ${a}) * 2;\n\n      return ivec3(b, r, c);\n    }\n  `}function Aa(e,t,n){if(n){const t=ia(["r","c","d"],e);return`\n  ivec3 getOutputCoords() {\n    ivec2 resTexRC = ivec2(resultUV.yx *\n                           vec2(outTexShape[0], outTexShape[1]));\n    int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n    ${t}\n    return ivec3(r, c, d);\n  }\n`}const r=oa(["r","c","d"],e);return`\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${t[0]}, ${t[1]}));\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n      ${r}\n      return ivec3(r, c, d);\n    }\n  `}function Ra(e,t,n){if(n)return"\n    ivec4 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n\n      int texelsInLogicalRow = int(ceil(float(outShape[3]) / 2.0));\n      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[2]) / 2.0));\n      int texelsInBatchN = texelsInBatch * outShape[1];\n\n      int b2 = index / texelsInBatchN;\n      index -= b2 * texelsInBatchN;\n\n      int b = index / texelsInBatch;\n      index -= b * texelsInBatch;\n\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec4(b2, b, r, c);\n    }\n  ";const r=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)],a=Math.ceil(e[e.length-1]/2),s=a*Math.ceil(e[e.length-2]/2);let o=s,i="",c="b, r, c";for(let u=2;u<e.length-1;u++)o*=e[e.length-u-1],i=`\n      int b${u} = index / ${o};\n      index -= b${u} * ${o};\n    `+i,c=`b${u}, `+c;return`\n    ivec${e.length} getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${r[0]}, ${r[1]}));\n      int index = resTexRC.x * ${r[1]} + resTexRC.y;\n\n      ${i}\n\n      int b = index / ${s};\n      index -= b * ${s};\n\n      int r = 2 * (index / ${a});\n      int c = imod(index, ${a}) * 2;\n\n      return ivec${e.length}(${c});\n    }\n  `}function _a(e,t,n){if(n){const t=ia(["r","c","d","d2"],e);return`\n    ivec4 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(outTexShape[0], outTexShape[1]));\n      int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n      ${t}\n      return ivec4(r, c, d, d2);\n    }\n  `}const r=oa(["r","c","d","d2"],e);return`\n    ivec4 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(${t[0]}, ${t[1]}));\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n      ${r}\n      return ivec4(r, c, d, d2);\n    }\n  `}function Fa(e,t){const n=oa(["r","c","d","d2","d3"],e);return`\n    ivec5 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx * vec2(${t[0]},\n                             ${t[1]}));\n\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n\n      ${n}\n\n      ivec5 outShape = ivec5(r, c, d, d2, d3);\n      return outShape;\n    }\n  `}function Da(e,t){const n=oa(["r","c","d","d2","d3","d4"],e);return`\n    ivec6 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(${t[0]}, ${t[1]}));\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n\n      ${n}\n\n      ivec6 result = ivec6(r, c, d, d2, d3, d4);\n      return result;\n    }\n  `}function Ma(e,t,n){const r=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)];if(c["util"].arraysEqual(e,t))return n?"\n      ivec2 getOutputCoords() {\n        ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n        return 2 * ivec2(resultUV.yx * vec2(packedTexShape[0], packedTexShape[1]));\n      }\n    ":`\n      ivec2 getOutputCoords() {\n        return 2 * ivec2(resultUV.yx * vec2(${r[0]}, ${r[1]}));\n      }\n    `;const a=Math.ceil(e[1]/2);return n?"\n    ivec2 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      int texelsInLogicalRow = int(ceil(float(outShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec2(r, c);\n    }\n  ":`\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${r[0]}, ${r[1]}));\n\n      int index = resTexRC.x * ${r[1]} + resTexRC.y;\n      int r = 2 * (index / ${a});\n      int c = imod(index, ${a}) * 2;\n\n      return ivec2(r, c);\n    }\n  `}function La(e,t,n){return c["util"].arraysEqual(e,t)?n?"\n      ivec2 getOutputCoords() {\n        return ivec2(resultUV.yx * vec2(outTexShape[0], outTexShape[1]));\n      }\n    ":`\n      ivec2 getOutputCoords() {\n        return ivec2(resultUV.yx * vec2(${t[0]}, ${t[1]}));\n      }\n    `:1===e[1]?n?"\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(outTexShape[0], outTexShape[1]));\n        int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n        return ivec2(index, 0);\n      }\n    ":`\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(${t[0]}, ${t[1]}));\n        int index = resTexRC.x * ${t[1]} + resTexRC.y;\n        return ivec2(index, 0);\n      }\n    `:1===e[0]?n?"\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(outTexShape[0], outTexShape[1]));\n        int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n        return ivec2(0, index);\n      }\n    ":`\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(${t[0]}, ${t[1]}));\n        int index = resTexRC.x * ${t[1]} + resTexRC.y;\n        return ivec2(0, index);\n      }\n    `:n?"\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(outTexShape[0], outTexShape[1]));\n      int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n      int r = index / outShape[1];\n      int c = index - r * outShape[1];\n      return ivec2(r, c);\n    }\n  ":`\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${t[0]}, ${t[1]}));\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n      int r = index / ${e[1]};\n      int c = index - r * ${e[1]};\n      return ivec2(r, c);\n    }\n  `}function Pa(e){return"offset"+e}function Ba(e){const t=e.name,n="get"+t.charAt(0).toUpperCase()+t.slice(1),r=sa();return`\n    vec4 ${n}() {\n      return ${r.texture2D}(${t}, halfCR);\n    }\n  `}function Va(e,t){const n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1);if(e.shapeInfo.isUniform)return`float ${r}() {return ${n};}`;const[a,s]=e.shapeInfo.texShape;if(1===a&&1===s)return`\n      float ${r}() {\n        return sampleTexture(${n}, halfCR);\n      }\n    `;const o=Pa(n);if(t)return`\n    float ${r}() {\n      vec2 uv = uvFromFlat(${n}TexShape[0], ${n}TexShape[1], ${o});\n      return sampleTexture(${n}, uv);\n    }\n  `;const[i,c]=e.shapeInfo.texShape;return`\n    float ${r}() {\n      vec2 uv = uvFromFlat(${i}, ${c}, ${o});\n      return sampleTexture(${n}, uv);\n    }\n  `}function za(e,t){const n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),a=e.shapeInfo.texShape,s=sa();if(t)return`\n    vec4 ${r}(int index) {\n      ivec2 packedTexShape = ivec2(ceil(float(${n}TexShape[0]) / 2.0), ceil(float(${n}TexShape[1]) / 2.0));\n      vec2 uv = packedUVfrom1D(\n        packedTexShape[0], packedTexShape[1], index);\n      return ${s.texture2D}(${n}, uv);\n    }\n  `;const o=[Math.ceil(a[0]/2),Math.ceil(a[1]/2)];return`\n    vec4 ${r}(int index) {\n      vec2 uv = packedUVfrom1D(\n        ${o[0]}, ${o[1]}, index);\n      return ${s.texture2D}(${n}, uv);\n    }\n  `}function Wa(e,t){const n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1);if(e.shapeInfo.isUniform)return`\n      float ${r}(int index) {\n        ${Za(e)}\n      }\n    `;const a=e.shapeInfo.texShape,s=a[0],o=a[1];if(1===o&&1===s)return`\n      float ${r}(int index) {\n        return sampleTexture(${n}, halfCR);\n      }\n    `;const i=Pa(n);return 1===o?t?`\n      float ${r}(int index) {\n        vec2 uv = vec2(0.5, (float(index + ${i}) + 0.5) / float(${n}TexShape[0]));\n        return sampleTexture(${n}, uv);\n      }\n    `:`\n      float ${r}(int index) {\n        vec2 uv = vec2(0.5, (float(index + ${i}) + 0.5) / ${s}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `:1===s?t?`\n      float ${r}(int index) {\n        vec2 uv = vec2((float(index + ${i}) + 0.5) / float(${n}TexShape[1]), 0.5);\n        return sampleTexture(${n}, uv);\n      }\n    `:`\n      float ${r}(int index) {\n        vec2 uv = vec2((float(index + ${i}) + 0.5) / ${o}.0, 0.5);\n        return sampleTexture(${n}, uv);\n      }\n    `:t?`\n    float ${r}(int index) {\n      vec2 uv = uvFromFlat(${n}TexShape[0], ${n}TexShape[1], index + ${i});\n      return sampleTexture(${n}, uv);\n    }\n  `:`\n    float ${r}(int index) {\n      vec2 uv = uvFromFlat(${s}, ${o}, index + ${i});\n      return sampleTexture(${n}, uv);\n    }\n  `}function Ua(e,t){const n=e.shapeInfo.logicalShape,r=e.name,a="get"+r.charAt(0).toUpperCase()+r.slice(1),s=e.shapeInfo.texShape,o=s[0],i=s[1],u=sa();if(null!=s&&c["util"].arraysEqual(n,s))return t?`\n      vec4 ${a}(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);\n\n        return ${u.texture2D}(${r}, uv);\n      }\n    `:`\n      vec4 ${a}(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(${i}.0, ${o}.0);\n\n        return ${u.texture2D}(${r}, uv);\n      }\n    `;if(t)return`\n    vec4 ${a}(int row, int col) {\n      ivec2 packedTexShape = ivec2(ceil(float(${r}TexShape[0]) / 2.0), ceil(float(${r}TexShape[1]) / 2.0));\n      int valuesPerRow = int(ceil(float(${r}Shape[1]) / 2.0));\n      vec2 uv = packedUVfrom2D(valuesPerRow, packedTexShape[0], packedTexShape[1], row, col);\n      return ${u.texture2D}(${r}, uv);\n    }\n  `;const l=[Math.ceil(s[0]/2),Math.ceil(s[1]/2)],d=Math.ceil(n[1]/2);return`\n    vec4 ${a}(int row, int col) {\n      vec2 uv = packedUVfrom2D(${d}, ${l[0]}, ${l[1]}, row, col);\n      return ${u.texture2D}(${r}, uv);\n    }\n  `}function Ga(e,t){const n=e.shapeInfo.logicalShape,r=e.name,a="get"+r.charAt(0).toUpperCase()+r.slice(1),s=e.shapeInfo.texShape;if(null!=s&&c["util"].arraysEqual(n,s)){if(t)return`\n      float ${a}(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);\n        return sampleTexture(${r}, uv);\n      }\n    `;const e=s[0],n=s[1];return`\n    float ${a}(int row, int col) {\n      vec2 uv = (vec2(col, row) + halfCR) / vec2(${n}.0, ${e}.0);\n      return sampleTexture(${r}, uv);\n    }\n  `}const{newShape:o,keptDims:i}=c["util"].squeezeShape(n),u=o;if(u.length<n.length){const n=rs(e,u),r=["row","col"];return`\n      ${ma(n,t)}\n      float ${a}(int row, int col) {\n        return ${a}(${as(r,i)});\n      }\n    `}if(e.shapeInfo.isUniform)return`\n      float ${a}(int row, int col) {\n        int index = round(dot(vec2(row, col), vec2(${n[1]}, 1)));\n        ${Za(e)}\n      }\n    `;const l=s[0],d=s[1],p=Pa(r);return 1===d?t?`\n      float ${a}(int row, int col) {\n        float index = dot(vec3(row, col, ${p}), vec3(${r}Shape[1], 1, 1));\n        vec2 uv = vec2(0.5, (index + 0.5) / float(${r}TexShape[0]));\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n    float ${a}(int row, int col) {\n      float index = dot(vec3(row, col, ${p}), vec3(${n[1]}, 1, 1));\n      vec2 uv = vec2(0.5, (index + 0.5) / ${l}.0);\n      return sampleTexture(${r}, uv);\n    }\n  `:1===l?t?`\n      float ${a}(int row, int col) {\n        float index = dot(vec3(row, col, ${p}), vec3(${r}Shape[1], 1, 1));\n        vec2 uv = vec2((index + 0.5) / float(${r}TexShape[1]), 0.5);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n    float ${a}(int row, int col) {\n      float index = dot(vec3(row, col, ${p}), vec3(${n[1]}, 1, 1));\n      vec2 uv = vec2((index + 0.5) / ${d}.0, 0.5);\n      return sampleTexture(${r}, uv);\n    }\n  `:t?`\n      float ${a}(int row, int col) {\n        // Explicitly use integer operations as dot() only works on floats.\n        int index = row * ${r}Shape[1] + col + ${p};\n        vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n  float ${a}(int row, int col) {\n    // Explicitly use integer operations as dot() only works on floats.\n    int index = row * ${n[1]} + col + ${p};\n    vec2 uv = uvFromFlat(${l}, ${d}, index);\n    return sampleTexture(${r}, uv);\n  }\n`}function Ha(e,t){const n=e.shapeInfo.logicalShape,r=e.name,a="get"+r.charAt(0).toUpperCase()+r.slice(1),s=e.shapeInfo.texShape,o=[Math.ceil(s[0]/2),Math.ceil(s[1]/2)];if(1===n[0]){const r=n.slice(1),s=[1,2],o=rs(e,r),i=["b","row","col"];return`\n        ${ba(o,t)}\n        vec4 ${a}(int b, int row, int col) {\n          return ${a}(${as(i,s)});\n        }\n      `}const i=sa();if(t)return`\n    vec4 ${a}(int b, int row, int col) {\n      ivec2 packedTexShape = ivec2(ceil(float(${r}TexShape[0]) / 2.0), ceil(float(${r}TexShape[1]) / 2.0));\n      int valuesPerRow = int(ceil(float(${r}Shape[2]) / 2.0));\n      int texelsInBatch = valuesPerRow * int(ceil(float(${r}Shape[1]) / 2.0));\n      vec2 uv = packedUVfrom3D(\n        packedTexShape[0], packedTexShape[1], texelsInBatch, valuesPerRow, b, row, col);\n      return ${i.texture2D}(${r}, uv);\n    }\n  `;const c=o[0],u=o[1],l=Math.ceil(n[2]/2),d=l*Math.ceil(n[1]/2);return`\n    vec4 ${a}(int b, int row, int col) {\n      vec2 uv = packedUVfrom3D(\n        ${c}, ${u}, ${d}, ${l}, b, row, col);\n      return ${i.texture2D}(${r}, uv);\n    }\n  `}function qa(e,t){const n=e.shapeInfo.logicalShape,r=e.name,a="get"+r.charAt(0).toUpperCase()+r.slice(1),s=n[1]*n[2],o=n[2],{newShape:i,keptDims:u}=c["util"].squeezeShape(n),l=i;if(l.length<n.length){const n=rs(e,l),r=["row","col","depth"];return`\n        ${ma(n,t)}\n        float ${a}(int row, int col, int depth) {\n          return ${a}(${as(r,u)});\n        }\n      `}if(e.shapeInfo.isUniform)return`\n      float ${a}(int row, int col, int depth) {\n        int index = round(dot(vec3(row, col, depth),\n                          vec3(${s}, ${o}, 1)));\n        ${Za(e)}\n      }\n    `;const d=e.shapeInfo.texShape,p=d[0],h=d[1],f=e.shapeInfo.flatOffset;if(h===s&&null==f)return t?`\n      float ${a}(int row, int col, int depth) {\n        int stride1 = ${r}Shape[2];\n        float texR = float(row);\n        float texC = dot(vec2(col, depth), vec2(stride1, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${r}TexShape[1], ${r}TexShape[0]);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n        float ${a}(int row, int col, int depth) {\n          float texR = float(row);\n          float texC = dot(vec2(col, depth), vec2(${o}, 1));\n          vec2 uv = (vec2(texC, texR) + halfCR) /\n                     vec2(${h}.0, ${p}.0);\n          return sampleTexture(${r}, uv);\n        }\n      `;if(h===o&&null==f)return t?`\n      float ${a}(int row, int col, int depth) {\n        float texR = dot(vec2(row, col), vec2(${r}Shape[1], 1));\n        float texC = float(depth);\n        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n    float ${a}(int row, int col, int depth) {\n      float texR = dot(vec2(row, col), vec2(${n[1]}, 1));\n      float texC = float(depth);\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${h}.0, ${p}.0);\n      return sampleTexture(${r}, uv);\n    }\n  `;const m=Pa(r);return t?`\n    float ${a}(int row, int col, int depth) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int stride0 = ${r}Shape[1] * ${r}Shape[2];\n      int stride1 = ${r}Shape[2];\n      int index = row * ${s} + col * ${o} + depth + ${m};\n      vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index);\n      return sampleTexture(${r}, uv);\n    }\n    `:`\n      float ${a}(int row, int col, int depth) {\n        // Explicitly use integer operations as dot() only works on floats.\n        int index = row * ${s} + col * ${o} + depth + ${m};\n        vec2 uv = uvFromFlat(${p}, ${h}, index);\n        return sampleTexture(${r}, uv);\n      }\n  `}function Ka(e,t){const n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),a=sa();if(t)return`\n    vec4 ${r}(int b2, int b, int row, int col) {\n      int valuesPerRow = int(ceil(float(${n}Shape[3]) / 2.0));\n      int texelsInBatch = valuesPerRow * int(ceil(float(${n}Shape[2]) / 2.0));\n      int index = b * texelsInBatch + (row / 2) * valuesPerRow + (col / 2);\n      texelsInBatch *= ${n}Shape[1];\n      index = b2 * texelsInBatch + index;\n      ivec2 packedTexShape = ivec2(ceil(float(${n}TexShape[0]) / 2.0), ceil(float(${n}TexShape[1]) / 2.0));\n      int texR = index / packedTexShape[1];\n      int texC = index - texR * packedTexShape[1];\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(packedTexShape[1], packedTexShape[0]); return ${a.texture2D}(${n}, uv);\n    }\n  `;const s=e.shapeInfo.logicalShape,o=s.length,i=e.shapeInfo.texShape,c=[Math.ceil(i[0]/2),Math.ceil(i[1]/2)],u=c[0],l=c[1],d=Math.ceil(s[o-1]/2);let p=d*Math.ceil(s[o-2]/2),h="int b, int row, int col",f=`b * ${p} + (row / 2) * ${d} + (col / 2)`;for(let m=2;m<o-1;m++)h=`int b${m}, `+h,p*=s[o-m-1],f=`b${m} * ${p} + `+f;return`\n    vec4 ${r}(${h}) {\n      int index = ${f};\n      int texR = index / ${l};\n      int texC = index - texR * ${l};\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${l}, ${u});\n      return ${a.texture2D}(${n}, uv);\n    }\n  `}function Xa(e,t){const n=e.shapeInfo.logicalShape,r=e.name,a="get"+r.charAt(0).toUpperCase()+r.slice(1),s=n[3],o=n[2]*s,i=n[1]*o,{newShape:u,keptDims:l}=c["util"].squeezeShape(n);if(u.length<n.length){const n=rs(e,u),r=["row","col","depth","depth2"];return`\n      ${ma(n,t)}\n      float ${a}(int row, int col, int depth, int depth2) {\n        return ${a}(${as(r,l)});\n      }\n    `}if(e.shapeInfo.isUniform)return`\n      float ${a}(int row, int col, int depth, int depth2) {\n        int index = round(dot(vec4(row, col, depth, depth2),\n                          vec4(${i}, ${o}, ${s}, 1)));\n        ${Za(e)}\n      }\n    `;const d=e.shapeInfo.flatOffset,p=e.shapeInfo.texShape,h=p[0],f=p[1],m=`int stride2 = ${r}Shape[3];`,b=`int stride1 = ${r}Shape[2] * stride2;`,g=`int stride0 = ${r}Shape[1] * stride1;`;if(f===i&&null==d)return t?`\n      float ${a}(int row, int col, int depth, int depth2) {\n        ${m}\n        ${b}\n        float texR = float(row);\n        float texC =\n            dot(vec3(col, depth, depth2),\n                vec3(stride1, stride2, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${r}TexShape[1], ${r}TexShape[0]);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n      float ${a}(int row, int col, int depth, int depth2) {\n        float texR = float(row);\n        float texC =\n            dot(vec3(col, depth, depth2),\n                vec3(${o}, ${s}, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${f}.0, ${h}.0);\n        return sampleTexture(${r}, uv);\n      }\n    `;if(f===s&&null==d)return t?`\n      float ${a}(int row, int col, int depth, int depth2) {\n        float texR = dot(vec3(row, col, depth),\n                         vec3(${r}Shape[1] * ${r}Shape[2], ${r}Shape[2], 1));\n        float texC = float(depth2);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${r}TexShape[1], ${r}TexShape[0]);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n      float ${a}(int row, int col, int depth, int depth2) {\n        float texR = dot(vec3(row, col, depth),\n                         vec3(${n[1]*n[2]}, ${n[2]}, 1));\n        float texC = float(depth2);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${f}.0, ${h}.0);\n        return sampleTexture(${r}, uv);\n      }\n    `;const y=Pa(r);return t?`\n    float ${a}(int row, int col, int depth, int depth2) {\n      // Explicitly use integer operations as dot() only works on floats.\n      ${m}\n      ${b}\n      ${g}\n      int index = row * stride0 + col * stride1 +\n          depth * stride2 + depth2;\n      vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index + ${y});\n      return sampleTexture(${r}, uv);\n    }\n  `:`\n    float ${a}(int row, int col, int depth, int depth2) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${i} + col * ${o} +\n          depth * ${s} + depth2;\n      vec2 uv = uvFromFlat(${h}, ${f}, index + ${y});\n      return sampleTexture(${r}, uv);\n    }\n  `}function Ya(e){const t=e.shapeInfo.logicalShape,n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),a=t[4],s=t[3]*a,o=t[2]*s,i=t[1]*o,{newShape:u,keptDims:l}=c["util"].squeezeShape(t);if(u.length<t.length){const t=rs(e,u),n=["row","col","depth","depth2","depth3"];return`\n      ${ma(t)}\n      float ${r}(int row, int col, int depth, int depth2, int depth3) {\n        return ${r}(${as(n,l)});\n      }\n    `}if(e.shapeInfo.isUniform)return`\n      float ${r}(int row, int col, int depth, int depth2, int depth3) {\n        float index = dot(\n          vec4(row, col, depth, depth2),\n          vec4(${i}, ${o}, ${s}, ${a})) +\n          depth3;\n        ${Za(e)}\n      }\n    `;const d=e.shapeInfo.flatOffset,p=e.shapeInfo.texShape,h=p[0],f=p[1];if(f===i&&null==d)return`\n      float ${r}(int row, int col, int depth, int depth2, int depth3) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n                         vec4(${o}, ${s}, ${a}, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${f}.0, ${h}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `;if(f===a&&null==d)return`\n      float ${r}(int row, int col, int depth, int depth2, int depth3) {\n        float texR = dot(\n          vec4(row, col, depth, depth2),\n          vec4(${t[1]*t[2]*t[3]},\n               ${t[2]*t[3]}, ${t[3]}, 1));\n        int texC = depth3;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${f}.0, ${h}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `;const m=Pa(n);return`\n    float ${r}(int row, int col, int depth, int depth2, int depth3) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${i} + col * ${o} + depth * ${s} +\n          depth2 * ${a} + depth3 + ${m};\n      vec2 uv = uvFromFlat(${h}, ${f}, index);\n      return sampleTexture(${n}, uv);\n    }\n  `}function Qa(e){const t=e.shapeInfo.logicalShape,n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),{newShape:a,keptDims:s}=c["util"].squeezeShape(t);if(a.length<t.length){const t=rs(e,a),n=["row","col","depth","depth2","depth3","depth4"];return`\n      ${ma(t)}\n      float ${r}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        return ${r}(${as(n,s)});\n      }\n    `}const o=t[5],i=t[4]*o,u=t[3]*i,l=t[2]*u,d=t[1]*l;if(e.shapeInfo.isUniform)return`\n      float ${r}(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n        int index = round(dot(\n          vec4(row, col, depth, depth2),\n          vec4(${d}, ${l}, ${u}, ${i})) +\n          dot(\n            vec2(depth3, depth4),\n            vec2(${o}, 1)));\n        ${Za(e)}\n      }\n    `;const p=e.shapeInfo.flatOffset,h=e.shapeInfo.texShape,f=h[0],m=h[1];if(m===d&&null==p)return`\n      float ${r}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n          vec4(${l}, ${u}, ${i}, ${o})) +\n               float(depth4);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${m}.0, ${f}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `;if(m===o&&null==p)return`\n      float ${r}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        float texR = dot(vec4(row, col, depth, depth2),\n          vec4(${t[1]*t[2]*t[3]*t[4]},\n               ${t[2]*t[3]*t[4]},\n               ${t[3]*t[4]},\n               ${t[4]})) + float(depth3);\n        int texC = depth4;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${m}.0, ${f}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `;const b=Pa(n);return`\n    float ${r}(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${d} + col * ${l} + depth * ${u} +\n          depth2 * ${i} + depth3 * ${o} + depth4 + ${b};\n      vec2 uv = uvFromFlat(${f}, ${m}, index);\n      return sampleTexture(${n}, uv);\n    }\n  `}function Za(e){const t=e.name,n=c["util"].sizeFromShape(e.shapeInfo.logicalShape);return n<2?`return ${t};`:`\n    for (int i = 0; i < ${n}; i++) {\n      if (i == index) {\n        return ${t}[i];\n      }\n    }\n  `}function Ja(e,t){const n=e.name,r=n.charAt(0).toUpperCase()+n.slice(1),a="get"+r+"AtOutCoords",s=e.shapeInfo.logicalShape.length,o=t.logicalShape.length,i=ha(e.shapeInfo.logicalShape,t.logicalShape),u=ts(o),l=o-s;let d;const p=["x","y","z","w","u","v"];d=0===s?"":o<2&&i.length>=1?"coords = 0;":i.map(e=>`coords.${p[e+l]} = 0;`).join("\n");let h="";h=o<2&&s>0?"coords":e.shapeInfo.logicalShape.map((e,t)=>"coords."+p[t+l]).join(", ");let f="return outputValue;";const m=c["util"].sizeFromShape(e.shapeInfo.logicalShape),b=1===m,g=c["util"].sizeFromShape(t.logicalShape),y=1===g;if(1!==s||b||y){if(b&&!y)f=1===o?"\n        return vec4(outputValue.x, outputValue.x, 0., 0.);\n      ":"\n        return vec4(outputValue.x);\n      ";else if(i.length){const e=s-2,t=s-1;i.indexOf(e)>-1&&i.indexOf(t)>-1?f="return vec4(outputValue.x);":i.indexOf(e)>-1?f="return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);":i.indexOf(t)>-1&&(f="return vec4(outputValue.xx, outputValue.zz);")}}else f="\n      return vec4(outputValue.xy, outputValue.xy);\n    ";return`\n    vec4 ${a}() {\n      ${u} coords = getOutputCoords();\n      ${d}\n      vec4 outputValue = get${r}(${h});\n      ${f}\n    }\n  `}function es(e,t){const n=e.name,r=n.charAt(0).toUpperCase()+n.slice(1),a="get"+r+"AtOutCoords",s=t.texShape,o=e.shapeInfo.texShape,i=e.shapeInfo.logicalShape.length,u=t.logicalShape.length;if(!e.shapeInfo.isUniform&&i===u&&null==e.shapeInfo.flatOffset&&c["util"].arraysEqual(o,s))return`\n      float ${a}() {\n        return sampleTexture(${n}, resultUV);\n      }\n    `;const l=ts(u),d=ha(e.shapeInfo.logicalShape,t.logicalShape),p=u-i;let h;const f=["x","y","z","w","u","v"];h=0===i?"":u<2&&d.length>=1?"coords = 0;":d.map(e=>`coords.${f[e+p]} = 0;`).join("\n");let m="";return m=u<2&&i>0?"coords":e.shapeInfo.logicalShape.map((e,t)=>"coords."+f[t+p]).join(", "),`\n    float ${a}() {\n      ${l} coords = getOutputCoords();\n      ${h}\n      return get${r}(${m});\n    }\n  `}function ts(e){if(e<=1)return"int";if(2===e)return"ivec2";if(3===e)return"ivec3";if(4===e)return"ivec4";if(5===e)return"ivec5";if(6===e)return"ivec6";throw Error(`GPU for rank ${e} is not yet supported`)}function ns(e,t,n){const{newShape:r,keptDims:a}=c["util"].squeezeShape(t),s=t.length,o=e&&3===s&&1===t[0],i=o?t.slice(1):r,u=!e&&s>1&&!c["util"].arraysEqual(t,n)&&r.length<s||o,l=u?i:t;return{useSqueezeShape:u,uniformShape:l,keptDims:a}}function rs(e,t){const n=JSON.parse(JSON.stringify(e));return n.shapeInfo.logicalShape=t,n}function as(e,t){return t.map(t=>e[t]).join(", ")}
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ss(e,t,n,r){const a=n.map((e,n)=>{const r={logicalShape:e.shape,texShape:e.isUniform?null:e.texData.texShape,isUniform:e.isUniform,isPacked:!e.isUniform&&e.texData.isPacked,flatOffset:null};return null!=e.texData&&null!=e.texData.slice&&e.texData.slice.flatOffset>0&&(r.flatOffset=e.texData.slice.flatOffset),{name:t.variableNames[n],shapeInfo:r}}),s=a.map(e=>e.shapeInfo),o={logicalShape:r.shape,texShape:r.texData.texShape,isUniform:!1,isPacked:r.texData.isPacked,flatOffset:null},i=fa(a,o,t),u=e.createProgram(i);let l=null;const d=e.getUniformLocation(u,"NAN",!1);1===Object(c["env"])().getNumber("WEBGL_VERSION")&&(l=e.getUniformLocation(u,"INFINITY",!1));const p=!1,h={},f={},m={};for(let c=0;c<t.variableNames.length;c++){const n=t.variableNames[c];h[n]=e.getUniformLocation(u,n,p),h["offset"+n]=e.getUniformLocation(u,"offset"+n,p),t.enableShapeUniforms&&(f[n+"Shape"]=e.getUniformLocation(u,n+"Shape",p),m[n+"TexShape"]=e.getUniformLocation(u,n+"TexShape",p))}let b,g,y;t.enableShapeUniforms&&(b=e.getUniformLocation(u,"outShape",p),y=e.getUniformLocation(u,"outShapeStrides",p),g=e.getUniformLocation(u,"outTexShape",p));const x=[];return t.customUniforms&&t.customUniforms.forEach((t,n)=>{x[n]=e.getUniformLocation(u,t.name,p)}),{program:t,source:i,webGLProgram:u,uniformLocations:h,customUniformLocations:x,inShapeInfos:s,outShapeInfo:o,infLoc:l,nanLoc:d,inShapesLocations:f,inTexShapesLocations:m,outShapeLocation:b,outShapeStridesLocation:y,outTexShapeLocation:g}}function os(e,t){if(e.length!==t.length)throw Error(`Binary was compiled with ${e.length} inputs, but was executed with ${t.length} inputs`);e.forEach((e,n)=>{const r=e.logicalShape,a=t[n],s=a.shape;if(!c["util"].arraysEqual(r,s))throw Error(`Binary was compiled with different shapes than the current args. Shapes ${r} and ${s} must match`);if(e.isUniform&&a.isUniform)return;const o=e.texShape,i=a.isUniform?null:a.texData.texShape;if(!c["util"].arraysEqual(o,i))throw Error(`Binary was compiled with different texture shapes than the current args. Shape ${o} and ${i} must match`)})}function is(e,t,n,r,a){t.program.enableShapeUniforms||(os(t.inShapeInfos,n),os([t.outShapeInfo],[r]));const s=r.texData.texture,o=r.texData.texShape;r.texData.isPacked?e.setOutputPackedMatrixTexture(s,o[0],o[1]):e.setOutputMatrixTexture(s,o[0],o[1]),e.setProgram(t.webGLProgram),1===Object(c["env"])().getNumber("WEBGL_VERSION")&&null!==t.infLoc&&e.gl.uniform1f(t.infLoc,1/0),null!==t.nanLoc&&e.gl.uniform1f(t.nanLoc,NaN),n.forEach((n,r)=>{const a=t.program.variableNames[r],s=t.uniformLocations[a],o=t.uniformLocations["offset"+a],i=t.inShapesLocations[a+"Shape"],u=t.inTexShapesLocations[a+"TexShape"];if(i){const{uniformShape:r}=ns(t.program.packedInputs,n.shape,n.texData.texShape);switch(r.length){case 1:e.gl.uniform1iv(i,new Int32Array(r));break;case 2:e.gl.uniform2iv(i,new Int32Array(r));break;case 3:e.gl.uniform3iv(i,new Int32Array(r));break;case 4:e.gl.uniform4iv(i,new Int32Array(r));break;default:break}}if(u&&e.gl.uniform2i(u,n.texData.texShape[0],n.texData.texShape[1]),null!=s)if(n.isUniform)if(c["util"].sizeFromShape(n.shape)<2)e.gl.uniform1f(s,n.uniformValues[0]);else{let t=n.uniformValues;t instanceof Float32Array||(t=new Float32Array(t)),e.gl.uniform1fv(s,t)}else null!=n.texData.slice&&null!=o&&e.gl.uniform1i(o,n.texData.slice.flatOffset),e.setInputMatrixTexture(n.texData.texture,s,r)});const i=t.outShapeLocation;if(i)switch(r.shape.length){case 1:e.gl.uniform1iv(i,new Int32Array(r.shape));break;case 2:e.gl.uniform2iv(i,new Int32Array(r.shape));break;case 3:e.gl.uniform3iv(i,new Int32Array(r.shape));break;case 4:e.gl.uniform4iv(i,new Int32Array(r.shape));break;default:break}if(t.outShapeStridesLocation){const n=c["util"].computeStrides(r.shape);switch(r.shape.length){case 2:e.gl.uniform1iv(t.outShapeStridesLocation,new Int32Array(n));break;case 3:e.gl.uniform2iv(t.outShapeStridesLocation,new Int32Array(n));break;case 4:e.gl.uniform3iv(t.outShapeStridesLocation,new Int32Array(n));break;default:break}}t.outTexShapeLocation&&e.gl.uniform2i(t.outTexShapeLocation,r.texData.texShape[0],r.texData.texShape[1]),t.program.customUniforms&&a&&t.program.customUniforms.forEach((n,r)=>{const s=t.customUniformLocations[r],o=a[r];if("float"===n.type)e.gl.uniform1fv(s,o);else if("vec2"===n.type)e.gl.uniform2fv(s,o);else if("vec3"===n.type)e.gl.uniform3fv(s,o);else if("vec4"===n.type)e.gl.uniform4fv(s,o);else if("int"===n.type)e.gl.uniform1iv(s,o);else if("ivec2"===n.type)e.gl.uniform2iv(s,o);else if("ivec3"===n.type)e.gl.uniform3iv(s,o);else{if("ivec4"!==n.type)throw Error(`uniform type ${n.type} is not supported yet.`);e.gl.uniform4iv(s,o)}}),e.executeProgram()}function cs(e,t,n){let r="";t.concat(n).forEach(t=>{const a=null!=t.texData&&null!=t.texData.slice&&t.texData.slice.flatOffset>0;if(e.enableShapeUniforms&&!t.isUniform){const s=t.texData.texShape,{useSqueezeShape:o,uniformShape:i,keptDims:u}=ns(e.packedInputs,t.shape,s);let l="",d="",p="";if(1===i.length&&e.packedInputs){const e=[Math.ceil(s[0]/2),Math.ceil(s[1]/2)];l=`${e[0]>1}_${e[1]>1}`}else if(2!==i.length||e.packedInputs){if(i.length>2&&!e.packedInputs){const e=c["util"].computeStrides(i);p=`${e[0]===s[1]}_${e[e.length-1]===s[1]}`}}else d=`${i[0]>1}_${i[1]>1}`;const h=t.shape.length,f=2===i.length&&c["util"].arraysEqual(t.shape,s),m=1===c["util"].sizeFromShape(t.shape),b=c["backend_util"].getBroadcastDims(t.shape,n.shape),g=!e.packedInputs&&h===n.shape.length&&c["util"].arraysEqual(s,n.texData.texShape),y=e.packedInputs||i.length>2?"":`${s[0]>1}_${s[1]>1}`;r+=`${h}_${g}_${o?u:""}_${i.length}_${m}_${b}_${f}_${l}_${d}_${p}_${y}_${a}`}else{const e=t.isUniform?"uniform":t.texData.texShape;r+=`${t.shape}_${e}_${a}`}});const a=e.userCode;let s=e.constructor.name;return s+="_"+r+"_"+a+Object(c["env"])().getNumber("WEBGL_VERSION"),s}function us(e){return Object(c["env"])().getBool("WEBGL_USE_SHAPES_UNIFORMS")&&e<=4}
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ls{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outPackingScheme=er.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const t=sa();this.outputShape=e,this.enableShapeUniforms=us(this.outputShape.length),this.userCode=`\n      ivec3 outCoordsFromFlatIndex(int index) {\n        ${this.enableShapeUniforms?ia(["r","c","d"],e):oa(["r","c","d"],e)}\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));\n        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getA(rc.x, rc.y, rc.z);\n        }\n\n        ${t.output} = result;\n      }\n    `}}
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ds{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outPackingScheme=er.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const t=sa();this.outputShape=e,this.enableShapeUniforms=us(this.outputShape.length),this.userCode=`\n      ivec3 outCoordsFromFlatIndex(int index) {\n        ${this.enableShapeUniforms?ia(["r","c","d"],e):oa(["r","c","d"],e)}\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));\n        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));\n        }\n\n        ${t.output} = result;\n      }\n    `}}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ps{constructor(e){this.variableNames=["A"],this.outTexUsage=tr.DOWNLOAD;const t=sa();this.outputShape=e,this.userCode=`\n      ${pa}\n\n      void main() {\n        float x = getAAtOutCoords();\n        ${t.output} = encode_float(x);\n      }\n    `}}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class hs{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outTexUsage=tr.DOWNLOAD;const t=sa();this.outputShape=e,this.userCode=`\n      ${pa}\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));\n        ${t.output} = encode_float(x);\n      }\n    `}}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class fs{constructor(e,t=!1){this.variableNames=["A"],this.customUniforms=[{name:"texShape",type:"ivec2"}];const n=sa();this.outputShape=e,this.enableShapeUniforms=us(this.outputShape.length);let r="result";t&&(r="floor(result * 255. + 0.5)"),this.userCode=`\n      ${this.enableShapeUniforms?da():la(e)}\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n\n        int flatIndex = getFlatIndex(coords);\n        int offset = imod(flatIndex, 4);\n\n        flatIndex = idiv(flatIndex, 4, 1.);\n\n        int r = flatIndex / texShape[1];\n        int c = imod(flatIndex, texShape[1]);\n        vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);\n        vec4 values = ${n.texture2D}(A, uv);\n\n        float result;\n\n        if(offset == 0) {\n          result = values[0];\n        } else if(offset == 1) {\n          result = values[1];\n        } else if(offset == 2) {\n          result = values[2];\n        } else {\n          result = values[3];\n        }\n\n        ${n.output} = vec4(${r}, 0., 0., 0.);\n      }\n    `}}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ms{constructor(e,t=!1){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.customUniforms=[{name:"texShape",type:"ivec2"}];const n=sa();this.outputShape=e,this.enableShapeUniforms=us(this.outputShape.length);let r="",a="result";t&&(a="floor(result * 255. + 0.5)");for(let s=0;s<=1;s++)for(let t=0;t<=1;t++){const a=2*s+t;r+=`\n          localCoords = coords;\n          if(localCoords[2] + ${t} < ${this.enableShapeUniforms?"outShape[2]":""+e[2]}) {\n          localCoords[2] += ${t};\n          if (localCoords[1] + ${s} < ${this.enableShapeUniforms?"outShape[1]":""+e[1]}) {\n            localCoords[1] += ${s};\n\n            flatIndex = getFlatIndex(localCoords);\n            offset = imod(flatIndex, 4);\n\n            flatIndex = idiv(flatIndex, 4, 1.);\n\n            int r = flatIndex / texShape[1];\n            int c = imod(flatIndex, texShape[1]);\n            vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);\n            values = ${n.texture2D}(A, uv);\n\n            if (offset == 0) {\n              result[${a}] = values[0];\n            } else if (offset == 1) {\n              result[${a}] = values[1];\n            } else if (offset == 2) {\n              result[${a}] = values[2];\n            } else {\n              result[${a}] = values[3];\n            }\n          }\n        }\n        `}this.userCode=`\n        ${this.enableShapeUniforms?da():la(e)}\n\n        void main() {\n          ivec3 coords = getOutputCoords();\n\n          vec4 result = vec4(0.);\n          int flatIndex, r, c, offset;\n          ivec3 localCoords;\n          vec2 uv;\n          vec4 values;\n\n          ${r}\n\n          ${n.output} = ${a};\n        }\n    `}}
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bs(e){const t=sa(),n=`${t.version}\n    precision highp float;\n    ${t.attribute} vec3 clipSpacePos;\n    ${t.attribute} vec2 uv;\n    ${t.varyingVs} vec2 resultUV;\n\n    void main() {\n      gl_Position = vec4(clipSpacePos, 1);\n      resultUV = uv;\n    }`;return br(e,n)}function gs(e){const t=new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0]);return kr(e,t)}function ys(e){const t=new Uint16Array([0,1,2,2,1,3]);return jr(e,t)}function xs(e,t,n,r,a,s){Nr(t,n);const o=Sr(e),i=e.TEXTURE_2D;return ur(e,()=>e.bindTexture(i,o)),ur(e,()=>e.texParameteri(i,e.TEXTURE_WRAP_S,e.CLAMP_TO_EDGE)),ur(e,()=>e.texParameteri(i,e.TEXTURE_WRAP_T,e.CLAMP_TO_EDGE)),ur(e,()=>e.texParameteri(i,e.TEXTURE_MIN_FILTER,e.NEAREST)),ur(e,()=>e.texParameteri(i,e.TEXTURE_MAG_FILTER,e.NEAREST)),ur(e,()=>e.texImage2D(i,0,r,t,n,0,a,s,null)),ur(e,()=>e.bindTexture(e.TEXTURE_2D,null)),o}function Os(e){return e.internalFormatFloat}function vs(e,t,n,r){const[a,s]=rr(t,n);return xs(e,a,s,Os(r),r.textureFormatFloat,e.FLOAT)}function ws(e){return e.internalFormatHalfFloat}function ks(e,t,n,r){const[a,s]=rr(t,n);return xs(e,a,s,ws(r),r.textureFormatFloat,r.textureTypeHalfFloat)}function js(e){return e.downloadTextureFormat}function Ss(e,t,n,r){const[a,s]=rr(t,n);return xs(e,a,s,js(r),e.RGBA,e.UNSIGNED_BYTE)}function Ns(e){return e.internalFormatPackedFloat}function Cs(e,t,n,r){const[a,s]=or(t,n);return xs(e,a,s,Ns(r),e.RGBA,e.FLOAT)}function Is(e){return e.internalFormatPackedHalfFloat}function Ts(e,t,n,r){const[a,s]=or(t,n);return xs(e,a,s,Is(r),e.RGBA,r.textureTypeHalfFloat)}function $s(e,t,n){const r=0,a=12,s=20;ur(e,()=>e.bindBuffer(e.ARRAY_BUFFER,n));const o=Ir(e,t,"clipSpacePos",n,3,s,r);return o&&Ir(e,t,"uv",n,2,s,a)}function Es(e,t,n,r,a,s){let o,i,c;ur(e,()=>e.bindTexture(e.TEXTURE_2D,t)),a instanceof Uint8Array?(o=new Uint8Array(n*r*4),i=e.UNSIGNED_BYTE,c=e.RGBA):(o=new Float32Array(n*r*4),i=e.FLOAT,c=s.internalFormatPackedFloat),o.set(a),ur(e,()=>e.texImage2D(e.TEXTURE_2D,0,c,n,r,0,e.RGBA,i,o)),ur(e,()=>e.bindTexture(e.TEXTURE_2D,null))}function As(e,t,n){ur(e,()=>e.bindTexture(e.TEXTURE_2D,t)),n.data instanceof Uint8Array?ur(e,()=>e.texImage2D(e.TEXTURE_2D,0,e.RGBA,n.width,n.height,0,e.RGBA,e.UNSIGNED_BYTE,n.data)):ur(e,()=>e.texImage2D(e.TEXTURE_2D,0,e.RGBA,e.RGBA,e.UNSIGNED_BYTE,n)),ur(e,()=>e.bindTexture(e.TEXTURE_2D,null))}function Rs(e,t,n,r){const a=e.createBuffer();ur(e,()=>e.bindBuffer(e.PIXEL_PACK_BUFFER,a));const s=4,o=4,i=s*o*t*n;return ur(e,()=>e.bufferData(e.PIXEL_PACK_BUFFER,i,e.STREAM_READ)),ur(e,()=>e.readPixels(0,0,n,t,e.RGBA,e.FLOAT,0)),ur(e,()=>e.bindBuffer(e.PIXEL_PACK_BUFFER,null)),a}function _s(e,t,n){const r=e,a=new Float32Array(n);return r.bindBuffer(r.PIXEL_PACK_BUFFER,t),r.getBufferSubData(r.PIXEL_PACK_BUFFER,0,a),r.bindBuffer(r.PIXEL_PACK_BUFFER,null),a}function Fs(e,t,n,r){const[a,s]=rr(t,n),o=4,i=new Uint8Array(ar(t*n,o));return ur(e,()=>e.readPixels(0,0,a,s,r.downloadTextureFormat,e.UNSIGNED_BYTE,i)),new Float32Array(i.buffer)}function Ds(e,t,n,r,a,s,o,i){const c=e,u=new Float32Array(ir(s,o));return c.bindBuffer(c.PIXEL_PACK_BUFFER,t),c.getBufferSubData(c.PIXEL_PACK_BUFFER,0,u),c.bindBuffer(c.PIXEL_PACK_BUFFER,null),u}function Ms(e,t,n){const r=new Float32Array(t*n*4);return ur(e,()=>e.readPixels(0,0,n,t,e.RGBA,e.FLOAT,r)),r}
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Ls{constructor(e){this.outputTexture=null,this.program=null,this.disposed=!1,this.vertexAttrsAreBound=!1,this.itemsToPoll=[];const t=Object(c["env"])().getNumber("WEBGL_VERSION");null!=e?(this.gl=e,Yn(t,e)):this.gl=Qn(t);let n="WEBGL_color_buffer_float";const r="EXT_color_buffer_half_float";if(1===Object(c["env"])().getNumber("WEBGL_VERSION")){const e="OES_texture_float",t="OES_texture_half_float";if(this.textureFloatExtension=mr(this.gl,e),Yr(this.gl,t))this.textureHalfFloatExtension=mr(this.gl,t);else if(Object(c["env"])().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");if(this.colorBufferFloatExtension=this.gl.getExtension(n),Yr(this.gl,r))this.colorBufferHalfFloatExtension=mr(this.gl,r);else if(Object(c["env"])().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.")}else if(n="EXT_color_buffer_float",Yr(this.gl,n))this.colorBufferFloatExtension=this.gl.getExtension(n);else{if(!Yr(this.gl,r))throw new Error("GL context does not support color renderable floats");this.colorBufferHalfFloatExtension=this.gl.getExtension(r)}this.vertexBuffer=gs(this.gl),this.indexBuffer=ys(this.gl),this.framebuffer=Cr(this.gl),this.textureConfig=cr(this.gl,this.textureHalfFloatExtension)}get debug(){return Object(c["env"])().getBool("DEBUG")}dispose(){if(this.disposed)return;null!=this.program&&console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing."),null!=this.outputTexture&&console.warn("Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.");const e=this.gl;ur(e,()=>e.finish()),ur(e,()=>e.bindFramebuffer(e.FRAMEBUFFER,null)),ur(e,()=>e.deleteFramebuffer(this.framebuffer)),ur(e,()=>e.bindBuffer(e.ARRAY_BUFFER,null)),ur(e,()=>e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,null)),ur(e,()=>e.deleteBuffer(this.indexBuffer)),this.disposed=!0}createFloat32MatrixTexture(e,t){return this.throwIfDisposed(),vs(this.gl,e,t,this.textureConfig)}createFloat16MatrixTexture(e,t){return this.throwIfDisposed(),ks(this.gl,e,t,this.textureConfig)}createUnsignedBytesMatrixTexture(e,t){return this.throwIfDisposed(),Ss(this.gl,e,t,this.textureConfig)}uploadPixelDataToTexture(e,t){this.throwIfDisposed(),As(this.gl,e,t)}uploadDenseMatrixToTexture(e,t,n,r){this.throwIfDisposed(),Es(this.gl,e,t,n,r,this.textureConfig)}createFloat16PackedMatrixTexture(e,t){return this.throwIfDisposed(),Ts(this.gl,e,t,this.textureConfig)}createPackedMatrixTexture(e,t){return this.throwIfDisposed(),Cs(this.gl,e,t,this.textureConfig)}deleteMatrixTexture(e){this.throwIfDisposed(),this.outputTexture===e&&(_r(this.gl,this.framebuffer),this.outputTexture=null),ur(this.gl,()=>this.gl.deleteTexture(e))}downloadByteEncodedFloatMatrixFromOutputTexture(e,t,n){return this.downloadMatrixDriver(e,()=>Fs(this.gl,t,n,this.textureConfig))}downloadPackedMatrixFromBuffer(e,t,n,r,a,s){return Ds(this.gl,e,t,n,r,a,s,this.textureConfig)}downloadFloat32MatrixFromBuffer(e,t){return _s(this.gl,e,t)}createBufferFromTexture(e,t,n){this.bindTextureToFrameBuffer(e);const r=Rs(this.gl,t,n,this.textureConfig);return this.unbindTextureToFrameBuffer(),r}createAndWaitForFence(){const e=this.createFence(this.gl);return this.pollFence(e)}createFence(e){let t,n;if(Object(c["env"])().getBool("WEBGL_FENCE_API_ENABLED")){const r=e,a=r.fenceSync(r.SYNC_GPU_COMMANDS_COMPLETE,0);e.flush(),n=()=>{const e=r.clientWaitSync(a,0,0);return e===r.ALREADY_SIGNALED||e===r.CONDITION_SATISFIED},t=a}else Object(c["env"])().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0?(t=this.beginQuery(),this.endQuery(),n=()=>this.isQueryAvailable(t,Object(c["env"])().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))):n=()=>!0;return{query:t,isFencePassed:n}}downloadMatrixFromPackedTexture(e,t,n){return this.downloadMatrixDriver(e,()=>Ms(this.gl,t,n))}createProgram(e){this.throwIfDisposed();const t=this.gl,n=gr(t,e);null==this.vertexShader&&(this.vertexShader=bs(t));const r=Or(t);return ur(t,()=>t.attachShader(r,this.vertexShader)),ur(t,()=>t.attachShader(r,n)),vr(t,r),this.debug&&wr(t,r),this.vertexAttrsAreBound||(this.setProgram(r),this.vertexAttrsAreBound=$s(t,this.program,this.vertexBuffer)),r}deleteProgram(e){this.throwIfDisposed(),e===this.program&&(this.program=null),null!=e&&ur(this.gl,()=>this.gl.deleteProgram(e))}setProgram(e){this.throwIfDisposed(),this.program=e,null!=this.program&&this.debug&&wr(this.gl,this.program),ur(this.gl,()=>this.gl.useProgram(e))}getUniformLocation(e,t,n=!0){return this.throwIfDisposed(),n?$r(this.gl,e,t):Er(this.gl,e,t)}getAttributeLocation(e,t){return this.throwIfDisposed(),ur(this.gl,()=>this.gl.getAttribLocation(e,t))}getUniformLocationNoThrow(e,t){return this.throwIfDisposed(),this.gl.getUniformLocation(e,t)}setInputMatrixTexture(e,t,n){this.throwIfDisposed(),this.throwIfNoProgram(),Ar(this.gl,e,t,n)}setOutputMatrixTexture(e,t,n){this.setOutputMatrixTextureDriver(e,n,t)}setOutputPackedMatrixTexture(e,t,n){this.throwIfDisposed();const[r,a]=or(t,n);this.setOutputMatrixTextureDriver(e,r,a)}setOutputMatrixWriteRegion(e,t,n,r){this.setOutputMatrixWriteRegionDriver(n,e,r,t)}setOutputPackedMatrixWriteRegion(e,t,n,r){throw new Error("setOutputPackedMatrixWriteRegion not implemented.")}debugValidate(){null!=this.program&&wr(this.gl,this.program),Fr(this.gl)}executeProgram(){this.throwIfDisposed(),this.throwIfNoProgram();const e=this.gl;this.debug&&this.debugValidate(),ur(e,()=>e.drawElements(e.TRIANGLES,6,e.UNSIGNED_SHORT,0))}blockUntilAllProgramsCompleted(){this.throwIfDisposed(),ur(this.gl,()=>this.gl.finish())}getQueryTimerExtension(){return null==this.disjointQueryTimerExtension&&(this.disjointQueryTimerExtension=mr(this.gl,2===Object(c["env"])().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")?"EXT_disjoint_timer_query_webgl2":"EXT_disjoint_timer_query")),this.disjointQueryTimerExtension}getQueryTimerExtensionWebGL2(){return this.getQueryTimerExtension()}getQueryTimerExtensionWebGL1(){return this.getQueryTimerExtension()}beginQuery(){if(2===Object(c["env"])().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")){const e=this.gl,t=this.getQueryTimerExtensionWebGL2(),n=e.createQuery();return e.beginQuery(t.TIME_ELAPSED_EXT,n),n}const e=this.getQueryTimerExtensionWebGL1(),t=e.createQueryEXT();return e.beginQueryEXT(e.TIME_ELAPSED_EXT,t),t}endQuery(){if(2===Object(c["env"])().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")){const e=this.gl,t=this.getQueryTimerExtensionWebGL2();return void e.endQuery(t.TIME_ELAPSED_EXT)}const e=this.getQueryTimerExtensionWebGL1();e.endQueryEXT(e.TIME_ELAPSED_EXT)}async waitForQueryAndGetTime(e){return await c["util"].repeatedTry(()=>this.disposed||this.isQueryAvailable(e,Object(c["env"])().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))),this.getQueryTime(e,Object(c["env"])().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))}getQueryTime(e,t){if(0===t)return null;if(2===t){const t=this.gl,n=t.getQueryParameter(e,t.QUERY_RESULT);return n/1e6}{const t=this.getQueryTimerExtensionWebGL1(),n=t.getQueryObjectEXT(e,t.QUERY_RESULT_EXT);return n/1e6}}isQueryAvailable(e,t){if(0===t)return!0;if(2===t){const t=this.gl,n=this.getQueryTimerExtensionWebGL2(),r=t.getQueryParameter(e,t.QUERY_RESULT_AVAILABLE);return null==this.disjoint&&(this.disjoint=this.gl.getParameter(n.GPU_DISJOINT_EXT)),r&&!this.disjoint}{const t=this.getQueryTimerExtensionWebGL1(),n=t.getQueryObjectEXT(e,t.QUERY_RESULT_AVAILABLE_EXT);return null==this.disjoint&&(this.disjoint=this.gl.getParameter(t.GPU_DISJOINT_EXT)),n&&!this.disjoint}}pollFence(e){return new Promise(t=>{this.addItemToPoll(()=>e.isFencePassed(),()=>t())})}pollItems(){const e=Ps(this.itemsToPoll.map(e=>e.isDoneFn));for(let t=0;t<=e;++t){const{resolveFn:e}=this.itemsToPoll[t];e()}this.itemsToPoll=this.itemsToPoll.slice(e+1)}addItemToPoll(e,t){this.itemsToPoll.push({isDoneFn:e,resolveFn:t}),this.itemsToPoll.length>1||c["util"].repeatedTry(()=>(this.pollItems(),0===this.itemsToPoll.length))}bindTextureToFrameBuffer(e){this.throwIfDisposed(),Rr(this.gl,e,this.framebuffer),this.debug&&Fr(this.gl)}unbindTextureToFrameBuffer(){null!=this.outputTexture?(Rr(this.gl,this.outputTexture,this.framebuffer),this.debug&&Fr(this.gl)):_r(this.gl,this.framebuffer)}downloadMatrixDriver(e,t){this.bindTextureToFrameBuffer(e);const n=t();return this.unbindTextureToFrameBuffer(),n}setOutputMatrixTextureDriver(e,t,n){this.throwIfDisposed();const r=this.gl;Rr(r,e,this.framebuffer),this.debug&&Fr(r),this.outputTexture=e,ur(r,()=>r.viewport(0,0,t,n)),ur(r,()=>r.scissor(0,0,t,n))}setOutputMatrixWriteRegionDriver(e,t,n,r){this.throwIfDisposed(),ur(this.gl,()=>this.gl.scissor(e,t,n,r))}throwIfDisposed(){if(this.disposed)throw new Error("Attempted to use disposed GPGPUContext.")}throwIfNoProgram(){if(null==this.program)throw new Error("No GPU program is currently set.")}}function Ps(e){let t=0;for(;t<e.length;++t){const n=e[t]();if(!n)break}return t-1}
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Bs(e,t){Array.isArray(e)||(e=[e]),e.forEach(e=>{null!=e&&c["util"].assert("complex64"!==e.dtype,()=>t+" does not support complex64 tensors in the CPU backend.")})}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Vs(e){const t=new Float32Array(e.length);for(let n=0;n<e.length;++n)t[n]=Math.abs(e[n]);return t}const zs=e=>{const{x:t}=e.inputs,n=e.backend;Bs(t,"abs");let r=new Float32Array(c["util"].sizeFromShape(t.shape));const a=n.data.get(t.dataId).values;return r=Vs(a),n.makeOutput(r,t.shape,"float32")};c["Abs"];
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Ws(e){return(t,n,r,a,s)=>{const o=c["backend_util"].assertAndGetBroadcastShape(t,n),i=o.length,u=c["util"].computeStrides(o),l=c["util"].sizeFromShape(o),d=c["util"].getTypedArrayFromDType(s,l),p=t.length,h=n.length,f=c["util"].computeStrides(t),m=c["util"].computeStrides(n),b=c["backend_util"].getBroadcastDims(t,o),g=c["backend_util"].getBroadcastDims(n,o);if(b.length+g.length===0)for(let c=0;c<d.length;++c)d[c]=e(r[c%r.length],a[c%a.length]);else for(let y=0;y<d.length;++y){const t=c["util"].indexToLoc(y,i,u),n=t.slice(-p);b.forEach(e=>n[e]=0);const s=c["util"].locToIndex(n,p,f),o=t.slice(-h);g.forEach(e=>o[e]=0);const l=c["util"].locToIndex(o,h,m);d[y]=e(r[s],a[l])}return[d,o]}}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Us(e){const{inputs:t,backend:n}=e,{real:r,imag:a}=t,s=n.data.get(r.dataId).values,o=n.data.get(a.dataId).values,i=n.makeTensorInfo(r.shape,"complex64"),c=n.data.get(i.dataId);return c.complexTensorInfos={real:n.makeTensorInfo(r.shape,"float32",s),imag:n.makeTensorInfo(a.shape,"float32",o)},i}c["Complex"];
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Gs(e,t,n="float32"){if("complex64"===n){const n=Gs(e,t,"float32"),r=Gs(e,t,"float32");return Us({inputs:{real:n,imag:r},backend:e})}const r=c["util"].makeZerosTypedArray(c["util"].sizeFromShape(t),n);return e.makeTensorInfo(t,n,r)}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Hs(e){const{inputs:t,backend:n}=e,{x:r}=t;return n.incRef(r.dataId),{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}c["Identity"];
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qs(e){const{inputs:t,backend:n}=e,{input:r}=t,a=n.data.get(r.dataId).complexTensorInfos.real,s=n.data.get(a.dataId).values;return n.makeTensorInfo(a.shape,a.dtype,s)}c["Real"];
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ks(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{dtype:s}=r;if("complex64"===s){if("complex64"===a.dtype)return Hs({inputs:{x:a},backend:n});const e=Gs(n,a.shape,a.dtype),t=Ks({inputs:{x:a},backend:n,attrs:{dtype:"float32"}}),r=Us({inputs:{real:t,imag:e},backend:n});return n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(t),r}if("complex64"===a.dtype){const e=qs({inputs:{input:a},backend:n}),t=Ks({inputs:{x:e},backend:n,attrs:{dtype:s}});return n.disposeIntermediateTensorInfo(e),t}if(!c["util"].hasEncodingLoss(a.dtype,s)){const e=Hs({inputs:{x:a},backend:n});return{dataId:e.dataId,shape:e.shape,dtype:s}}if("int32"===s){const e=n.data.get(a.dataId).values,t=Int32Array.from(e);return n.makeTensorInfo(a.shape,"int32",t)}if("bool"===s){const e=n.data.get(a.dataId).values,t=c["util"].toTypedArray([0],a.dtype),[r,s]=Ws((e,t)=>e!==t?1:0)(a.shape,[],e,t,"bool");return n.makeTensorInfo(s,"bool",r)}throw new Error(`Error in Cast: failed to cast ${a.dtype} to ${s}`)}c["Cast"];
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Xs(e,t,n,r){return null==n?({inputs:n,backend:a})=>{const{a:s,b:o}=n,i=a;Bs([s,o],e);const u=i.data.get(s.dataId).values,l=i.data.get(o.dataId).values,d="string"===s.dtype?c["backend_util"].fromUint8ToStringArray(u):u,p="string"===s.dtype?c["backend_util"].fromUint8ToStringArray(l):l,h=r||s.dtype,[f,m]=t(s.shape,o.shape,d,p,h);return i.makeTensorInfo(m,h,f)}:({inputs:e,backend:a})=>{const{a:s,b:o}=e,i=a;if("complex64"===s.dtype||"complex64"===o.dtype){const e=Ks({inputs:{x:s},backend:i,attrs:{dtype:"complex64"}}),t=i.data.get(e.dataId),r=t.complexTensorInfos.real,a=t.complexTensorInfos.imag,c=i.data.get(r.dataId).values,u=i.data.get(a.dataId).values,l=Ks({inputs:{x:o},backend:i,attrs:{dtype:"complex64"}}),d=i.data.get(l.dataId),p=d.complexTensorInfos.real,h=d.complexTensorInfos.imag,f=i.data.get(p.dataId).values,m=i.data.get(h.dataId).values,[b,g,y]=n(s.shape,o.shape,c,u,f,m),x=i.makeTensorInfo(y,"float32",b),O=i.makeTensorInfo(y,"float32",g),v=Us({inputs:{real:x,imag:O},backend:i});return i.disposeIntermediateTensorInfo(e),i.disposeIntermediateTensorInfo(l),i.disposeIntermediateTensorInfo(x),i.disposeIntermediateTensorInfo(O),v}{const e=i.data.get(s.dataId).values,n=i.data.get(o.dataId).values,a=r||s.dtype,[c,u]=t(s.shape,o.shape,e,n,a);return i.makeTensorInfo(u,a,c)}}}function Ys(e){return(t,n,r,a,s,o)=>{const i=c["backend_util"].assertAndGetBroadcastShape(t,n),u=c["util"].sizeFromShape(i),l=i.length,d=c["util"].computeStrides(i),p=c["util"].getTypedArrayFromDType("float32",u),h=c["util"].getTypedArrayFromDType("float32",u),f=c["backend_util"].getBroadcastDims(t,i),m=c["backend_util"].getBroadcastDims(n,i),b=c["backend_util"].mergeRealAndImagArrays(r,a),g=c["backend_util"].mergeRealAndImagArrays(s,o),y=t.length,x=c["util"].computeStrides(t),O=n.length,v=c["util"].computeStrides(n);if(f.length+m.length===0)for(let c=0;c<p.length;c++){const t=c%b.length,n=c%g.length,r=e(b[2*t],b[2*t+1],g[2*n],g[2*n+1]);p[c]=r.real,h[c]=r.imag}else for(let w=0;w<p.length;w++){const t=c["util"].indexToLoc(w,l,d),n=t.slice(-y);f.forEach(e=>n[e]=0);const r=c["util"].locToIndex(n,y,x),a=t.slice(-O);m.forEach(e=>a[e]=0);const s=c["util"].locToIndex(a,O,v),o=e(b[2*r],b[2*r+1],g[2*s],g[2*s+1]);p[w]=o.real,h[w]=o.imag}return[p,h,i]}}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Qs=Ws((e,t)=>e+t),Zs=Ys((e,t,n,r)=>({real:e+n,imag:t+r})),Js=Xs(c["Add"],Qs,Zs);c["Add"];
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function eo(e,t,n,r,a){const s=c["util"].sizeFromShape(r),o=c["util"].makeZerosTypedArray(a,n);for(let i=0;i<e.length;i++){const n=e[i];if(n<0)throw new Error("Input x must be non-negative!");n>=a||(o[n]+=s>0?t[i]:1)}return o}function to(e,t,n,r=!1){const a=e.shape[0],s=e.shape[1],o=Object(c["buffer"])([a,n],t.dtype);for(let i=0;i<a;i++)for(let a=0;a<s;a++){const s=e.get(i,a);if(s<0)throw new Error("Input x must be non-negative!");s>=n||(r?o.set(1,i,s):t.size>0?o.set(o.get(i,s)+t.get(i,a),i,s):o.set(o.get(i,s)+1,i,s))}return o}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function no(e){return(t,n,r)=>{const a=c["util"].getTypedArrayFromDType(n,t.length);for(let s=0;s<t.length;++s)a[s]=e(t[s],r);return a}}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ro(e,t,n){return({inputs:r,attrs:a,backend:s})=>{const{x:o}=r;if(Bs(o,e),"string"===o.dtype||"string"===n)throw new Error("unaryKernelFunc does not support string input/output");const i=s,u=i.data.get(o.dataId).values,l=c["util"].sizeFromShape(o.shape),d=n||o.dtype,p=c["util"].getArrayFromDType(d,l);for(let e=0;e<l;++e)p[e]=t(u[e],a);return i.makeTensorInfo(o.shape,d,p)}}function ao(e,t,n){return({inputs:r,attrs:a,backend:s})=>{const{x:o}=r;if(Bs(o,e),"string"===o.dtype||"string"===n)throw new Error("unaryKernelFunc does not support string input/output");const i=s,c=i.data.get(o.dataId).values,u=n||o.dtype,l=t(c,u,a);return i.makeTensorInfo(o.shape,u,l)}}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const so=no(e=>Math.ceil(e)),oo=ao(c["Ceil"],so);c["Ceil"];
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function io(e,t,n,r){const a=c["util"].getArrayFromDType(n,c["util"].sizeFromShape(t));if(r&&"string"!==n){let t=0;e.forEach(e=>{const n=c["util"].sizeFromShape(e.shape);a.set(e.vals,t),t+=n})}else{let r=0;e.forEach(e=>{const s="string"===n?c["backend_util"].fromUint8ToStringArray(e.vals):e.vals;let o=0;for(let n=0;n<e.shape[0];++n){const i=n*t[1]+r;for(let t=0;t<e.shape[1];++t)a[i+t]=s[o++]}r+=e.shape[1]})}return a}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const co=Ws((e,t)=>e===t?1:0),uo=Xs(c["Equal"],co,null,"bool"),lo=(c["Equal"],no(e=>Math.exp(e))),po=ao(c["Exp"],lo),ho=(c["Exp"],no(e=>Math.expm1(e))),fo=ao(c["Expm1"],ho),mo=(c["Expm1"],no(e=>Math.floor(e))),bo=ao(c["Floor"],mo);c["Floor"];
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function go(e,t,n,r,a,s,o,i,u){const l=Object(c["buffer"])([r,s],n);for(let c=0;c<r;c++){const n=[];let r=0;for(let t=0;t<a;t++){const s=e[c*a+t];r+=s*o[t],n.push(s)}if(r<0||r>=u/s)throw new Error(`Invalid indices: ${n} does not index into ${i}`);for(let e=0;e<s;e++)l.values[c*s+e]=t.get(...t.indexToLoc(r*s+e))}return l}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yo(e,t,n){const r=Object(c["buffer"])(n,e.dtype);for(let a=0;a<r.size;++a){const n=r.indexToLoc(a),s=n.slice(),o=s[0],i=s[2],c=t.locToIndex([o,i]);s[2]=t.values[c];const u=e.locToIndex(s);r.values[a]=e.values[u]}return r}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const xo=Ws((e,t)=>e>t?1:0),Oo=Xs(c["Greater"],xo,null,"bool"),vo=(c["Greater"],Ws((e,t)=>e>=t?1:0)),wo=Xs(c["GreaterEqual"],vo,null,"bool"),ko=(c["GreaterEqual"],Ws((e,t)=>e<t?1:0)),jo=Xs(c["Less"],ko,null,"bool"),So=(c["Less"],Ws((e,t)=>e<=t?1:0)),No=Xs(c["LessEqual"],So,null,"bool");c["LessEqual"];
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Co(e,t,n){const r=(t-e)/(n-1),a=c["util"].makeZerosTypedArray(n,"float32");a[0]=e;for(let s=1;s<a.length;s++)a[s]=a[s-1]+r;return a}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Io=no(e=>Math.log(e)),To=ao(c["Log"],Io);c["Log"];
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function $o(e,t,n,r){const a=c["util"].getTypedArrayFromDType(r,c["util"].sizeFromShape(n));for(let s=0;s<a.length;++s){const n=s*t;let r=e[n];for(let a=0;a<t;++a){const t=e[n+a];(Number.isNaN(t)||t>r)&&(r=t)}a[s]=r}return a}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Eo=Ws((e,t)=>Math.max(e,t)),Ao=Xs(c["Maximum"],Eo),Ro=(c["Maximum"],Ws((e,t)=>Math.min(e,t))),_o=Xs(c["Minimum"],Ro),Fo=(c["Minimum"],Ws((e,t)=>e*t)),Do=Ys((e,t,n,r)=>({real:e*n-t*r,imag:e*r+t*n})),Mo=Xs(c["Multiply"],Fo,Do);c["Multiply"];
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Lo(e,t,n){const r=c["util"].createScalarValue(-1,n);return Fo([],t,r,e,n)}function Po(e){const{inputs:t,backend:n}=e,{x:r}=t;Bs(r,"neg");const a=n.data.get(r.dataId).values,[s,o]=Lo(a,r.shape,r.dtype);return n.makeTensorInfo(o,r.dtype,s)}c["Neg"];
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Bo=Ws((e,t)=>e!==t?1:0),Vo=Xs(c["NotEqual"],Bo,null,"bool");c["NotEqual"];
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function zo(e,t,n,r,a){const s=t.length,o=c["util"].sizeFromShape(t),i=c["util"].computeStrides(t),u=c["util"].computeStrides(a),l=c["util"].getTypedArrayFromDType(n,c["util"].sizeFromShape(a));for(let d=0;d<o;++d){const t=c["util"].indexToLoc(d,s,i),n=new Array(t.length);for(let e=0;e<n.length;e++)n[e]=t[r[e]];const a=c["util"].locToIndex(n,s,u);l[a]=e[d]}return l}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Wo(e){const{inputs:t,attrs:n,backend:r}=e,{x:a}=t,{perm:s}=n;Bs(a,"transpose");const o=a.shape.length,i=new Array(o);for(let d=0;d<i.length;d++)i[d]=a.shape[s[d]];const c=r.data.get(a.dataId).values,u=zo(c,a.shape,a.dtype,s,i),l=r.write(u,i,a.dtype);return{dataId:l,shape:i,dtype:a.dtype}}c["Transpose"];
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Uo(e,t,n,r){const[a,s]=c["backend_util"].computeOutAndReduceShapes(e,r),o=Object(c["upcastType"])(t,"int32"),i=c["util"].makeZerosTypedArray(c["util"].sizeFromShape(a),o),u=c["util"].sizeFromShape(s);for(let c=0;c<i.length;++c){const e=c*u;let t=1;for(let r=0;r<u;++r)t*=n[e+r];i[c]=t}return{outVals:i,outShape:a,outDtype:o}}function Go(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,keepDims:o}=r;Bs(a,"prod");const i=a.shape.length,u=c["util"].parseAxisParam(s,a.shape),l=c["backend_util"].getAxesPermutation(u,i);let d=u,p=a;const h=[];null!=l&&(p=Wo({inputs:{x:a},backend:n,attrs:{perm:l}}),h.push(p),d=c["backend_util"].getInnerMostAxes(d.length,i));const f=n.data.get(p.dataId).values,{outVals:m,outShape:b,outDtype:g}=Uo(p.shape,p.dtype,f,d);let y=b;return o&&(y=c["backend_util"].expandShapeToKeepDim(b,u)),h.forEach(e=>n.disposeIntermediateTensorInfo(e)),n.makeTensorInfo(y,g,m)}c["Prod"];
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ho(e,t,n,r){const a=e===t,s=e<t&&n<0,o=t<e&&n>1;if(a||s||o)return c["util"].makeZerosTypedArray(0,r);const i=Math.abs(Math.ceil((t-e)/n)),u=c["util"].makeZerosTypedArray(i,r);t<e&&1===n&&(n=-1),u[0]=e;for(let c=1;c<u.length;c++)u[c]=u[c-1]+n;return u}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const qo=no(e=>1/Math.sqrt(e)),Ko=ao(c["Rsqrt"],qo),Xo=(c["Rsqrt"],no(e=>1/(1+Math.exp(-e)))),Yo=ro(c["Sigmoid"],e=>1/(1+Math.exp(-e)));c["Sigmoid"];
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Qo(e,t,n,r,a){const s=c["slice_util"].isSliceContinous(r,t,n),o=c["util"].sizeFromShape(n),i=c["util"].computeStrides(r);if(s){const n=c["slice_util"].computeFlatOffset(t,i);return"string"===a?e.slice(n,n+o):e.subarray(n,n+o)}const u="string"===a?c["backend_util"].fromUint8ToStringArray(e):e,l=Object(c["buffer"])(r,a,u),d=Object(c["buffer"])(n,a);for(let c=0;c<d.size;++c){const e=d.indexToLoc(c),n=e.map((e,n)=>e+t[n]);d.set(l.get(...n),...e)}return"string"===a?c["backend_util"].fromStringArrayToUint8(d.values):d.values}function Zo(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{begin:s,size:o}=r;Bs(a,"slice");const[i,u]=c["slice_util"].parseSliceParams(a,s,o);c["slice_util"].assertParamsValid(a,i,u);const l=n.data.get(a.dataId).values,d=Qo(l,i,u,a.shape,a.dtype);return n.makeTensorInfo(u,a.dtype,d)}c["Slice"];
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Jo(e,t,n,r,a,s,o){const i=t[0],u=s[0],l=new Array(u),d=new Array(i),p=t[1];if(0===u){if(0!==i)throw new Error("Received SparseTensor with denseShape[0] = 0 but\n         indices.shape[0] = "+i);const e=c["util"].getArrayFromDType(n,0),t=c["util"].getArrayFromDType(a,0);return[e,[0,p],t,l,d]}let h=!0,f=0;const m=new Array(u).fill(0);for(let c=0;c<i;++c){const t=e[c*p];if(t<0)throw new Error(`indices(${c}, 0) is invalid: ${t} < 0`);if(t>=u)throw new Error(`indices(${c}, 0) is invalid: ${t} >= ${u}`);++m[t],h=h&&t>=f,f=t}let b=!0;for(let c=0;c<u;++c){const e=0===m[c];l[c]=e,b=b&&!e,m[c]=Math.max(m[c],1),c>0&&(m[c]+=m[c-1])}if(b&&h){const t=e,n=r;for(let e=0;e<i;++e)d[e]=e;return[t,[i,p],n,l,d]}{const t=m[u-1],s=c["util"].getArrayFromDType(n,t*p),h=c["util"].getArrayFromDType(a,t),f=new Array(u).fill(0);for(let n=0;n<i;++n){const t=e[n*p],a=f[t],o=(0===t?0:m[t-1])+a;f[t]++;for(let r=0;r<p;++r)s[o*p+r]=e[n*p+r];h[o]=r[n],d[n]=o}for(let e=0;e<u;++e){const t=f[e];if(0===t){const t=0===e?0:m[e-1];s[t*p+0]=e;for(let e=1;e<p;++e)s[t*p+e]=0;h[t]=o}}return[s,[t,p],h,l,d]}}
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ei(e,t,n,r,a){const s=c["util"].sizeFromShape(r),o=t[0],i=a.length,u=[];let l=1,d=-1;for(let c=0;c<i;++c){const e=a[c];if(-1===e){if(-1!==d)throw new Error(`only one output dimension may be -1, not both ${d} and ${c}`);d=c,u.push(1)}else{if(e<0)throw new Error(`size ${c} must be non-negative, not ${e}`);l*=e,u.push(e)}}if(-1!==d){if(l<=0)throw new Error("reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero");const e=Math.trunc(s/l);if(l*e!==s)throw new Error(`Input to reshape is a SparseTensor with ${s}\n          dense values, but the requested shape requires a multiple of ${l}. inputShape=${r} outputShape= ${u}`);u[d]=e}const p=c["util"].sizeFromShape(u);if(p!==s)throw new Error(`Input to reshape is a tensor with ${s} dense values, but the requested shape has ${p}. inputShape=${r} outputShape=${u}`);const h=r.length,f=[];if(h>0){f[h-1]=1;for(let e=h-2;e>=0;--e)f[e]=f[e+1]*r[e+1]}const m=[];if(i>0){m[i-1]=1;for(let e=i-2;e>=0;--e)m[e]=m[e+1]*u[e+1]}const b=c["util"].getArrayFromDType(n,o*i);for(let c=0;c<o;++c){let t=0;for(let n=0;n<h;++n)t+=e[c*h+n]*f[n];for(let e=0;e<i;++e)b[c*i+e]=Math.trunc(t/m[e]),t%=m[e]}return[b,[o,i],u]}
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ti(e,t,n,r,a,s=!1,o=0){const i=r.length;if(i!==a.length)throw new Error("segmentIds and indices should have same size.");const u=[t[0],e.length/t[0]],l=u[1],d=i>0?a[i-1]+1:0,p=d;if(p<0)throw new Error("segment ids must be >= 0");const h=t.slice();h[0]=p;const f=h.reduce((e,t)=>e*t,1),m=c["util"].getArrayFromDType(n,f);if(0===i)return p>0&&m.fill(o),[m,h];if(p<=0)throw new Error("segment ids must be >= 0");let b=0,g=1,y=0,x=a[b];while(1){let t=0;if(g<i){if(t=a[g],x===t){++g;continue}if(x>=t)throw new Error("segment ids are not increasing")}if(x<0||x>=p)throw new Error(`Segment id ${x} out of range [0, ${p}), possibly because segmentIds input is not sorted.`);x>y&&m.fill(o,y*l,x*l);for(let n=b;n<g;++n){const t=r[n];if(t<0||t>=u[0])throw new Error(`Bad: indices[${n}] == ${r[n]} out of range [0, ${u[0]})`);for(let n=0;n<l;n++)m[x*l+n]+=e[t*l+n]}if(s)for(let e=0;e<l;e++)m[x*l+e]/=g-b;if(b=g,++g,y=x+1,x=t,g>i)break}return y<p&&m.fill(o,y*l,p*l),[m,h]}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ni=no(e=>Math.sqrt(e)),ri=ro(c["Sqrt"],e=>Math.sqrt(e)),ai=(c["Sqrt"],Ws((e,t)=>{const n=e-t;return n*n})),si=Xs(c["SquaredDifference"],ai);c["SquaredDifference"];
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function oi(e,t,n,r){const a=Object(c["buffer"])(e,t.dtype);for(let s=0;s<a.size;s++){const e=a.indexToLoc(s),o=new Array(e.length);for(let t=0;t<o.length;t++)o[t]=e[t]*n[t]+r[t];a.set(t.get(...o),...e)}return a}
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ii{constructor(e,t,n,r,a,s){this.separator=c["util"].encodeString(e),this.nGramWidths=t,this.leftPad=c["util"].encodeString(n),this.rightPad=c["util"].encodeString(r),this.padWidth=a,this.preserveShort=s}getPadWidth(e){return Math.min(this.padWidth<0?e-1:this.padWidth,e-1)}getNumNGrams(e,t){const n=this.getPadWidth(t);return Math.max(0,e+2*n-t+1)}createNGrams(e,t,n,r,a,s){for(let o=0;o<a;++o){const i=this.getPadWidth(s),c=Math.max(0,i-o),u=Math.max(0,i-(a-(o+1))),l=s-(c+u),d=t+(c>0?0:o-i);let p=0;p+=c*this.leftPad.length;for(let t=0;t<l;++t)p+=e[d+t].length;p+=u*this.rightPad.length;const h=c+u+l-1;p+=h*this.separator.length,n[r+o]=new Uint8Array(p);const f=n[r+o];let m=0;const b=e=>e.forEach(e=>f[m++]=e);for(let e=0;e<c;++e)b(this.leftPad),b(this.separator);for(let t=0;t<l-1;++t)b(e[d+t]),b(this.separator);if(l>0){b(e[d+l-1]);for(let e=0;e<u;++e)b(this.separator),b(this.rightPad)}else{for(let e=0;e<u-1;++e)b(this.rightPad),b(this.separator);b(this.rightPad)}}}compute(e,t){const n=e.length,r=t.length;if(r>0){let e=t[0];if(0!==e)throw new Error("First split value must be 0, got "+e);for(let a=1;a<r;++a){let r=t[a]>=e;if(r=r&&t[a]<=n,!r)throw new Error(`Invalid split value ${t[a]}, must be in [${e}, ${n}]`);e=t[a]}if(e!==n)throw new Error(`Last split value must be data size. Expected ${n}, got ${e}`)}const a=r-1,s=c["util"].getArrayFromDType("int32",r);if(0===n||0===r){const e=new Array(n);for(let t=0;t<=a;++t)s[t]=0;return[e,s]}s[0]=0;for(let i=1;i<=a;++i){const e=t[i]-t[i-1];let n=0;this.nGramWidths.forEach(t=>{n+=this.getNumNGrams(e,t)}),this.preserveShort&&e>0&&0===n&&(n=1),s[i]=s[i-1]+n}const o=new Array(s[a]);for(let i=0;i<a;++i){const n=t[i];let r=s[i];if(this.nGramWidths.forEach(a=>{const s=t[i+1]-t[i],c=this.getNumNGrams(s,a);this.createNGrams(e,n,o,r,c,a),r+=c}),this.preserveShort&&r===s[i]){const a=t[i+1]-t[i];if(0===a)continue;const s=a+2*this.padWidth,c=1;this.createNGrams(e,n,o,r,c,s)}}return[o,s]}}function ci(e,t,n,r,a,s,o,i){return new ii(n,r,a,s,o,i).compute(e,t)}
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ui(e,t,n,r){if(!e.length)return;if(0===t.length){for(let t=0;t<e.length;++t)r.push(e.subarray(t,t+1));return}if(1===t.length){const a=t[0];let s=e.indexOf(a);while(-1!==s){const t=e.subarray(0,s);n&&0===t.length||r.push(t),e=e.subarray(s+1),s=e.indexOf(a)}return void(n&&0===e.length||r.push(e))}let a=0;for(let s=0;s<e.length+1;s++)if(s===e.length||-1!==t.indexOf(e[s])){const t=e.subarray(a,s);n&&0===t.length||r.push(t),a=s+1}}function li(e,t,n){const r=e.length,a=[];let s=0,o=0;const i=new Array(r);for(let c=0;c<r;++c){const r=a.length;ui(e[c],t,n,a);const u=a.length-r;i[c]=u,s+=u,o=Math.max(o,u)}const u=c["util"].getArrayFromDType("int32",2*s),l=new Array(s),d=[r,o];let p=0;for(let c=0;c<r;++c)for(let e=0;e<i[c];++e)u[2*p]=c,u[2*p+1]=e,l[p]=a[p],++p;return[u,l,d]}
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function di(e,t){const n=c["util"].getArrayFromDType("int32",e.length);for(let r=0;r<e.length;++r)n[r]=c["util"].fingerPrint64(e[r]).modulo(t).getLowBitsUnsigned();return n}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const pi=Ws((e,t)=>e-t),hi=Ys((e,t,n,r)=>({real:e-n,imag:t-r})),fi=Xs(c["Sub"],pi,hi);c["Sub"];
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function mi(e,t){const n=new Array(e.rank);for(let a=0;a<n.length;a++)n[a]=e.shape[a]*t[a];const r=Object(c["buffer"])(n,e.dtype);for(let a=0;a<r.values.length;++a){const t=r.indexToLoc(a),n=new Array(e.rank);for(let r=0;r<n.length;r++)n[r]=t[r]%e.shape[r];const s=e.locToIndex(n);r.values[a]=e.values[s]}return r}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const bi=(e,t)=>{const n=t.value-e.value;return 0===n?e.index-t.index:n};function gi(e,t,n=0,r=e.length-1){while(r>n){if(r-n>600){const a=r-n+1,s=t-n+1,o=Math.log(a),i=.5*Math.exp(2*o/3),c=.5*Math.sqrt(o*i*(a-i)/a)*Math.sign(s-a/2),u=Math.max(n,Math.floor(t-s*i/a+c)),l=Math.min(r,Math.floor(t+(a-s)*i/a+c));gi(e,t,u,l)}const a=e[t];let s=n,o=r;c["util"].swap(e,n,t),bi(e[r],a)>0&&c["util"].swap(e,n,r);while(s<o){c["util"].swap(e,s,o),s++,o--;while(bi(e[s],a)<0)s+=1;while(bi(e[o],a)>0)o-=1}0===bi(e[n],a)?c["util"].swap(e,n,o):(o+=1,c["util"].swap(e,o,r)),o<=t&&(n=o+1),t<=o&&(r=o-1)}}function yi(e,t,n,r,a){const s=t[t.length-1],[o,i]=[e.length/s,s],u=c["util"].getTypedArrayFromDType(n,o*r),l=c["util"].getTypedArrayFromDType("int32",o*r);for(let c=0;c<o;c++){const t=c*i,n=e.subarray(t,t+i);let s=new Array(n.length);n.forEach((e,t)=>s[t]={value:e,index:t}),r<s.length&&(gi(s,r),s=s.slice(0,r)),a&&s.sort(bi);const o=c*r,d=u.subarray(o,o+r),p=l.subarray(o,o+r);for(let e=0;e<r;e++)d[e]=s[e].value,p[e]=s[e].index}const d=t.slice();return d[d.length-1]=r,[Object(c["buffer"])(d,n,u),Object(c["buffer"])(d,"int32",l)]}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xi(e,t,n,r){const a=c["util"].parseAxisParam(t,n)[0],s=[1,n[0],1];for(let c=0;c<a;c++)s[0]*=n[c];s[1]=n[a];for(let c=a+1;c<n.length;c++)s[2]*=n[c];const o={},i=new Int32Array(n[a]),u=new c["TensorBuffer"](s,r,e),l=[],d=1===s[0]&&1===s[2];for(let c=0;c<n[a];c++){let t;if(d)t=e[c].toString();else{const e=[];for(let t=0;t<s[0];t++)for(let n=0;n<s[2];n++)e.push(u.get(t,c,n));t=e.join(",")}if(void 0!==o[t])i[c]=o[t];else{const e=Object.keys(o).length;o[t]=e,i[c]=e,l.push(c)}}const p=s.slice();p[1]=Object.keys(o).length;const h=new c["TensorBuffer"](p,r);l.forEach((e,t)=>{for(let n=0;n<s[0];n++)for(let r=0;r<s[2];r++)h.set(u.get(n,e,r),n,t,r)});const f=n.slice();return f[a]=p[1],{outputValues:h.values,outputShape:f,indices:i}}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const{addImpl:Oi,bincountImpl:vi,bincountReduceImpl:wi,ceilImpl:ki,concatImpl:ji,equalImpl:Si,expImpl:Ni,expm1Impl:Ci,floorImpl:Ii,gatherNdImpl:Ti,gatherV2Impl:$i,greaterImpl:Ei,greaterEqualImpl:Ai,lessImpl:Ri,lessEqualImpl:_i,linSpaceImpl:Fi,logImpl:Di,maxImpl:Mi,maximumImpl:Li,minimumImpl:Pi,multiplyImpl:Bi,negImpl:Vi,notEqualImpl:zi,prodImpl:Wi,rangeImpl:Ui,rsqrtImpl:Gi,sigmoidImpl:Hi,simpleAbsImpl:qi,sliceImpl:Ki,sparseFillEmptyRowsImpl:Xi,sparseReshapeImpl:Yi,sparseSegmentReductionImpl:Qi,sqrtImpl:Zi,stridedSliceImpl:Ji,stringNGramsImpl:ec,stringSplitImpl:tc,stringToHashBucketFastImpl:nc,subImpl:rc,tileImpl:ac,topKImpl:sc,transposeImpl:oc,uniqueImpl:ic}=a;
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cc(e,t){return["x","y","z","w","u","v"].slice(0,t).map(t=>`${e}.${t}`)}function uc(e,t){return 1===t?[e]:cc(e,t)}function lc(e,t){if(1===e)return"rc";let n="";for(let r=0;r<e;r++)n+=t[r],r<e-1&&(n+=",");return n}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class dc{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outputShape=e;const t=e.length;if(0===t)this.userCode="\n        void main() {\n          setOutput(vec4(getA(), 0., 0., 0.));\n        }\n      ";else{const n=uc("rc",t),r=ts(t),a=hc(t,e,n),s=fc(t,e[e.length-1],e[e.length-2],n),o=mc(e,n);this.userCode=`\n        void main() {\n          ${r} rc = getOutputCoords();\n\n          if(${a}) {\n            setOutput(vec4(0));\n          } else {\n            ${s}\n\n            setOutput(vec4(${o}));\n          }\n        }\n      `}}}function pc(e,t){const n=[];for(let r=0;r<=1;r++)for(let a=0;a<=1;a++){let s=`${0===r?"r":"rp1"}, ${0===a?"c":"cp1"}`;for(let n=2;n<e;n++)s=t[t.length-1-n]+","+s;n.push(s)}return n}function hc(e,t,n){if(1===e)return"rc > "+t[0];let r="";for(let a=e-2;a<e;a++)r+=`${n[a]} >= ${t[a]}`,a<e-1&&(r+="||");return r}function fc(e,t,n,r){if(1===e)return"";const a=r.slice(-2);return`\n    int r = ${a[0]};\n    int c = ${a[1]};\n    int rp1 = r + 1;\n    int cp1 = c + 1;\n\n    bool cEdge = cp1 >= ${t};\n    bool rEdge = rp1 >= ${n};\n  `}function mc(e,t){const n=e.length,r=pc(n,t);return 1===n?`getA(rc),\n            rc + 1 >= ${e[0]} ? 0. : getA(rc + 1),\n            0, 0`:`getA(${r[0]}),\n          cEdge ? 0. : getA(${r[1]}),\n          rEdge ? 0. : getA(${r[2]}),\n          rEdge || cEdge ? 0. : getA(${r[3]})`}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class bc{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec3"}],this.outputShape=e,this.enableShapeUniforms=us(this.outputShape.length);let n="";for(let r=0;r<4;r++){let e="thisRC = rc;";r%2===1&&(e+="thisRC.z += 1;"),r>1&&(e+="thisRC.y += 1;"),n+=`\n        ${e}\n        ${r>0?"if(thisRC.y < rows && thisRC.z < cols){":""}\n          int flatIndex = getFlatIndex(thisRC);\n\n          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);\n          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));\n\n          result[${r}] =\n            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);\n        ${r>0?"}":""}\n      `}this.userCode=`\n      ${gc(t,this.enableShapeUniforms)}\n      ${this.enableShapeUniforms?da():la(e)}\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n\n        vec4 result = vec4(0.);\n\n        ivec3 thisRC;\n        int rows = ${this.enableShapeUniforms?"outShape[1]":e[1]};\n        int cols = ${this.enableShapeUniforms?"outShape[2]":e[2]};\n\n        ${n}\n\n        setOutput(result);\n      }\n    `}}function gc(e,t){const n=t?ua(["r","c","d"],"inputShape"):oa(["r","c","d"],e);return`\n    ivec3 inputCoordsFromReshapedOutCoords(int index) {\n      ${n}\n      return ivec3(r, c, d);\n    }\n  `}
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class yc{constructor(e){this.gpgpu=e,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0,this.freeTextures={},this.logEnabled=!1,this.usedTextures={}}acquireTexture(e,t,n){const r=kc(t,n),a=jc(e,r,n);a in this.freeTextures||(this.freeTextures[a]=[]),a in this.usedTextures||(this.usedTextures[a]=[]);const s=Oc(e,r,this.gpgpu.gl,this.gpgpu.textureConfig,n);if(this.freeTextures[a].length>0){this.numFreeTextures--,this.numUsedTextures++,this._numBytesFree-=s,this.log();const e=this.freeTextures[a].shift();return this.usedTextures[a].push(e),e}let o;return r===nr.PACKED_2X2_FLOAT32?o=this.gpgpu.createPackedMatrixTexture(e[0],e[1]):r===nr.PACKED_2X2_FLOAT16?o=this.gpgpu.createFloat16PackedMatrixTexture(e[0],e[1]):r===nr.UNPACKED_FLOAT32?o=this.gpgpu.createFloat32MatrixTexture(e[0],e[1]):r===nr.UNPACKED_FLOAT16?o=this.gpgpu.createFloat16MatrixTexture(e[0],e[1]):r===nr.PACKED_4X1_UNSIGNED_BYTE&&(o=this.gpgpu.createUnsignedBytesMatrixTexture(e[0],e[1])),this.usedTextures[a].push(o),this.numUsedTextures++,this._numBytesAllocated+=s,this.log(),o}releaseTexture(e,t,n,r){if(null==this.freeTextures)return;const a=kc(n,r),s=jc(t,a,r);s in this.freeTextures||(this.freeTextures[s]=[]);const o=Oc(t,a,this.gpgpu.gl,this.gpgpu.textureConfig,r),i=Object(c["env"])().get("WEBGL_DELETE_TEXTURE_THRESHOLD");-1!==i&&this._numBytesAllocated>i?(this.gpgpu.deleteMatrixTexture(e),this._numBytesAllocated-=o):(this.freeTextures[s].push(e),this.numFreeTextures++,this._numBytesFree+=o),this.numUsedTextures--;const u=this.usedTextures[s],l=u.indexOf(e);if(l<0)throw new Error("Cannot release a texture that was never provided by this texture manager");u.splice(l,1),this.log()}log(){if(!this.logEnabled)return;const e=this.numFreeTextures+this.numUsedTextures;console.log("Free/Used",`${this.numFreeTextures} / ${this.numUsedTextures}`,`(${e})`);const t=this._numBytesFree/this._numBytesAllocated;console.log("Bytes allocated: "+this._numBytesAllocated),console.log(`Bytes unused: ${this._numBytesFree} (${Math.round(100*t)}%)`)}get numBytesAllocated(){return this._numBytesAllocated}get numBytesFree(){return this._numBytesFree}getNumUsedTextures(){return this.numUsedTextures}getNumFreeTextures(){return this.numFreeTextures}dispose(){if(null!=this.freeTextures){for(const e in this.freeTextures)this.freeTextures[e].forEach(e=>{this.gpgpu.deleteMatrixTexture(e)});for(const e in this.usedTextures)this.usedTextures[e].forEach(e=>{this.gpgpu.deleteMatrixTexture(e)});this.freeTextures=null,this.usedTextures=null,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0}}}function xc(e,t){const n=e;if(t===n.R32F)return 4;if(t===n.R16F)return 2;if(t===n.RGBA32F)return 16;if(t===e.RGBA)return 16;if(t===n.RGBA16F)return 8;throw new Error("Unknown internal format "+t)}function Oc(e,t,n,r,a){const s=vc(t,r);let o;if(a){const[t,n]=or(e[0],e[1]);o=t*n}else{const[t,n]=rr(e[0],e[1]);o=t*n}const i=xc(n,s);return o*i}function vc(e,t){switch(e){case nr.PACKED_2X2_FLOAT32:return Ns(t);case nr.PACKED_2X2_FLOAT16:return Is(t);case nr.UNPACKED_FLOAT32:return Os(t);case nr.UNPACKED_FLOAT16:return ws(t);case nr.PACKED_4X1_UNSIGNED_BYTE:return js(t);default:throw new Error("Unknown physical texture type "+e)}}function wc(e){return Object(c["env"])().getBool("WEBGL_RENDER_FLOAT32_ENABLED")?e?nr.PACKED_2X2_FLOAT32:nr.UNPACKED_FLOAT32:e?nr.PACKED_2X2_FLOAT16:nr.UNPACKED_FLOAT16}function kc(e,t){if(e===tr.UPLOAD)return nr.PACKED_2X2_FLOAT32;if(e===tr.RENDER||null==e)return wc(t);if(e===tr.DOWNLOAD||e===tr.PIXELS)return nr.PACKED_4X1_UNSIGNED_BYTE;throw new Error("Unknown logical texture type "+e)}function jc(e,t,n){return`${e[0]}_${e[1]}_${t}_${n}`}
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Sc{constructor(e,t){this.variableNames=["A"],this.outputShape=e,this.enableShapeUniforms=us(this.outputShape.length),this.userCode=`\n      float unaryOperation(float x) {\n        ${t}\n      }\n\n      void main() {\n        float x = getAAtOutCoords();\n        float y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    `}}const Nc="if (isnan(x)) return x;",Cc="return x;",Ic="return abs(x);";const Tc="return (x >= 0.0) ? x : (exp(x) - 1.0);",$c=Nc+"\n  return (x < 0.0) ? 0.0 : x;\n",Ec=Nc+"\n  return (x < 0.0) ? 0.0 : min(6.0, x);\n",Ac="return x;",Rc="return 1.0 / (1.0 + exp(-1.0 * x));",_c="return x;",Fc="\n  vec4 result;\n\n  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);\n  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);\n  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);\n  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);\n\n  return result;\n",Dc="\n  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",Mc="\n  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",Lc="return 1.0 / (1.0 + exp(-1.0 * x));";class Pc{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.enableShapeUniforms=us(this.outputShape.length),this.userCode=`\n      vec4 unaryOperation(vec4 x) {\n        ${t}\n      }\n\n      void main() {\n        vec4 x = getAAtOutCoords();\n        vec4 y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    `}}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Bc{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outputShape=e;const t=e.length,n=uc("rc",t),r=ts(t),a=lc(t,n),s=n.slice(-2),o=t<=1?"rc":`vec2(${s.join(",")})`;this.userCode=`\n      void main() {\n        ${r} rc = getOutputCoords();\n        vec4 packedInput = getA(${a});\n\n        setOutput(getChannel(packedInput, ${o}));\n      }\n    `}}
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Vc=c["kernel_impls"].whereImpl,zc=1e-7,Wc=1e-4,Uc={};function Gc(e){return e in Uc||(Uc[e]={}),Uc[e]}const Hc=Object(c["env"])().getNumber("CPU_HANDOFF_SIZE_THRESHOLD"),qc=600;function Kc(){return null==Object(c["env"])().global.screen?1024:Object(c["env"])().global.screen.height*Object(c["env"])().global.screen.width*window.devicePixelRatio*qc/1024/1024}class Xc extends c["KernelBackend"]{constructor(e){if(super(),this.pendingRead=new WeakMap,this.pendingDisposal=new WeakSet,this.dataRefCount=new WeakMap,this.numBytesInGPU=0,this.uploadWaitMs=0,this.downloadWaitMs=0,this.lastGlFlushTime=0,this.warnedAboutMemory=!1,this.pendingDeletes=0,this.disposed=!1,!Object(c["env"])().getBool("HAS_WEBGL"))throw new Error("WebGL is not supported on this device");if(null==e){const e=Qn(Object(c["env"])().getNumber("WEBGL_VERSION"));this.binaryCache=Gc(Object(c["env"])().getNumber("WEBGL_VERSION")),this.gpgpu=new Ls(e),this.canvas=e.canvas,this.gpgpuCreatedLocally=!0}else this.gpgpu=e,this.binaryCache={},this.gpgpuCreatedLocally=!1,this.canvas=e.gl.canvas;this.textureManager=new yc(this.gpgpu),this.numMBBeforeWarning=Kc(),this.texData=new c["DataStorage"](this,Object(c["engine"])())}nextDataId(){return Xc.nextDataId++}numDataIds(){return this.texData.numDataIds()-this.pendingDeletes}write(e,t,n){if((Object(c["env"])().getBool("WEBGL_CHECK_NUMERICAL_PROBLEMS")||Object(c["env"])().getBool("DEBUG"))&&this.checkNumericalProblems(e),"complex64"===n&&null!=e)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");const r={id:this.nextDataId()};return this.texData.set(r,{shape:t,dtype:n,values:e,usage:tr.UPLOAD,refCount:1}),r}refCount(e){if(this.texData.has(e)){const t=this.texData.get(e);return t.refCount}return 0}incRef(e){const t=this.texData.get(e);t.refCount++}decRef(e){if(this.texData.has(e)){const t=this.texData.get(e);t.refCount--}}move(e,t,n,r,a){if(Object(c["env"])().getBool("DEBUG")&&this.checkNumericalProblems(t),"complex64"===r)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.texData.set(e,{shape:n,dtype:r,values:t,usage:tr.UPLOAD,refCount:a})}disposeIntermediateTensorInfo(e){this.disposeData(e.dataId)}readSync(e){const t=this.texData.get(e),{values:n,dtype:r,complexTensorInfos:a,slice:s,shape:o,isPacked:i}=t;if(null!=s){let t;t=i?new Pc(o,Ac):new Sc(o,Ac);const n=this.runWebGLProgram(t,[{dataId:e,shape:o,dtype:r}],r),a=this.readSync(n.dataId);return this.disposeIntermediateTensorInfo(n),a}if(null!=n)return this.convertAndCacheOnCPU(e);if("string"===r)return n;const u=null!=this.activeTimers;let l,d;if(u&&(l=c["util"].now()),"complex64"===r){const e=this.readSync(a.real.dataId),t=this.readSync(a.imag.dataId);d=c["backend_util"].mergeRealAndImagArrays(e,t)}else d=this.getValuesFromTexture(e);return u&&(this.downloadWaitMs+=c["util"].now()-l),this.convertAndCacheOnCPU(e,d)}async read(e){if(this.pendingRead.has(e)){const t=this.pendingRead.get(e);return new Promise(e=>t.push(e))}const t=this.texData.get(e),{values:n,shape:r,slice:a,dtype:s,complexTensorInfos:o,isPacked:i}=t;if(null!=a){let t;t=i?new Pc(r,Ac):new Sc(r,Ac);const n=this.runWebGLProgram(t,[{dataId:e,shape:r,dtype:s}],s),a=this.read(n.dataId);return this.disposeIntermediateTensorInfo(n),a}if(null!=n)return this.convertAndCacheOnCPU(e);if(!Object(c["env"])().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")&&2===Object(c["env"])().getNumber("WEBGL_VERSION"))throw new Error("tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.");let u,l,d=null;if("complex64"!==s&&Object(c["env"])().get("WEBGL_BUFFER_SUPPORTED")){u=this.decode(e);const t=this.texData.get(u.dataId);d=this.gpgpu.createBufferFromTexture(t.texture,...sr(r))}if(this.pendingRead.set(e,[]),"complex64"!==s&&await this.gpgpu.createAndWaitForFence(),"complex64"===s){const e=await Promise.all([this.read(o.real.dataId),this.read(o.imag.dataId)]),t=e[0],n=e[1];l=c["backend_util"].mergeRealAndImagArrays(t,n)}else if(null==d)l=this.getValuesFromTexture(e);else{const e=c["util"].sizeFromShape(r);l=this.gpgpu.downloadFloat32MatrixFromBuffer(d,e)}if(null!=u&&this.disposeIntermediateTensorInfo(u),null!=d){const e=this.gpgpu.gl;ur(e,()=>e.deleteBuffer(d))}const p=this.convertAndCacheOnCPU(e,l),h=this.pendingRead.get(e);return this.pendingRead.delete(e),h.forEach(e=>e(p)),this.pendingDisposal.has(e)&&(this.pendingDisposal.delete(e),this.disposeData(e)&&Object(c["engine"])().removeDataId(e,this),this.pendingDeletes--),p}bufferSync(e){const t=this.readSync(e.dataId);let n=t;if("string"===e.dtype)try{n=t.map(e=>c["util"].decodeString(e))}catch(r){throw new Error("Failed to decode encoded string bytes into utf-8")}return Object(c["buffer"])(e.shape,e.dtype,n)}checkNumericalProblems(e){if(null!=e)for(let t=0;t<e.length;t++){const n=e[t];if(!hr(n)){if(Object(c["env"])().getBool("WEBGL_RENDER_FLOAT32_CAPABLE"))throw Error(`The value ${n} cannot be represented with your current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'`);throw Error(`The value ${n} cannot be represented on this device.`)}}}getValuesFromTexture(e){const{shape:t,dtype:n,isPacked:r}=this.texData.get(e),a=c["util"].sizeFromShape(t);if(Object(c["env"])().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")){const n=this.decode(e),r=this.texData.get(n.dataId),s=this.gpgpu.downloadMatrixFromPackedTexture(r.texture,...sr(t)).subarray(0,a);return this.disposeIntermediateTensorInfo(n),s}const s=Object(c["env"])().getBool("WEBGL_PACK")&&!0===r,o=s?Vr(t):t,i=s?new hs(o):new ps(o),u=this.runWebGLProgram(i,[{shape:o,dtype:n,dataId:e}],"float32"),l=this.texData.get(u.dataId),d=this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(l.texture,l.texShape[0],l.texShape[1]).subarray(0,a);return this.disposeIntermediateTensorInfo(u),d}timerAvailable(){return Object(c["env"])().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0}async time(e){const t=this.activeTimers,n=[];let r=!1;null==this.programTimersStack?(this.programTimersStack=n,r=!0):this.activeTimers.push(n),this.activeTimers=n,e();const a=c["util"].flatten(this.activeTimers.map(e=>e.query)).filter(e=>null!=e),s=c["util"].flatten(this.activeTimers.map(e=>e.name)).filter(e=>null!=e);this.activeTimers=t,r&&(this.programTimersStack=null);const o={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null};if(Object(c["env"])().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0){const e=await Promise.all(a);o["kernelMs"]=c["util"].sum(e),o["getExtraProfileInfo"]=()=>e.map((e,t)=>({name:s[t],ms:e})).map(e=>`${e.name}: ${e.ms}`).join(", ")}else o["kernelMs"]={error:"WebGL query timers are not supported in this environment."};return this.uploadWaitMs=0,this.downloadWaitMs=0,o}memory(){return{unreliable:!1,numBytesInGPU:this.numBytesInGPU,numBytesInGPUAllocated:this.textureManager.numBytesAllocated,numBytesInGPUFree:this.textureManager.numBytesFree}}startTimer(){return Object(c["env"])().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?this.gpgpu.beginQuery():{startMs:c["util"].now(),endMs:null}}endTimer(e){return Object(c["env"])().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?(this.gpgpu.endQuery(),e):(e.endMs=c["util"].now(),e)}async getQueryTime(e){if(Object(c["env"])().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0)return this.gpgpu.waitForQueryAndGetTime(e);const t=e;return t.endMs-t.startMs}disposeData(e,t=!1){if(this.pendingDisposal.has(e))return!1;if(!this.texData.has(e))return!0;if(t?this.texData.get(e).refCount=0:this.texData.get(e).refCount--,!t&&this.texData.get(e).refCount>0)return!1;if(this.pendingRead.has(e))return this.pendingDisposal.add(e),this.pendingDeletes++,!1;this.releaseGPUData(e);const{complexTensorInfos:n}=this.texData.get(e);return null!=n&&(this.disposeData(n.real.dataId,t),this.disposeData(n.imag.dataId,t)),this.texData.delete(e),!0}releaseGPUData(e){const{texture:t,dtype:n,texShape:r,usage:a,isPacked:s,slice:o}=this.texData.get(e),i=o&&o.origDataId||e,c=this.dataRefCount.get(i);c>1?this.dataRefCount.set(i,c-1):(this.dataRefCount.delete(i),null!=t&&(this.numBytesInGPU-=this.computeBytes(r,n),this.textureManager.releaseTexture(t,r,a,s)));const u=this.texData.get(e);u.texture=null,u.texShape=null,u.isPacked=!1,u.slice=null}getTexture(e){return this.uploadToGPU(e),this.texData.get(e).texture}getDataInfo(e){return this.texData.get(e)}shouldExecuteOnCPU(e,t=Hc){return Object(c["env"])().getBool("WEBGL_CPU_FORWARD")&&e.every(e=>null==this.texData.get(e.dataId).texture&&c["util"].sizeFromShape(e.shape)<t)}getGPGPUContext(){return this.gpgpu}where(e){c["backend_util"].warn("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");const t=e.dataSync();return Vc(e.shape,t)}packedUnaryOp(e,t,n){const r=new Pc(e.shape,t),a=this.compileAndRun(r,[e],n);return Object(c["engine"])().makeTensorFromDataId(a.dataId,a.shape,a.dtype)}abs(e){if(this.shouldExecuteOnCPU([e])&&"complex64"!==e.dtype){const t=qi(this.texData.get(e.dataId).values);return this.makeOutput(e.shape,e.dtype,t)}if(Object(c["env"])().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(e,Ic,e.dtype);const t=new Sc(e.shape,Ic),n=this.compileAndRun(t,[e]);return Object(c["engine"])().makeTensorFromDataId(n.dataId,n.shape,n.dtype)}makeTensorInfo(e,t,n){let r;if("string"===t&&null!=n&&n.length>0&&c["util"].isString(n[0])){const a=n.map(e=>c["util"].encodeString(e));r=this.write(a,e,t)}else r=this.write(n,e,t);return this.texData.get(r).usage=null,{dataId:r,shape:e,dtype:t}}makeOutput(e,t,n){const{dataId:r}=this.makeTensorInfo(e,t,n);return Object(c["engine"])().makeTensorFromDataId(r,e,t,this)}unpackTensor(e){const t=new Bc(e.shape);return this.runWebGLProgram(t,[e],e.dtype)}packTensor(e){const t=new dc(e.shape),n=!0;return this.runWebGLProgram(t,[e],e.dtype,null,n)}packedReshape(e,t){const n=[Pr(e.shape),...Br(e.shape)],r={dtype:e.dtype,shape:n,dataId:e.dataId},a=[Pr(t),...Br(t)],s=new bc(a,n),o=!0,i=[n],c=this.runWebGLProgram(s,[r],e.dtype,i,o);return{dataId:c.dataId,shape:t,dtype:c.dtype}}decode(e){const t=this.texData.get(e),{isPacked:n,shape:r,dtype:a}=t,s=Vr(r);let o;const i=sr(s);o=n?new ds(s):new ls(s);const c=!0,u=[i],l=this.runWebGLProgram(o,[{shape:s,dtype:a,dataId:e}],a,u,c);return{dtype:a,shape:r,dataId:l.dataId}}runWebGLProgram(e,t,n,r,a=!1){const s=this.makeTensorInfo(e.outputShape,n),o=this.texData.get(s.dataId);if(e.packedOutput&&(o.isPacked=!0),e.outPackingScheme===er.DENSE){const t=sr(e.outputShape);o.texShape=t.map(e=>2*e)}if(null!=e.outTexUsage&&(o.usage=e.outTexUsage),0===c["util"].sizeFromShape(s.shape))return o.values=c["util"].getTypedArrayFromDType(s.dtype,0),s;const i=[],u=t.map(t=>{if("complex64"===t.dtype)throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");let n=this.texData.get(t.dataId);if(null==n.texture){if(!e.packedInputs&&c["util"].sizeFromShape(t.shape)<=Object(c["env"])().getNumber("WEBGL_SIZE_UPLOAD_UNIFORM"))return{shape:t.shape,texData:null,isUniform:!0,uniformValues:n.values};e.packedInputs&&(n.isPacked=!0,n.shape=t.shape)}else if(!!n.isPacked!==!!e.packedInputs)t=n.isPacked?this.unpackTensor(t):this.packTensor(t),i.push(t),n=this.texData.get(t.dataId);else if(n.isPacked&&!Ur(n.shape,t.shape)){const e=t,r=t.shape;t.shape=n.shape,t=this.packedReshape(t,r),i.push(t),n=this.texData.get(t.dataId),e.shape=r}return this.uploadToGPU(t.dataId),{shape:t.shape,texData:n,isUniform:!1}});this.uploadToGPU(s.dataId);const l={shape:s.shape,texData:o,isUniform:!1},d=cs(e,u,l),p=this.getAndSaveBinary(d,()=>ss(this.gpgpu,e,u,l)),h=null!=this.activeTimers;let f;h&&(f=this.startTimer()),is(this.gpgpu,p,u,l,r),i.forEach(e=>this.disposeIntermediateTensorInfo(e)),h&&(f=this.endTimer(f),this.activeTimers.push({name:e.constructor.name,query:this.getQueryTime(f)}));const m=Object(c["env"])().get("WEBGL_FLUSH_THRESHOLD");if(m>0){const e=c["util"].now();e-this.lastGlFlushTime>m&&(this.gpgpu.gl.flush(),this.lastGlFlushTime=e)}if(!Object(c["env"])().getBool("WEBGL_LAZILY_UNPACK")&&o.isPacked&&!1===a){const e=this.unpackTensor(s);return this.disposeIntermediateTensorInfo(s),e}return s}compileAndRun(e,t,n,r,a=!1){n=n||t[0].dtype;const s=this.runWebGLProgram(e,t,n,r,a);return s}getAndSaveBinary(e,t){return e in this.binaryCache||(this.binaryCache[e]=t()),this.binaryCache[e]}getTextureManager(){return this.textureManager}dispose(){if(!this.disposed){if(!Object(c["env"])().getBool("IS_TEST")){const e=Object.keys(this.binaryCache);e.forEach(e=>{this.gpgpu.deleteProgram(this.binaryCache[e].webGLProgram),delete this.binaryCache[e]})}this.textureManager.dispose(),null!=this.canvas&&"undefined"!==typeof HTMLCanvasElement&&this.canvas instanceof HTMLCanvasElement?this.canvas.remove():this.canvas=null,this.gpgpuCreatedLocally&&(this.gpgpu.program=null,this.gpgpu.dispose()),this.disposed=!0}}floatPrecision(){return null==this.floatPrecisionValue&&(this.floatPrecisionValue=Object(c["tidy"])(()=>{if(!Object(c["env"])().get("WEBGL_RENDER_FLOAT32_ENABLED")){const e=Object(c["env"])().getBool("DEBUG");Object(c["env"])().set("DEBUG",!1);const t=this.abs(Object(c["scalar"])(1e-8)).dataSync()[0];if(Object(c["env"])().set("DEBUG",e),t>0)return 32}return 16})),this.floatPrecisionValue}epsilon(){return 32===this.floatPrecision()?zc:Wc}uploadToGPU(e){const t=this.texData.get(e),{shape:n,dtype:r,values:a,texture:s,usage:o,isPacked:i}=t;if(null!=s)return;const u=null!=this.activeTimers;let l;u&&(l=c["util"].now());let d=t.texShape;if(null==d&&(d=zr(n,i),t.texShape=d),null!=a){const e=Vr(n);let s,o=d[1],p=d[0];const h=a instanceof Uint8Array;i?([o,p]=or(d[0],d[1]),s=new ms(e,h)):s=new fs(e,h);const f=this.makeTensorInfo([p,o],r);this.texData.get(f.dataId).usage=h?tr.PIXELS:tr.UPLOAD,this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(f.dataId),o,p,a);const m=[[p,o]],b=!0,g=this.runWebGLProgram(s,[f],r,m,b),y=this.texData.get(g.dataId);t.texture=y.texture,t.texShape=y.texShape,t.isPacked=y.isPacked,t.usage=y.usage,this.disposeIntermediateTensorInfo(f),this.texData.delete(g.dataId),t.values=null,u&&(this.uploadWaitMs+=c["util"].now()-l)}else{const e=this.acquireTexture(d,o,r,i);t.texture=e}}convertAndCacheOnCPU(e,t){const n=this.texData.get(e),{dtype:r}=n;return this.releaseGPUData(e),null!=t&&(n.values=Yc(t,r)),n.values}acquireTexture(e,t,n,r){if(this.numBytesInGPU+=this.computeBytes(e,n),!this.warnedAboutMemory&&this.numBytesInGPU>1024*this.numMBBeforeWarning*1024){const e=(this.numBytesInGPU/1024/1024).toFixed(2);this.warnedAboutMemory=!0,console.warn(`High memory usage in GPU: ${e} MB, most likely due to a memory leak`)}return this.textureManager.acquireTexture(e,t,r)}computeBytes(e,t){return e[0]*e[1]*c["util"].bytesPerElement(t)}}function Yc(e,t){if("float32"===t||"complex64"===t)return e;if("int32"===t||"bool"===t){const n="int32"===t?new Int32Array(e.length):new Uint8Array(e.length);for(let t=0;t<n.length;++t)n[t]=Math.round(e[t]);return n}throw new Error("Unknown dtype "+t)}
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Xc.nextDataId=0,
/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
c["device_util"].isBrowser()&&Object(c["registerBackend"])("webgl",()=>new Xc,2);const Qc="\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n";
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Zc{constructor(e,t,n){this.variableNames=["A","B"],this.outputShape=c["backend_util"].assertAndGetBroadcastShape(t,n),this.enableShapeUniforms=us(this.outputShape.length),this.userCode=`\n      float binaryOperation(float a, float b) {\n        ${e}\n      }\n\n      void main() {\n        float a = getAAtOutCoords();\n        float b = getBAtOutCoords();\n        setOutput(binaryOperation(a, b));\n      }\n    `}}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Jc="\n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n";class eu{constructor(e,t,n,r=!1){this.variableNames=["A","B"],this.supportsBroadcasting=!0,this.packedInputs=!0,this.packedOutput=!0,this.outputShape=c["backend_util"].assertAndGetBroadcastShape(t,n);const a=this.outputShape.length;this.enableShapeUniforms=us(a);let s="";if(r)if(0===a||1===c["util"].sizeFromShape(this.outputShape))s="\n          result.y = 0.;\n          result.z = 0.;\n          result.w = 0.;\n        ";else{const e=ts(a);if(s=`\n          ${e} coords = getOutputCoords();\n        `,1===a)this.enableShapeUniforms?s+="\n            result.y = (coords + 1) >= outShape ? 0. : result.y;\n            result.z = 0.;\n            result.w = 0.;\n          ":s+=`\n            result.y = (coords + 1) >= ${this.outputShape[0]} ? 0. : result.y;\n            result.z = 0.;\n            result.w = 0.;\n          `;else{const e=uc("coords",a);this.enableShapeUniforms?s+=`\n            bool nextRowOutOfBounds =\n              (${e[a-2]} + 1) >= outShape[${a} - 2];\n            bool nextColOutOfBounds =\n              (${e[a-1]} + 1) >= outShape[${a} - 1];\n            result.y = nextColOutOfBounds ? 0. : result.y;\n            result.z = nextRowOutOfBounds ? 0. : result.z;\n            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;\n          `:s+=`\n            bool nextRowOutOfBounds =\n              (${e[a-2]} + 1) >= ${this.outputShape[a-2]};\n            bool nextColOutOfBounds =\n              (${e[a-1]} + 1) >= ${this.outputShape[a-1]};\n            result.y = nextColOutOfBounds ? 0. : result.y;\n            result.z = nextRowOutOfBounds ? 0. : result.z;\n            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;\n          `}}this.userCode=`\n      vec4 binaryOperation(vec4 a, vec4 b) {\n        ${e}\n      }\n\n      void main() {\n        vec4 a = getAAtOutCoords();\n        vec4 b = getBAtOutCoords();\n\n        vec4 result = binaryOperation(a, b);\n        ${s}\n\n        setOutput(result);\n      }\n    `}}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tu(e){const{inputs:t,backend:n}=e,{x:r}=t;return n.incRef(r.dataId),{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}const nu={kernelName:c["Identity"],backendName:"webgl",kernelFunc:tu};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ru(e){const{inputs:t,backend:n}=e,{real:r,imag:a}=t,s=n.makeTensorInfo(r.shape,"complex64"),o=n.texData.get(s.dataId),i=tu({inputs:{x:r},backend:n}),c=tu({inputs:{x:a},backend:n});return o.complexTensorInfos={real:i,imag:c},s}const au={kernelName:c["Complex"],backendName:"webgl",kernelFunc:ru},su="return (a < 0.) ? b * a : a;",ou="\n  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));\n  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);\n";
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function iu(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{alpha:s}=r,o=n.makeTensorInfo([],"float32",c["util"].createScalarValue(s,"float32")),i=Object(c["env"])().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new eu(ou,a.shape,o.shape):new Zc(su,a.shape,o.shape),u=n.runWebGLProgram(i,[a,o],a.dtype);return n.disposeIntermediateTensorInfo(o),u}const cu={kernelName:c["LeakyRelu"],backendName:"webgl",kernelFunc:iu},uu="return (a < 0.) ? b * a : a;",lu="\n  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));\n  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);\n";
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function du(e){const{inputs:t,backend:n}=e,{x:r,alpha:a}=t,s=Object(c["env"])().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new eu(lu,r.shape,a.shape):new Zc(uu,r.shape,a.shape);return n.runWebGLProgram(s,[r,a],r.dtype)}const pu={kernelName:c["Prelu"],backendName:"webgl",kernelFunc:du},hu="if (isnan(x)) return x;",fu="\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n",mu="\n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n";
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bu({opSnippet:e,packedOpSnippet:t,cpuKernelImpl:n,dtype:r}){return({inputs:a,backend:s})=>{const{x:o}=a,i=s,u=r||o.dtype;if(i.shouldExecuteOnCPU([o])&&null!=n){const e=i.texData.get(o.dataId),t=n(e.values,u);return i.makeTensorInfo(o.shape,u,t)}const l=Object(c["env"])().getBool("WEBGL_PACK_UNARY_OPERATIONS")&&null!=t;let d;return d=l?new Pc(o.shape,t):new Sc(o.shape,e),i.runWebGLProgram(d,[o],u)}}function gu({opSnippet:e,packedOpSnippet:t,checkOutOfBounds:n=!1,supportsComplex:r=!1,cpuKernelImpl:a,dtype:s}){return({inputs:o,backend:i})=>{const{a:u,b:l}=o,d=i;if(r&&"complex64"===u.dtype){const t=d.texData.get(u.dataId),n=d.texData.get(l.dataId),[r,a]=[[t.complexTensorInfos.real,n.complexTensorInfos.real],[t.complexTensorInfos.imag,n.complexTensorInfos.imag]].map(t=>{const[n,r]=t,a={dataId:n.dataId,dtype:n.dtype,shape:u.shape},s={dataId:r.dataId,dtype:r.dtype,shape:l.shape},o=new Zc(e,u.shape,l.shape);return d.runWebGLProgram(o,[a,s],Object(c["upcastType"])(n.dtype,r.dtype))}),s=ru({inputs:{real:r,imag:a},backend:d});return d.disposeIntermediateTensorInfo(r),d.disposeIntermediateTensorInfo(a),s}const p=s||Object(c["upcastType"])(u.dtype,l.dtype);if(("string"===u.dtype||"string"===l.dtype||d.shouldExecuteOnCPU([u,l]))&&null!=a){const e=d.texData.get(u.dataId).values,t=d.texData.get(l.dataId).values,n="string"===u.dtype?c["backend_util"].fromUint8ToStringArray(e):e,r="string"===u.dtype?c["backend_util"].fromUint8ToStringArray(t):t,[s,o]=a(u.shape,l.shape,n,r,p),i=d.makeTensorInfo(o,p),h=d.texData.get(i.dataId);return h.values=s,i}const h=Object(c["env"])().getBool("WEBGL_PACK_BINARY_OPERATIONS")&&null!=t;let f;return f=h?new eu(t,u.shape,l.shape,n):new Zc(e,u.shape,l.shape),d.runWebGLProgram(f,[u,l],p)}}function yu(e,t=!1){if("linear"===e)return t?_c:Cc;if("relu"===e)return t?Dc:$c;if("elu"===e)return t?Fc:Tc;if("relu6"===e)return t?Mc:Ec;if("prelu"===e)return t?lu:uu;if("leakyrelu"===e)return t?ou:su;if("sigmoid"===e)return t?Lc:Rc;throw new Error(`Activation ${e} has not been implemented for the WebGL backend.`)}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class xu{constructor(e,t,n,r=!1,a=!1,s=!1,o=null,i=!1,c=!1){this.variableNames=["matrixA","matrixB"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=n,this.enableShapeUniforms=us(this.outputShape.length);const u=r?e[1]:e[2],l=Math.ceil(u/2),d=r?"i * 2, rc.y":"rc.y, i * 2",p=a?"rc.z, i * 2":"i * 2, rc.z",h=r?["a.xxyy","a.zzww"]:["a.xxzz","a.yyww"],f=a?["b.xzxz","b.ywyw"]:["b.xyxy","b.zwzw"];let m="",b="";o&&(m=i?`vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          ${o}\n        }`:c?`vec4 activation(vec4 a) {\n          vec4 b = getLeakyreluAlphaAtOutCoords();\n          ${o}\n        }`:`vec4 activation(vec4 x) {\n          ${o}\n        }`,b="result = activation(result);");const g=s?"result += getBiasAtOutCoords();":"";s&&this.variableNames.push("bias"),i&&this.variableNames.push("preluActivationWeights"),c&&this.variableNames.push("leakyreluAlpha");let y="rc.x",x="rc.x";e[0]<t[0]?y=`int(min(float(rc.x), ${e[0]-1}.))`:t[0]<e[0]&&(x=`int(min(float(rc.x), ${t[0]-1}.))`),this.userCode=`\n      ${m}\n      // Don't use uniform for sharedDimensionPacked for performance.\n      const float sharedDimension = ${l}.0;\n\n      vec4 dot2x2ARowBCol(ivec3 rc) {\n        vec4 result = vec4(0);\n        for (int i = 0; i < ${l}; i++) {\n          int batchA = ${y};\n          int batchB = ${x};\n          vec4 a = getMatrixA(batchA, ${d});\n          vec4 b = getMatrixB(batchB, ${p});\n\n          // These swizzled products need to be separately added.\n          // See: https://github.com/tensorflow/tfjs/issues/1735\n          result += (${h[0]} * ${f[0]});\n          result += (${h[1]} * ${f[1]});\n        }\n        return result;\n      }\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n        vec4 result = dot2x2ARowBCol(rc);\n\n        ${g}\n\n        ${b}\n\n        setOutput(result);\n      }\n    `}}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ou={REAL:"return areal * breal - aimag * bimag;",IMAG:"return areal * bimag + aimag * breal;"};class vu{constructor(e,t,n){this.variableNames=["AReal","AImag","BReal","BImag"],this.outputShape=c["backend_util"].assertAndGetBroadcastShape(t,n),this.userCode=`\n      float binaryOpComplex(\n          float areal, float aimag, float breal, float bimag) {\n        ${e}\n      }\n\n      void main() {\n        float areal = getARealAtOutCoords();\n        float aimag = getAImagAtOutCoords();\n        float breal = getBRealAtOutCoords();\n        float bimag = getBImagAtOutCoords();\n        setOutput(binaryOpComplex(areal, aimag, breal, bimag));\n      }\n    `}}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const wu="return a * b;";function ku(e){const{inputs:t,backend:n}=e,{a:r,b:a}=t,s=c["backend_util"].upcastType(r.dtype,a.dtype);if("complex64"===r.dtype){const e=n.texData.get(r.dataId),t=n.texData.get(a.dataId),s=new vu(Ou.REAL,r.shape,a.shape),o=new vu(Ou.IMAG,r.shape,a.shape),i=[{dataId:e.complexTensorInfos.real.dataId,dtype:e.complexTensorInfos.real.dtype,shape:r.shape},{dataId:e.complexTensorInfos.imag.dataId,dtype:e.complexTensorInfos.imag.dtype,shape:r.shape},{dataId:t.complexTensorInfos.real.dataId,dtype:t.complexTensorInfos.real.dtype,shape:a.shape},{dataId:t.complexTensorInfos.imag.dataId,dtype:t.complexTensorInfos.imag.dtype,shape:a.shape}],c=n.runWebGLProgram(s,i,"float32"),u=n.runWebGLProgram(o,i,"float32"),l=ru({inputs:{real:c,imag:u},backend:n});return n.disposeIntermediateTensorInfo(c),n.disposeIntermediateTensorInfo(u),l}if(n.shouldExecuteOnCPU([r,a])){const e=n.texData.get(r.dataId),t=n.texData.get(a.dataId),[o,i]=Bi(r.shape,a.shape,e.values,t.values,s),c=n.makeTensorInfo(i,s),u=n.texData.get(c.dataId);return u.values=o,c}let o;return o=Object(c["env"])().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new eu(wu,r.shape,a.shape):new Zc(wu,r.shape,a.shape),n.runWebGLProgram(o,[r,a],s)}const ju={kernelName:c["Multiply"],backendName:"webgl",kernelFunc:ku};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Su(e,t,n){const r=[Pr(e.shape),...Br(e.shape)],a={dtype:e.dtype,shape:r,dataId:e.dataId},s=[Pr(t),...Br(t)],o=new bc(s,r),i=!0,c=[r],u=n.runWebGLProgram(o,[a],e.dtype,c,i);return{dataId:u.dataId,shape:t,dtype:u.dtype}}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Nu(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{shape:s}=r,o=n,i=c["util"].sizeFromShape(a.shape),u=c["util"].inferFromImplicitShape(s,i),l=c["util"].sizeFromShape(u);c["util"].assert(i===l,()=>`The new shape (${u}) has ${l} elements and the old shape (${a.shape}) has ${i} elements. The new shape and old shape must have the same number of elements.`);const d=o.texData.get(a.dataId);return!d.isPacked||Ur(a.shape,u)||null!==d.texture&&Ur(d.shape,u)?(o.incRef(a.dataId),{dataId:a.dataId,shape:u,dtype:a.dtype}):Su(a,u,o)}const Cu={kernelName:c["Reshape"],backendName:"webgl",kernelFunc:Nu};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Iu{constructor(e,t){this.variableNames=["x"];const{windowSize:n,batchSize:r,inSize:a,outSize:s}=e;this.outputShape=[r,s];const o=4*Math.floor(n/4),i=n%4;let u="sumValue += dot(values, ones);";if(null!=t){const e=1/t;u=`sumValue += dot(values * ${c["util"].isInt(e)?e.toPrecision(2):e}, ones);`}let l="";a%n>0&&(l=`\n        if (inIdx < 0 || inIdx >= ${a}) {\n          return 0.0;\n        }\n      `),this.userCode=`\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        ${l}\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${n};\n\n        float sumValue = 0.0;\n\n        for (int i = 0; i < ${o}; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          ${u}\n        }\n\n        int inIdx = inOffset + ${o};\n        if (${1===i}) {\n          vec4 values = vec4(getValue(batch, inIdx), 0.0, 0.0, 0.0);\n\n          ${u}\n        } else if (${2===i}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1), 0.0, 0.0);\n\n          ${u}\n        } else if (${3===i}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2), 0.0);\n\n          ${u}\n        }\n        setOutput(sumValue);\n      }\n    `}}
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Tu{constructor(e,t){this.variableNames=["x"];const{windowSize:n,batchSize:r,inSize:a,outSize:s}=e;this.outputShape=[r,s];let o="0.0",i="";"prod"===t?o="1.0":"min"===t?(o="1.0 / 1e-20",i="min"):"max"===t&&(o="-1.0 / 1e-20",i="max");let c=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;"sum"===t?c="sumValue":"prod"===t?c="prodValue":"all"===t?c="allValue":"any"===t&&(c="anyValue");const u=4*Math.floor(n/4),l=n%4;let d=`\n      if (${"sum"===t}) {\n        sumValue += dot(values, ones);\n      } else if (${"prod"===t}) {\n        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);\n        prodValue *= tmp[0] * tmp[1];\n      } else {\n        minMaxValue = ${i}(values, minMaxValue);\n        if (${"min"===t} || ${"max"===t}) {\n          minMaxValue = ${i}(values, minMaxValue);\n          bvec4 isNaN = isnan(values);\n          if (isNaN.r || isNaN.g || isNaN.b || isNaN.a) {\n            minMaxValue = vec4(NAN);\n          }\n        }\n      }\n    `,p="vec4";"all"===t?(o="1.0",d="\n        bool reducedAllValue = all(values);\n        float floatedReducedAllValue = float(reducedAllValue);\n        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);\n      ",p="bvec4"):"any"===t&&(o="0.0",d="\n        bool reducedAnyValue = any(values);\n        float floatedReducedAnyValue = float(reducedAnyValue);\n        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);\n      ",p="bvec4");let h="";a%n>0&&(h=`\n        if (inIdx < 0 || inIdx >= ${a}) {\n          return initializationValue;\n        }\n      `),this.userCode=`\n      const float initializationValue = ${o};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        ${h}\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${n};\n\n        vec4 minMaxValue = vec4(${o});\n        float prodValue = 1.0;\n        float sumValue = 0.0;\n        float allValue = 1.0;\n        float anyValue = 0.0;\n\n        for (int i = 0; i < ${u}; i += 4) {\n          int inIdx = inOffset + i;\n          ${p} values = ${p}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          ${d}\n        }\n\n        int inIdx = inOffset + ${u};\n        if (${1===l}) {\n          ${p} values = ${p}(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          ${d}\n        } else if (${2===l}) {\n          ${p} values = ${p}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          ${d}\n        } else if (${3===l}) {\n          ${p} values = ${p}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          ${d}\n        }\n        setOutput(${c});\n      }\n    `}}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $u(e){const t=[];while(0===t.length||1!==t[t.length-1].outSize){const n=t.length?t[t.length-1].outSize:e[1],r=c["backend_util"].computeOptimalWindowSize(n);t.push({inSize:n,windowSize:r,outSize:Math.ceil(n/r)})}return t}function Eu(e,t,n,r){const a=$u(e.shape);let s=e;for(let o=0;o<a.length;o++){const{inSize:i,windowSize:c,outSize:u}=a[o];let l,d;l="mean"===n?0===o?new Iu({windowSize:c,inSize:i,batchSize:e.shape[0],outSize:u},i):new Iu({windowSize:c,inSize:i,batchSize:e.shape[0],outSize:u}):new Tu({windowSize:c,inSize:i,batchSize:e.shape[0],outSize:u},n),d=s,s=r.runWebGLProgram(l,[s],t),d.dataId!==e.dataId&&r.disposeIntermediateTensorInfo(d)}return s}
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Au{constructor(e,t){this.variableNames=["A"];const n=new Array(e.length);for(let s=0;s<n.length;s++)n[s]=e[t[s]];this.outputShape=n,this.rank=n.length;const r=ts(this.rank),a=Ru(t);this.userCode=`\n    void main() {\n      ${r} resRC = getOutputCoords();\n      setOutput(getA(${a}));\n    }\n    `}}function Ru(e){const t=e.length;if(t>6)throw Error(`Transpose for rank ${t} is not yet supported`);const n=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u","resRC.v"],r=new Array(t);for(let a=0;a<e.length;a++)r[e[a]]=n[a];return r.join()}
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class _u{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0;const n=new Array(e.length);for(let u=0;u<n.length;u++)n[u]=e[t[u]];if(this.outputShape=n,this.rank=n.length,this.rank>6)throw Error(`Packed transpose for rank ${this.rank} is not yet supported.`);const r=ts(this.rank),a=cc("rc",this.rank),s=new Array(this.rank);for(let u=0;u<t.length;u++)s[t[u]]=a[u];const o=`vec2(${s.slice(-2).join()})`,i=`++${a[this.rank-1]} < ${n[this.rank-1]}`,c=`getChannel(getA(${s.join()}), ${o})`;this.userCode=`\n    void main() {\n      ${r} rc = getOutputCoords();\n      vec4 result = vec4(0.);\n      result[0] = ${c};\n      if(${i}) {\n        result[1] = ${c};\n      }\n      --${a[this.rank-1]};\n      if(++${a[this.rank-2]} < ${n[this.rank-2]}) {\n        result[2] = ${c};\n        if(${i}) {\n          result[3] = ${c};\n        }\n      }\n      setOutput(result);\n    }\n    `}}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Fu(e,t,n){const r=Object(c["env"])().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new _u(e.shape,t):new Au(e.shape,t);return n.runWebGLProgram(r,[e],e.dtype)}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Du(e,t,n,r){const a=t,s=e.shape.length,o=c["util"].parseAxisParam(a,e.shape);let i=o;const u=c["backend_util"].getAxesPermutation(i,s),l=null!=u;let d=e;l&&(d=Fu(e,u,r),i=c["backend_util"].getInnerMostAxes(i.length,s)),c["backend_util"].assertAxesAreInnerMostDims("sum",i,s);const[p,h]=c["backend_util"].computeOutAndReduceShapes(d.shape,i);let f=p;n&&(f=c["backend_util"].expandShapeToKeepDim(p,o));const m=c["util"].sizeFromShape(h),b=c["util"].sizeFromShape(e.shape),g=b/m,y=Nu({inputs:{x:d},attrs:{shape:[g,m]},backend:r}),x=Object(c["sumOutType"])(e.dtype),O=Eu(y,x,"sum",r),v=Nu({inputs:{x:O},attrs:{shape:f},backend:r});return r.disposeIntermediateTensorInfo(y),r.disposeIntermediateTensorInfo(O),l&&r.disposeIntermediateTensorInfo(d),v}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Mu(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,keepDims:o}=r;return Du(a,s,o,n)}const Lu={kernelName:c["Sum"],backendName:"webgl",kernelFunc:Mu};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Pu(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{perm:s}=r,o=n,i=a.shape.length,c=new Array(i);for(let l=0;l<c.length;l++)c[l]=a.shape[s[l]];let u;if(o.shouldExecuteOnCPU([a])){const e=o.texData.get(a.dataId),t=e.values,n=oc(t,a.shape,a.dtype,s,c);u=o.makeTensorInfo(c,a.dtype);const r=o.texData.get(u.dataId);r.values=n}else u=Fu(a,s,o);return u}const Bu={kernelName:c["Transpose"],backendName:"webgl",kernelFunc:Pu},Vu=1e3;
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zu({a:e,b:t,transposeA:n,transposeB:r,backend:a,bias:s=null,preluActivationWeights:o=null,leakyreluAlpha:i=0,activation:u=null}){const l=e.shape.length,d=t.shape.length,p=n?e.shape[l-2]:e.shape[l-1],h=r?t.shape[d-1]:t.shape[d-2],f=n?e.shape[l-1]:e.shape[l-2],m=r?t.shape[d-2]:t.shape[d-1],b=e.shape.slice(0,-2),g=t.shape.slice(0,-2),y=c["util"].sizeFromShape(b),x=c["util"].sizeFromShape(g),O=y===x||1===y||1===x;c["util"].assert(l>=2&&d>=2&&O,()=>`Error in matMul: the input batch dimensions must either be the same or at least one input batch dimension must be 1. Got input batch dimensions of (${b}) and (${g}).`);const v=y>x?e.shape.slice(0,-2):t.shape.slice(0,-2),w=v.concat([f,m]);c["util"].assert(p===h,()=>`Error in matMul: inner shapes (${p}) and (${h}) of Tensors with shapes ${e.shape} and ${t.shape} and transposeA=${n} and transposeB=${r} must match.`);const k=n?[y,p,f]:[y,f,p],j=r?[x,m,h]:[x,h,m],S=Nu({inputs:{x:e},backend:a,attrs:{shape:k}}),N=Nu({inputs:{x:t},backend:a,attrs:{shape:j}}),C=[S,N],I=Math.max(y,x),T=n?S.shape[1]:S.shape[2],$=null!=s,E=null!=o,A="leakyrelu"===u,R=null!=u?yu(u,!0):null,_=$||E||A||null!=R;let F;if((1===f||1===m)&&T>Vu&&!1===_){let e=S,t=N;n&&(e=Pu({inputs:{x:S},backend:a,attrs:{perm:[0,2,1]}}),C.push(e)),r&&(t=Pu({inputs:{x:N},backend:a,attrs:{perm:[0,2,1]}}),C.push(t));const s=1!==m,o=1===m;let i=e;s&&(i=Nu({inputs:{x:e},backend:a,attrs:{shape:[I,T,1]}}),C.push(i));const c=1===m?2:1;let u=t;o&&(u=Nu({inputs:{x:t},backend:a,attrs:{shape:[I,1,T]}}),C.push(u));const l=ku({inputs:{a:i,b:u},backend:a});F=Mu({inputs:{x:l},backend:a,attrs:{axis:c,keepDims:!0}}),C.push(l)}else{const u=Object(c["upcastType"])(e.dtype,t.dtype),l=new xu(k,j,[I,f,m],n,r,$,R,E,A),d=[S,N];if(null!=s&&d.push(s),E&&d.push(o),A){const e=a.makeTensorInfo([],"float32",c["util"].createScalarValue(i,"float32"));d.push(e),C.push(e)}F=a.runWebGLProgram(l,d,u)}const D=Nu({inputs:{x:F},backend:a,attrs:{shape:w}});C.push(F);for(const c of C)a.disposeIntermediateTensorInfo(c);return D}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Wu(e){const{inputs:t,backend:n,attrs:r}=e,{a:a,b:s,bias:o,preluActivationWeights:i}=t,{transposeA:c,transposeB:u,activation:l,leakyreluAlpha:d}=r;return zu({a:a,b:s,transposeA:c,transposeB:u,backend:n,bias:o,preluActivationWeights:i,leakyreluAlpha:d,activation:l})}const Uu={kernelName:c["_FusedMatMul"],backendName:"webgl",kernelFunc:Wu},Gu="return abs(x);";
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Hu(e){const{inputs:t,backend:n}=e,{x:r}=t;if(n.shouldExecuteOnCPU([r])&&"complex64"!==r.dtype){const e=n.texData.get(r.dataId),t=qi(e.values);return n.makeTensorInfo(r.shape,r.dtype,t)}let a;return a=Object(c["env"])().getBool("WEBGL_PACK_UNARY_OPERATIONS")?new Pc(r.shape,Gu):new Sc(r.shape,Gu),n.runWebGLProgram(a,[r],r.dtype)}const qu={kernelName:c["Abs"],backendName:"webgl",kernelFunc:Hu},Ku=Nc+"\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return acos(x);\n",Xu=bu({opSnippet:Ku}),Yu={kernelName:c["Acos"],backendName:"webgl",kernelFunc:Xu},Qu=Nc+"\n  if (x < 1.0) return NAN;\nreturn log(x + sqrt(x * x - 1.0));",Zu=bu({opSnippet:Qu}),Ju={kernelName:c["Acosh"],backendName:"webgl",kernelFunc:Zu},el="return a + b;",tl=gu({opSnippet:el,packedOpSnippet:el,supportsComplex:!0,cpuKernelImpl:Oi}),nl={kernelName:c["Add"],backendName:"webgl",kernelFunc:tl};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class rl{constructor(e,t){this.outputShape=[],this.outputShape=e,this.variableNames=t.map((e,t)=>"T"+t);const n=[];this.variableNames.forEach(e=>{n.push(`float v${e} = get${e}AtOutCoords();`)});const r=this.variableNames.map(e=>"v"+e).join(" + ");this.userCode=`\n      void main() {\n        ${n.join("\n        ")}\n\n        float result = ${r};\n        setOutput(result);\n      }\n    `}}
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class al{constructor(e,t){this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.variableNames=t.map((e,t)=>"T"+t);const n=[];this.variableNames.forEach(e=>{n.push(`vec4 v${e} = get${e}AtOutCoords();`)});const r=this.variableNames.map(e=>"v"+e).join(" + ");this.userCode=`\n      void main() {\n        ${n.join("\n        ")}\n\n        vec4 result = ${r};\n        setOutput(result);\n      }\n    `}}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sl(e){const{inputs:t,backend:n}=e,r=t;if(1===r.length)return tu({inputs:{x:r[0]},backend:n});if(r.length>Object(c["env"])().get("WEBGL_MAX_TEXTURES_IN_SHADER")){const e=Math.floor(r.length/2),t=sl({inputs:r.slice(0,e),backend:n}),a=sl({inputs:r.slice(e),backend:n});return sl({inputs:[t,a],backend:n})}const a=r.map(e=>e.dtype).reduce((e,t)=>Object(c["upcastType"])(e,t)),s=r.map(e=>e.shape),o=Object(c["env"])().getBool("WEBGL_PACK"),i=o?new al(r[0].shape,s):new rl(r[0].shape,s);return n.runWebGLProgram(i,r,a)}const ol={kernelName:c["AddN"],backendName:"webgl",kernelFunc:sl};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function il(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,keepDims:o}=r,i=a.shape.length,u=c["util"].parseAxisParam(s,a.shape);let l=u;const d=c["backend_util"].getAxesPermutation(l,i);let p=a;null!=d&&(p=Pu({inputs:{x:a},backend:n,attrs:{perm:d}}),l=c["backend_util"].getInnerMostAxes(l.length,i)),c["backend_util"].assertAxesAreInnerMostDims("all",l,i);const[h,f]=c["backend_util"].computeOutAndReduceShapes(p.shape,l),m=c["util"].sizeFromShape(f),b=Nu({inputs:{x:p},backend:n,attrs:{shape:[-1,m]}}),g=Eu(b,b.dtype,"all",n);let y;if(o){const e=c["backend_util"].expandShapeToKeepDim(h,u);y=Nu({inputs:{x:g},backend:n,attrs:{shape:e}})}else y=Nu({inputs:{x:g},backend:n,attrs:{shape:h}});return n.disposeIntermediateTensorInfo(b),n.disposeIntermediateTensorInfo(g),null!=d&&n.disposeIntermediateTensorInfo(p),y}const cl={kernelName:c["All"],backendName:"webgl",kernelFunc:il};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ul(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,keepDims:o}=r,i=a.shape.length,u=c["util"].parseAxisParam(s,a.shape);let l=u;const d=c["backend_util"].getAxesPermutation(l,i);let p=a;null!=d&&(p=Pu({inputs:{x:a},backend:n,attrs:{perm:d}}),l=c["backend_util"].getInnerMostAxes(l.length,i)),c["backend_util"].assertAxesAreInnerMostDims("any",l,i);const[h,f]=c["backend_util"].computeOutAndReduceShapes(p.shape,l),m=c["util"].sizeFromShape(f),b=Nu({inputs:{x:p},backend:n,attrs:{shape:[-1,m]}}),g=Eu(b,b.dtype,"any",n);let y;if(o){const e=c["backend_util"].expandShapeToKeepDim(h,u);y=Nu({inputs:{x:g},backend:n,attrs:{shape:e}})}else y=Nu({inputs:{x:g},backend:n,attrs:{shape:h}});return n.disposeIntermediateTensorInfo(b),n.disposeIntermediateTensorInfo(g),null!=d&&n.disposeIntermediateTensorInfo(p),y}const ll={kernelName:c["Any"],backendName:"webgl",kernelFunc:ul};
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class dl{constructor(e,t,n){this.variableNames=["A"];const{windowSize:r,batchSize:a,outSize:s}=e;n||this.variableNames.push("bestIndicesA"),this.outputShape=[a,s];const o="max"===t?">":"<",i=n?"inOffset + i;":"round(getBestIndicesA(batch, inOffset + i));";this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${r};\n\n        int bestIndex = inOffset;\n        float bestValue = getA(batch, bestIndex);\n\n        for (int i = 0; i < ${r}; i++) {\n          int inIdx = ${i};\n          float candidate = getA(batch, inIdx);\n          if (candidate ${o} bestValue) {\n            bestValue = candidate;\n            bestIndex = inIdx;\n          }\n        }\n        setOutput(float(bestIndex));\n      }\n    `}}
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class pl{constructor(e,t,n,r){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,c["util"].assert(e.length>2,()=>`Packed arg${n.charAt(0).toUpperCase()+n.slice(1)} supports only inputs with rank above 2.`);const a=e[e.length-1],s=Math.ceil(a/t);this.outputShape=e.slice(0,-1),s>1&&this.outputShape.push(s),r||this.variableNames.push("bestIndicesA");const o=this.outputShape,i=o.length,u=ts(i),l=uc("coords",i);let d,p;if(1===s){p=i+1;const e=ts(p);d=`\n        ${e} sourceLocR = ${e}(${l.join()}, 0);\n        ++${l[i-1]};\n        ${e} sourceLocG = ${e}(${l.join()}, 0);\n        ++${l[i-2]};\n        ${e} sourceLocA = ${e}(${l.join()}, 0);\n        --${l[i-1]};\n        ${e} sourceLocB = ${e}(${l.join()}, 0);\n        --${l[i-2]};`}else p=i,d=`\n        ${u} sourceLocR = coords;\n        ++${l[i-1]};\n        ${u} sourceLocG = coords;\n        ++${l[i-2]};\n        ${u} sourceLocA = coords;\n        --${l[i-1]};\n        ${u} sourceLocB = coords;\n        --${l[i-2]};`;const h=["x","y","z","w","u","v"].slice(0,p),f="."+h[p-1],m=h.map(e=>"int "+e),b=uc("sourceLocR",p-1).concat("inIdx.r"),g=uc("sourceLocG",p-1).concat("inIdx.g"),y=uc("sourceLocB",p-1).concat("inIdx.b"),x=uc("sourceLocA",p-1).concat("inIdx.a"),O="max"===n?"greaterThan":"lessThan",v=r?"":`\n          inIdx = round(vec4(getBestIndicesAChannel(${b.join()}),\n                             getBestIndicesAChannel(${g.join()}),\n                             getBestIndicesAChannel(${y.join()}),\n                             getBestIndicesAChannel(${x.join()})));`,w=`vec4(\n            getAChannel(${b.join()}),\n            hasNextCol ? getAChannel(${g.join()}) : 0.,\n            hasNextRow ? getAChannel(${y.join()}) : 0.,\n            hasNextRow && hasNextCol ? getAChannel(${x.join()}) : 0.)`,k=r?"":`\n      float getBestIndicesAChannel(${m.join()}) {\n        return getChannel(getBestIndicesA(${h.join()}),\n                                          vec2(${h.slice(-2).join()}));\n      }`;this.userCode=`\n      float getAChannel(${m.join()}) {\n        return getChannel(getA(${h.join()}),\n                               vec2(${h.slice(-2).join()}));\n      }\n      ${k}\n      void main() {\n        ${u} coords = getOutputCoords();\n        bool hasNextCol = ${l[i-1]} < ${o[i-1]-1};\n        bool hasNextRow = ${l[i-2]} < ${o[i-2]-1};\n        ${d}\n        ivec4 srcIdx = ivec4(sourceLocR${f}, sourceLocG${f},\n          sourceLocB${f}, sourceLocA${f}) * ${t};\n        ivec4 inIdx = srcIdx;\n        vec4 bestIndex = vec4(inIdx);\n        vec4 bestValue = ${w};\n\n        for (int i = 0; i < ${t}; i++) {\n          inIdx = srcIdx;\n          ${v}\n          vec4 candidate = ${w};\n          bvec4 nan = isnan(candidate);\n          bvec4 replace = bvec4(\n            vec4(${O}(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));\n\n          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,\n                           replace.y  ? candidate.y : bestValue.y,\n                           replace.z  ? candidate.z : bestValue.z,\n                           replace.w  ? candidate.w : bestValue.w);\n          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));\n          srcIdx++;\n        }\n        setOutput(bestIndex);\n      }\n    `}}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hl(e,t,n,r=null){let a=t.shape[0],s=t.shape[1];null!=r&&(a=r.shape[0],s=r.shape[1]);const o=c["backend_util"].computeOptimalWindowSize(s),i={windowSize:o,inSize:s,batchSize:a,outSize:Math.ceil(s/o)},u=new dl(i,n,null==r),l=[t];null!=r&&l.push(r);const d=e.runWebGLProgram(u,l,"int32");if(1===d.shape[1])return d;const p=hl(e,t,n,d);return e.disposeIntermediateTensorInfo(d),p}function fl(e,t,n,r=null){const a=null!=r?r.shape:t.shape,s=a[a.length-1],o=c["backend_util"].computeOptimalWindowSize(s),i=new pl(a,o,n,null==r),u=null==r?[t]:[t,r],l=e.runWebGLProgram(i,u,"int32");if(l.shape.length===t.shape.length){const r=fl(e,t,n,l);return e.disposeIntermediateTensorInfo(l),r}return l}function ml(e,t,n,r){const a=[n];if(c["backend_util"].assertAxesAreInnerMostDims("arg"+r.charAt(0).toUpperCase()+r.slice(1),a,t.shape.length),!Object(c["env"])().getBool("WEBGL_PACK_REDUCE")||t.shape.length<=2){const n=[],s=e.texData.get(t.dataId),o=null!==s&&s.isPacked;let i=t;o&&(i=e.unpackTensor(t),n.push(i));const[u,l]=c["backend_util"].computeOutAndReduceShapes(i.shape,a),d=c["util"].sizeFromShape(l),p=Nu({inputs:{x:i},backend:e,attrs:{shape:[-1,d]}});n.push(p);const h=hl(e,p,r);n.push(h);const f=Nu({inputs:{x:h},backend:e,attrs:{shape:u}});return n.forEach(t=>e.disposeIntermediateTensorInfo(t)),f}return fl(e,t,r)}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bl(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s}=r;let o=c["util"].parseAxisParam(s,a.shape);const i=c["backend_util"].getAxesPermutation(o,a.shape.length);let u=a;const l=[];null!=i&&(u=Pu({inputs:{x:a},backend:n,attrs:{perm:i}}),l.push(u),o=c["backend_util"].getInnerMostAxes(o.length,u.shape.length)),c["backend_util"].assertAxesAreInnerMostDims("argMax",[o[0]],u.shape.length);const d=ml(n,u,o[0],"max");return l.forEach(e=>n.disposeIntermediateTensorInfo(e)),d}const gl={kernelName:c["ArgMax"],backendName:"webgl",kernelFunc:bl};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yl(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s}=r;let o=c["util"].parseAxisParam(s,a.shape);const i=c["backend_util"].getAxesPermutation(o,a.shape.length);let u=a;const l=[];null!=i&&(u=Pu({inputs:{x:a},backend:n,attrs:{perm:i}}),l.push(u),o=c["backend_util"].getInnerMostAxes(o.length,u.shape.length)),c["backend_util"].assertAxesAreInnerMostDims("argMin",[o[0]],u.shape.length);const d=ml(n,u,o[0],"min");return l.forEach(e=>n.disposeIntermediateTensorInfo(e)),d}const xl={kernelName:c["ArgMin"],backendName:"webgl",kernelFunc:yl},Ol=Nc+"\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return asin(x);\n",vl=bu({opSnippet:Ol}),wl={kernelName:c["Asin"],backendName:"webgl",kernelFunc:vl},kl=Nc+"return log(x + sqrt(x * x + 1.0));",jl=bu({opSnippet:kl}),Sl={kernelName:c["Asinh"],backendName:"webgl",kernelFunc:jl},Nl=Nc+"\n  return atan(x);\n",Cl=bu({opSnippet:Nl}),Il={kernelName:c["Atan"],backendName:"webgl",kernelFunc:Cl},Tl=fu+"\n  return atan(a, b);\n",$l="\n  vec4 result = atan(a, b);\n  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));\n  "+mu+"\n  return result;\n",El=gu({opSnippet:Tl,packedOpSnippet:$l}),Al={kernelName:c["Atan2"],backendName:"webgl",kernelFunc:El},Rl=Nc+"\n  if ((x < -1.0) || (x > 1.0)) return NAN;\nreturn (log(1.0 + x) - log(1.0 - x)) / 2.0;",_l=bu({opSnippet:Rl}),Fl={kernelName:c["Atanh"],backendName:"webgl",kernelFunc:_l};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class Dl{constructor(e,t,n,r=!1,a=!1){if(this.variableNames=["x"],"avg"===t&&n)throw new Error("Cannot compute positions for average pool.");const s=e.filterWidth,o=e.strideHeight,i=e.strideWidth,c=e.dilationHeight,u=e.dilationWidth,l=e.effectiveFilterHeight,d=e.effectiveFilterWidth,p=e.padInfo.top,h=e.padInfo.left;this.outputShape=e.outShape;const f="avg"===t,m=`((batch  * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + d`,b=`(xR * ${e.inWidth} + xC) * ${e.inChannels} + d`;let g="0.0";if(f||(g="-1.0 / 1e-20"),n){const t=">=";return void(this.userCode=`\n        const ivec2 strides = ivec2(${o}, ${i});\n        const ivec2 pads = ivec2(${p}, ${h});\n\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int batch = coords[0];\n          int d = coords[3];\n\n          ivec2 xRCCorner = coords.yz * strides - pads;\n          int xRCorner = xRCCorner.x;\n          int xCCorner = xRCCorner.y;\n\n          // max/min x(?, ?, d) to get y(yR, yC, d).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n          float avgValue = 0.0;\n\n          for (int wR = 0; wR < ${l};\n              wR += ${c}) {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= ${e.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${d};\n                wC += ${u}) {\n              int xC = xCCorner + wC;\n\n              if (xC < 0 || xC >= ${e.inWidth}) {\n                continue;\n              }\n\n              float value = getX(batch, xR, xC, d);\n\n              // If a min / max value has already been found, use it. If not,\n              // use the current value.\n              float currMinMaxValue = mix(\n                  value, minMaxValue, minMaxValueFound);\n              if (value ${t} currMinMaxValue) {\n                minMaxValue = value;\n                minMaxValueFound = 1.0;\n                minMaxPosition = ${r?a?m:b:`wR * ${d} + wC`};\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      `)}const y="max";let x=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;"avg"===t&&(x="avgValue / count");const O=4*Math.floor(s/4),v=s%4,w=`\n      if (${f}) {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = ${y}(values, minMaxValue);\n      }\n    `;this.userCode=`\n      const ivec2 strides = ivec2(${o}, ${i});\n      const ivec2 pads = ivec2(${p}, ${h});\n      const float initializationValue = ${g};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xR, int xC, int d) {\n        if (xC < 0 || xC >= ${e.inWidth}) {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xR, xC, d);\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d = coords[3];\n\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // max/min x(?, ?, d) to get y(yR, yC, d).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(${g});\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wR = 0; wR < ${l};\n            wR += ${c}) {\n          int xR = xRCorner + wR;\n\n          if (xR < 0 || xR >= ${e.inHeight}) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${O}; wC += 4) {\n            int xC = xCCorner + wC * ${u};\n\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${u}, d),\n              getValue(batch, xR, xC + 2 * ${u}, d),\n              getValue(batch, xR, xC + 3 * ${u}, d)\n            );\n\n            ${w}\n          }\n\n          int xC = xCCorner + ${O};\n          if (${1===v}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              initializationValue,\n              initializationValue,\n              initializationValue\n            );\n\n            ${w}\n          } else if (${2===v}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${u}, d),\n              initializationValue,\n              initializationValue\n            );\n\n            ${w}\n          } else if (${3===v}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${u}, d),\n              getValue(batch, xR, xC + 2 * ${u}, d),\n              initializationValue\n            );\n\n            ${w}\n          }\n        }\n        setOutput(${x});\n      }\n    `}}class Ml{constructor(e,t,n,r=!1,a=!1){if(this.variableNames=["x"],"avg"===t&&n)throw new Error("Cannot compute positions for average pool.");const s=e.filterWidth,o=e.strideDepth,i=e.strideHeight,c=e.strideWidth,u=e.dilationDepth,l=e.dilationHeight,d=e.dilationWidth,p=e.effectiveFilterDepth,h=e.effectiveFilterHeight,f=e.effectiveFilterWidth,m=e.padInfo.front,b=e.padInfo.top,g=e.padInfo.left;this.outputShape=e.outShape;const y="avg"===t;let x="0.0";if(y||(x="-1.0 / 1e-20"),n){const t=">=";return void(this.userCode=`\n        const ivec3 strides =\n            ivec3(${o}, ${i}, ${c});\n        const ivec3 pads = ivec3(${m}, ${b}, ${g});\n\n        void main() {\n          ivec5 coords = getOutputCoords();\n          int batch = coords.x;\n          int ch = coords.u;\n\n          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n          int xDCorner = xCorner.x;\n          int xRCorner = xCorner.y;\n          int xCCorner = xCorner.z;\n\n          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n\n          for (int wD = 0; wD < ${p};\n              wD += ${u}) {\n            int xD = xDCorner + wD;\n\n            if (xD < 0 || xD >= ${e.inDepth}) {\n              continue;\n            }\n\n            for (int wR = 0; wR < ${h};\n                wR += ${l}) {\n              int xR = xRCorner + wR;\n\n              if (xR < 0 || xR >= ${e.inHeight}) {\n                continue;\n              }\n\n              for (int wC = 0; wC < ${f};\n                  wC += ${d}) {\n                int xC = xCCorner + wC;\n\n                if (xC < 0 || xC >= ${e.inWidth}) {\n                  continue;\n                }\n\n                float value = getX(batch, xD, xR, xC, ch);\n\n                // If a min / max value has already been found, use it. If not,\n                // use the current value.\n                float currMinMaxValue = mix(\n                    value, minMaxValue, minMaxValueFound);\n                if (value ${t} currMinMaxValue) {\n                  minMaxValue = value;\n                  minMaxValueFound = 1.0;\n                  minMaxPosition = ${r?a?`(((batch * ${e.inDepth} + xD) * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + ch`:`((xD * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + ch`:`wD * ${h} * ${f} +\n                      wR * ${f} + wC`};\n                }\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      `)}const O="max";let v=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;"avg"===t&&(v="avgValue / count");const w=4*Math.floor(s/4),k=s%4,j=`\n      if (${y}) {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = ${O}(values, minMaxValue);\n      }\n    `;this.userCode=`\n      const ivec3 strides =\n        ivec3(${o}, ${i}, ${c});\n      const ivec3 pads = ivec3(${m}, ${b}, ${g});\n      const float initializationValue = ${x};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xD, int xR, int xC, int ch) {\n        if (xC < 0 || xC >= ${e.inWidth}) {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xD, xR, xC, ch);\n      }\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xDCorner = xCorner.x;\n        int xRCorner = xCorner.y;\n        int xCCorner = xCorner.z;\n\n        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(${x});\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wD = 0; wD < ${p};\n            wD += ${u}) {\n          int xD = xDCorner + wD;\n\n          if (xD < 0 || xD >= ${e.inDepth}) {\n            continue;\n          }\n\n          for (int wR = 0; wR < ${h};\n            wR += ${l}) {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= ${e.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${w}; wC += 4) {\n              int xC = xCCorner + wC * ${d};\n\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${d}, ch),\n                getValue(batch, xD, xR, xC + 2 * ${d}, ch),\n                getValue(batch, xD, xR, xC + 3 * ${d}, ch)\n              );\n\n              ${j}\n            }\n\n            int xC = xCCorner + ${w};\n            if (${1===k}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                initializationValue,\n                initializationValue,\n                initializationValue\n              );\n\n              ${j}\n            } else if (${2===k}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${d}, ch),\n                initializationValue,\n                initializationValue\n              );\n\n              ${j}\n            } else if (${3===k}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${d}, ch),\n                getValue(batch, xD, xR, xC + 2 * ${d}, ch),\n                initializationValue\n              );\n\n              ${j}\n            }\n          }\n          setOutput(${v});\n        }\n      }\n    `}}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ll(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t;ra(a,"avgPool");const{filterSize:s,strides:o,pad:i,dimRoundingMode:u}=r,l=1;c["util"].assert(c["backend_util"].eitherStridesOrDilationsAreOne(o,l),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${o} and dilations '${l}'`);const d=c["backend_util"].computePool2DInfo(a.shape,s,o,l,i,u);if(1===d.filterWidth&&1===d.filterHeight&&c["util"].arraysEqual(d.inShape,d.outShape))return tu({inputs:{x:a},backend:n});const p=new Dl(d,"avg",!1);return n.runWebGLProgram(p,[a],"float32")}const Pl={kernelName:c["AvgPool"],backendName:"webgl",kernelFunc:Ll};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Bl(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{filterSize:s,strides:o,pad:i,dimRoundingMode:u,dataFormat:l}=r,d=[1,1,1],p=c["backend_util"].computePool3DInfo(a.shape,s,o,d,i,u,l),h=new Ml(p,"avg",!1);return n.runWebGLProgram(h,[a],"float32")}const Vl={kernelName:c["AvgPool3D"],backendName:"webgl",kernelFunc:Bl};
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class zl{constructor(e){this.variableNames=["dy"],this.outputShape=e.inShape;const t=e.filterHeight,n=e.filterWidth,r=e.strideHeight,a=e.strideWidth,s=e.dilationHeight,o=e.dilationWidth,i=e.effectiveFilterHeight,c=e.effectiveFilterWidth,u=i-1-e.padInfo.top,l=c-1-e.padInfo.left,d=1/(t*n);this.userCode=`\n      const ivec2 pads = ivec2(${u}, ${l});\n      const float avgMultiplier = float(${d});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${i};\n            wR += ${s}) {\n          float dyR = float(dyRCorner + wR) / ${r}.0;\n\n          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < ${c};\n            wC+= ${o}) {\n            float dyC = float(dyCCorner + wC) / ${a}.0;\n\n            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n\n            dotProd += dyValue * avgMultiplier;\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class Wl{constructor(e){this.variableNames=["dy"],this.outputShape=e.inShape;const t=e.filterDepth,n=e.filterHeight,r=e.filterWidth,a=e.strideDepth,s=e.strideHeight,o=e.strideWidth,i=e.dilationDepth,c=e.dilationHeight,u=e.dilationWidth,l=e.effectiveFilterDepth,d=e.effectiveFilterHeight,p=e.effectiveFilterWidth,h=l-1-e.padInfo.front,f=d-1-e.padInfo.top,m=p-1-e.padInfo.left,b=1/(t*n*r);this.userCode=`\n      const ivec3 pads = ivec3(${h}, ${f}, ${m});\n      const float avgMultiplier = float(${b});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < ${l};\n            wD += ${i}) {\n          float dyD = float(dyDCorner + wD) / ${a}.0;\n\n          if (dyD < 0.0 || dyD >= ${e.outDepth}.0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < ${d};\n              wR += ${c}) {\n            float dyR = float(dyRCorner + wR) / ${s}.0;\n\n            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < ${p};\n                wC += ${u}) {\n              float dyC = float(dyCCorner + wC) / ${o}.0;\n\n              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n\n              dotProd += dyValue * avgMultiplier;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ul(e){const{inputs:t,backend:n,attrs:r}=e,{dy:a,input:s}=t,o=s,{filterSize:i,strides:u,pad:l,dimRoundingMode:d}=r,p=[1,1,1],h=c["backend_util"].computePool3DInfo(o.shape,i,u,p,l,d),f=new Wl(h);return n.runWebGLProgram(f,[a],o.dtype)}const Gl={kernelName:c["AvgPool3DGrad"],backendName:"webgl",kernelFunc:Ul};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Hl(e){const{inputs:t,backend:n,attrs:r}=e,{dy:a,input:s}=t,o=s;ra([a,s],"avgPoolGrad");const{filterSize:i,strides:u,pad:l}=r,d=c["backend_util"].computePool2DInfo(o.shape,i,u,1,l),p=new zl(d);return n.runWebGLProgram(p,[a],o.dtype)}const ql={kernelName:c["AvgPoolGrad"],backendName:"webgl",kernelFunc:Hl};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Kl(e){const{inputs:t,backend:n,attrs:r}=e,{a:a,b:s}=t,{transposeA:o,transposeB:i}=r;return zu({a:a,b:s,transposeA:o,transposeB:i,backend:n})}const Xl={kernelName:c["BatchMatMul"],backendName:"webgl",kernelFunc:Kl};
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Yl{constructor(e,t,n,r,a,s){this.outputShape=[],this.variableNames=["x","mean","variance"],c["backend_util"].assertAndGetBroadcastShape(e,t),c["backend_util"].assertAndGetBroadcastShape(e,n);let o="0.0";null!=r&&(c["backend_util"].assertAndGetBroadcastShape(e,r),this.variableNames.push("offset"),o="getOffsetAtOutCoords()");let i="1.0";null!=a&&(c["backend_util"].assertAndGetBroadcastShape(e,a),this.variableNames.push("scale"),i="getScaleAtOutCoords()"),this.outputShape=e,this.userCode=`\n      void main() {\n        float x = getXAtOutCoords();\n        float mean = getMeanAtOutCoords();\n        float variance = getVarianceAtOutCoords();\n        float offset = ${o};\n        float scale = ${i};\n        float inv = scale * inversesqrt(variance + float(${s}));\n        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));\n      }\n    `}}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Ql{constructor(e,t,n,r,a,s){this.packedInputs=!0,this.packedOutput=!0,this.variableNames=["x","mean","variance"],c["backend_util"].assertAndGetBroadcastShape(e,t),c["backend_util"].assertAndGetBroadcastShape(e,n);let o="vec4(0.0)";null!=r&&(c["backend_util"].assertAndGetBroadcastShape(e,r),this.variableNames.push("offset"),o="getOffsetAtOutCoords()");let i="vec4(1.0)";null!=a&&(c["backend_util"].assertAndGetBroadcastShape(e,a),this.variableNames.push("scale"),i="getScaleAtOutCoords()"),this.outputShape=e,this.userCode=`\n      void main() {\n        vec4 offset = ${o};\n        vec4 scale = ${i};\n\n        vec4 x = getXAtOutCoords();\n        vec4 mean = getMeanAtOutCoords();\n        vec4 variance = getVarianceAtOutCoords();\n\n        vec4 inv = scale * inversesqrt(variance + vec4(${s}));\n\n        setOutput((x - mean) * inv + offset);\n      }\n    `}}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Zl=({inputs:e,backend:t,attrs:n})=>{const{x:r,mean:a,variance:s,offset:o,scale:i}=e;c["util"].assert(a.shape.length===s.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),c["util"].assert(null==o||a.shape.length===o.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),c["util"].assert(null==i||a.shape.length===i.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");let{varianceEpsilon:u}=n;null==u&&(u=.001);const l=[r,a,s];let d=null;null!=o&&(d=o.shape,l.push(o));let p=null;null!=i&&(p=i.shape,l.push(i));const h=Object(c["env"])().getBool("WEBGL_PACK_NORMALIZATION")?new Ql(r.shape,a.shape,s.shape,d,p,u):new Yl(r.shape,a.shape,s.shape,d,p,u),f=t.runWebGLProgram(h,l,l[0].dtype);return f},Jl={kernelName:c["FusedBatchNorm"],backendName:"webgl",kernelFunc:Zl};
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class ed{constructor(e){this.variableNames=["source"],this.outputShape=e,this.rank=e.length;const t=ts(this.rank);this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const n=nd(this.rank);let r;const a=e.map((e,t)=>`sourceLoc.${td[t]} = start[${t}] + coords.${td[t]};`);r=`\n        ${t} sourceLoc;\n        ${t} coords = getOutputCoords();\n        ${a.join("\n")}\n      `,this.userCode=`\n      void main() {\n        ${r}\n        setOutput(getSource(${n}));\n      }\n    `}}const td=["x","y","z","w","u","v"];function nd(e){if(1===e)return"sourceLoc";if(e<=6)return td.slice(0,e).map(e=>"sourceLoc."+e).join(",");throw Error(`Slicing for rank ${e} is not yet supported`)}
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class rd{constructor(e){this.variableNames=["source"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.rank=e.length,this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const t=ts(this.rank),n=uc("coords",this.rank),r=uc("sourceLoc",this.rank),a=1===this.rank?"sourceLoc":`vec2(${r.slice(-2).join()})`,s=`getChannel(getSource(${r.join()}), ${a})`,o=`\n      result.x = ${s};\n      if (++${n[this.rank-1]} < ${e[this.rank-1]}) {\n        ++${r[this.rank-1]};\n        result.y = ${s};\n        --${r[this.rank-1]};\n      }\n    `,i=1===this.rank?"":`\n      --${n[this.rank-1]};\n      if (++${n[this.rank-2]} < ${e[this.rank-2]}) {\n        ++${r[this.rank-2]};\n        result.z = ${s};\n        if (++${n[this.rank-1]} < ${e[this.rank-1]}) {\n          ++${r[this.rank-1]};\n          result.w = ${s};\n        }\n      }\n    `,c=this.rank<=4?`sourceLoc = coords +\n            ${t}(${e.map((e,t)=>`start[${t}]`).join()});`:e.map((e,t)=>`${r[t]} = ${n[t]} + start[${t}];`).join("\n");this.userCode=`\n      void main() {\n        ${t} coords = getOutputCoords();\n        ${t} sourceLoc;\n        ${c}\n        vec4 result = vec4(0.);\n        ${o}\n        ${i}\n        setOutput(result);\n      }\n    `}}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ad(e,t,n,r){const a=r.texData.get(e.dataId),s=r.makeTensorInfo(n,e.dtype),o=r.texData.get(s.dataId);Object.assign(o,a),o.refCount=1,o.shape=n,o.dtype=e.dtype;let i=c["slice_util"].computeFlatOffset(t,c["util"].computeStrides(e.shape));a.slice&&(i+=a.slice.flatOffset),o.slice={flatOffset:i,origDataId:a.slice&&a.slice.origDataId||e.dataId};const u=r.dataRefCount.get(o.slice.origDataId)||1;return r.dataRefCount.set(o.slice.origDataId,u+1),s}function sd(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{begin:s,size:o}=r,[i,u]=c["slice_util"].parseSliceParams(a,s,o);if(c["slice_util"].assertParamsValid(a,i,u),0===c["util"].sizeFromShape(u))return n.makeTensorInfo(u,a.dtype,[]);if(n.shouldExecuteOnCPU([a])||"string"===a.dtype){const e=n.texData.get(a.dataId),t=Ki(e.values,i,u,a.shape,a.dtype);return n.makeTensorInfo(u,a.dtype,t)}const{isPacked:l}=n.texData.get(a.dataId),d=c["slice_util"].isSliceContinous(a.shape,i,u);if(l||!d){const e=Object(c["env"])().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new rd(u):new ed(u),t=[i];return n.runWebGLProgram(e,[a],a.dtype,t)}return n.uploadToGPU(a.dataId),ad(a,i,u,n)}const od={kernelName:c["Slice"],backendName:"webgl",kernelFunc:sd},id=e=>{const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{blockShape:s,crops:o}=r;c["util"].assert(a.shape.length<=4,()=>"batchToSpaceND for rank > 4 with a WebGL backend not implemented yet");const i=s.reduce((e,t)=>e*t),u=c["backend_util"].getReshaped(a.shape,s,i),l=c["backend_util"].getPermuted(u.length,s.length),d=c["backend_util"].getReshapedPermuted(a.shape,s,i),p=c["backend_util"].getSliceBeginCoords(o,s.length),h=c["backend_util"].getSliceSize(d,o,s.length),f=[],m=Nu({inputs:{x:a},backend:n,attrs:{shape:u}}),b=Pu({inputs:{x:m},backend:n,attrs:{perm:l}}),g=Nu({inputs:{x:b},backend:n,attrs:{shape:d}}),y=sd({inputs:{x:g},backend:n,attrs:{begin:p,size:h}});return f.push(m),f.push(b),f.push(g),f.forEach(e=>n.disposeIntermediateTensorInfo(e)),y},cd={kernelName:c["BatchToSpaceND"],backendName:"webgl",kernelFunc:id};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function ud(e){const{inputs:t,backend:n,attrs:r}=e,{x:a,weights:s}=t,{size:o}=r,i=n.readSync(a.dataId),c=n.readSync(s.dataId),u=vi(i,c,s.dtype,s.shape,o);return n.makeTensorInfo([o],s.dtype,u)}const ld={kernelName:c["Bincount"],backendName:"webgl",kernelFunc:ud},dd="return float(a != b);",pd=gu({opSnippet:dd,cpuKernelImpl:zi,dtype:"bool"}),hd={kernelName:c["NotEqual"],backendName:"webgl",kernelFunc:pd};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function fd(e){const{inputs:t,backend:n}=e,{input:r}=t,a=n.texData.get(r.dataId);return tu({inputs:{x:a.complexTensorInfos.real},backend:n})}const md={kernelName:c["Real"],backendName:"webgl",kernelFunc:fd},bd="return float(int(x));";
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gd(e,t){const n=new Sc(e.shape,bd),r=t.runWebGLProgram(n,[e],"int32");return{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yd(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{dtype:s}=r;if("complex64"===s){if("complex64"===a.dtype)return tu({inputs:{x:a},backend:n});const e=c["zeros"](a.shape),t=yd({inputs:{x:a},backend:n,attrs:{dtype:"float32"}}),r=ru({inputs:{real:t,imag:e},backend:n});return e.dispose(),n.disposeIntermediateTensorInfo(t),r}if("complex64"===a.dtype){const e=fd({inputs:{input:a},backend:n}),t=yd({inputs:{x:e},backend:n,attrs:{dtype:s}});return n.disposeIntermediateTensorInfo(e),t}if(!c["util"].hasEncodingLoss(a.dtype,s)){const e=tu({inputs:{x:a},backend:n});return{dataId:e.dataId,shape:e.shape,dtype:s}}if("int32"===s)return gd(a,n);if("bool"===s){const e=n.makeTensorInfo([],"bool",c["util"].getTypedArrayFromDType("bool",1)),t={a:a,b:e},r=pd({inputs:t,backend:n});return n.disposeIntermediateTensorInfo(e),r}throw new Error(`Error in Cast: failed to cast ${a.dtype} to ${s}`)}const xd={kernelName:c["Cast"],backendName:"webgl",kernelFunc:yd},Od="return ceil(x);",vd=bu({opSnippet:Od,packedOpSnippet:Od,cpuKernelImpl:ki}),wd={kernelName:c["Ceil"],backendName:"webgl",kernelFunc:vd};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class kd{constructor(e){this.variableNames=["A"],this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=e,this.userCode="\n\n      void main() {\n        float value = getAAtOutCoords();\n        if (isnan(value)) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, minVal, maxVal));\n      }\n    "}}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class jd{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=e,this.userCode="\n      void main() {\n        vec4 value = getAAtOutCoords();\n\n        if (any(isnan(value))) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));\n      }\n    "}}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Sd(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{clipValueMin:s,clipValueMax:o}=r;let i;i=Object(c["env"])().getBool("WEBGL_PACK_CLIP")?new jd(a.shape):new kd(a.shape);const u=[[s],[o]];return n.runWebGLProgram(i,[a],a.dtype,u)}const Nd={kernelName:c["ClipByValue"],backendName:"webgl",kernelFunc:Sd};
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Cd{constructor(e){this.variableNames=["real","imag"],this.outputShape=e,this.userCode="\n      void main() {\n        float re = abs(getRealAtOutCoords());\n        float im = abs(getImagAtOutCoords());\n        float mx = max(re, im);\n\n        // sadly the length function in glsl is not underflow-safe\n        // (at least not on Intel GPUs). So the safe solution is\n        // to ensure underflow-safety in all cases.\n        setOutput(\n          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))\n        );\n      }\n    "}}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Id(e,t){return{dataId:t.dataId,dtype:t.dtype,shape:e.shape}}function Td(e){const{inputs:t,backend:n}=e,{x:r}=t,a=n.texData.get(r.dataId),s=new Cd(r.shape),o=[Id(r,a.complexTensorInfos.real),Id(r,a.complexTensorInfos.imag)];return n.runWebGLProgram(s,o,o[0].dtype)}const $d={kernelName:c["ComplexAbs"],backendName:"webgl",kernelFunc:Td};
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Ed{constructor(e){this.outputShape=[],this.outputShape=c["backend_util"].computeOutShape(e,1),this.variableNames=e.map((e,t)=>"T"+t);const t=new Array(e.length-1);t[0]=e[0][1];for(let s=1;s<t.length;s++)t[s]=t[s-1]+e[s][1];const n=[`if (yC < ${t[0]}) setOutput(getT0(yR, yC));`];for(let s=1;s<t.length;s++){const e=t[s-1];n.push(`else if (yC < ${t[s]}) setOutput(getT${s}(yR, yC-${e}));`)}const r=t.length,a=t[t.length-1];n.push(`else setOutput(getT${r}(yR, yC-${a}));`),this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int yR = coords.x;\n        int yC = coords.y;\n\n        ${n.join("\n        ")}\n      }\n    `}}
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Ad{constructor(e,t){this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[],this.outputShape=c["backend_util"].computeOutShape(e,t);const n=this.outputShape,r=n.length,a=ts(r),s=uc("coords",r),o=["x","y","z","w","u","v"].slice(0,r);this.variableNames=e.map((e,t)=>"T"+t);const i=new Array(e.length-1);i[0]=e[0][t];for(let c=1;c<i.length;c++)i[c]=i[c-1]+e[c][t];const u=o[t],l=o.slice(-2),d=o.join();let p=`if (${u} < ${i[0]}) {\n        return getChannel(\n            getT0(${d}), vec2(${l.join()}));\n        }`;for(let c=1;c<i.length;c++){const e=i[c-1];p+=`\n        if (${u} < ${i[c]}  && ${u} >= ${i[c-1]}) {\n          return getChannel(\n            getT${c}(${Rd(o,u,e)}),\n            vec2(${Rd(l,u,e)}));\n        }`}const h=i.length,f=i[i.length-1];p+=`\n        return getChannel(\n          getT${h}(${Rd(o,u,f)}),\n          vec2(${Rd(l,u,f)}));`,this.userCode=`\n      float getValue(${o.map(e=>"int "+e)}) {\n        ${p}\n      }\n\n      void main() {\n        ${a} coords = getOutputCoords();\n        vec4 result = vec4(getValue(${s}), 0., 0., 0.);\n\n        ${s[r-1]} = ${s[r-1]} + 1;\n        if (${s[r-1]} < ${n[r-1]}) {\n          result.g = getValue(${s});\n        }\n\n        ${s[r-2]} = ${s[r-2]} + 1;\n        if (${s[r-2]} < ${n[r-2]}) {\n          result.a = getValue(${s});\n        }\n\n        ${s[r-1]} = ${s[r-1]} - 1;\n        if (${s[r-2]} < ${n[r-2]} &&\n            ${s[r-1]} < ${n[r-1]}) {\n          result.b = getValue(${s});\n        }\n        setOutput(result);\n      }\n    `}}function Rd(e,t,n){const r=e.indexOf(t),a=e.map((e,t)=>t===r?`${e} - ${n}`:e);return a.join()}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _d(e){const{inputs:t,backend:n}=e,{input:r}=t,a=n.texData.get(r.dataId);return tu({inputs:{x:a.complexTensorInfos.imag},backend:n})}const Fd={kernelName:c["Imag"],backendName:"webgl",kernelFunc:_d};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Dd(e,t,n){const r=e[0].dtype;if("complex64"===r){const r=e.map(e=>fd({inputs:{input:e},backend:n})),a=e.map(e=>_d({inputs:{input:e},backend:n})),s=Dd(r,t,n),o=Dd(a,t,n),i=ru({inputs:{real:s,imag:o},backend:n});return r.forEach(e=>n.disposeIntermediateTensorInfo(e)),a.forEach(e=>n.disposeIntermediateTensorInfo(e)),n.disposeIntermediateTensorInfo(s),n.disposeIntermediateTensorInfo(o),i}let a=n.shouldExecuteOnCPU(e);if("string"===r&&(a=!0),a){const a=e.map(e=>{const r=c["util"].sizeFromShape(e.shape.slice(t)),a=[-1,r];return Nu({inputs:{x:e},backend:n,attrs:{shape:a}})}),s=a.map(e=>({vals:n.readSync(e.dataId),shape:e.shape})),o=c["backend_util"].computeOutShape(a.map(e=>e.shape),1),i=1===a[0].shape[0],u=ji(s,o,r,i),l=c["backend_util"].computeOutShape(e.map(e=>e.shape),t),d=n.makeTensorInfo(l,r,u);return a.forEach(e=>n.disposeIntermediateTensorInfo(e)),d}if(e.length>Object(c["env"])().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER")){const r=Math.floor(e.length/2),a=Dd(e.slice(0,r),t,n),s=Dd(e.slice(r),t,n),o=Dd([a,s],t,n);return n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(s),o}if(Object(c["env"])().getBool("WEBGL_PACK_ARRAY_OPERATIONS")&&e[0].shape.length>1){const a=new Ad(e.map(e=>e.shape),t);return n.runWebGLProgram(a,e,r)}const{tensors2D:s,outShape:o}=Md(e,t,n),i=new Ed(s.map(e=>e.shape)),u=n.runWebGLProgram(i,s,r);s.forEach(e=>n.disposeIntermediateTensorInfo(e));const l=Nu({inputs:{x:u},attrs:{shape:o},backend:n});return n.disposeIntermediateTensorInfo(u),l}function Md(e,t,n){const r=c["backend_util"].computeOutShape(e.map(e=>e.shape),t),a=e.map(e=>Nu({inputs:{x:e},attrs:{shape:[-1,c["util"].sizeFromShape(e.shape.slice(t))]},backend:n}));return{tensors2D:a,outShape:r}}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ld(e){const{inputs:t,backend:n,attrs:r}=e,{axis:a}=r,s=c["util"].parseAxisParam(a,t[0].shape)[0],o=c["backend_util"].computeOutShape(t.map(e=>e.shape),s);if(0===c["util"].sizeFromShape(o))return n.makeTensorInfo(o,t[0].dtype,[]);const i=t.filter(e=>c["util"].sizeFromShape(e.shape)>0);if(1===i.length)return tu({inputs:{x:i[0]},backend:n});const u=i.map(e=>e.shape);return c["backend_util"].assertParamsConsistent(u,s),Dd(i,s,n)}const Pd={kernelName:c["Concat"],backendName:"webgl",kernelFunc:Ld};
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Bd{constructor(e,t=!1,n=null,r=!1,a=!1){this.variableNames=["x","W"],this.outputShape=e.outShape;const s=e.padInfo.top,o=e.padInfo.left,i=e.strideHeight,c=e.strideWidth,u=e.dilationHeight,l=e.dilationWidth,d=e.filterHeight,p=e.filterWidth,h=4*Math.floor(e.inChannels/4),f=e.inChannels%4,m="channelsLast"===e.dataFormat,b=m?1:2,g=m?2:3,y=m?3:1;let x="",O="";n&&(x=r?`float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          ${n}\n        }`:a?`float activation(float a) {\n          float b = getLeakyreluAlphaAtOutCoords();\n          ${n}\n        }`:`\n          float activation(float x) {\n            ${n}\n          }\n        `,O="result = activation(result);");const v=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),a&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n      ${x}\n\n      const ivec2 strides = ivec2(${i}, ${c});\n      const ivec2 pads = ivec2(${s}, ${o});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d2 = coords[${y}];\n\n        ivec2 xRCCorner =\n            ivec2(coords[${b}], coords[${g}]) * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${d}; wR++) {\n          int xR = xRCorner + wR * ${u};\n\n          if (xR < 0 || xR >= ${e.inHeight}) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${p}; wC++) {\n            int xC = xCCorner + wC * ${l};\n\n            if (xC < 0 || xC >= ${e.inWidth}) {\n              continue;\n            }\n\n            for (int d1 = 0; d1 < ${h}; d1 += 4) {\n              vec4 wValues = vec4(\n                getW(wR, wC, d1, d2),\n                getW(wR, wC, d1 + 1, d2),\n                getW(wR, wC, d1 + 2, d2),\n                getW(wR, wC, d1 + 3, d2)\n              );\n\n              if (${m}) {\n                vec4 xValues = vec4(\n                  getX(batch, xR, xC, d1),\n                  getX(batch, xR, xC, d1 + 1),\n                  getX(batch, xR, xC, d1 + 2),\n                  getX(batch, xR, xC, d1 + 3)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec4 xValues = vec4(\n                  getX(batch, d1, xR, xC),\n                  getX(batch, d1 + 1, xR, xC),\n                  getX(batch, d1 + 2, xR, xC),\n                  getX(batch, d1 + 3, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n\n            if (${1===f}) {\n\n              if (${m}) {\n                dotProd +=\n                    getX(batch, xR, xC, ${h}) *\n                    getW(wR, wC, ${h}, d2);\n              } else {\n                dotProd +=\n                    getX(batch, ${h}, xR, xC) *\n                    getW(wR, wC, ${h}, d2);\n              }\n\n            } else if (${2===f}) {\n              vec2 wValues = vec2(\n                getW(wR, wC, ${h}, d2),\n                getW(wR, wC, ${h} + 1, d2)\n              );\n\n              if (${m}) {\n                vec2 xValues = vec2(\n                  getX(batch, xR, xC, ${h}),\n                  getX(batch, xR, xC, ${h} + 1)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec2 xValues = vec2(\n                  getX(batch, ${h}, xR, xC),\n                  getX(batch, ${h} + 1, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            } else if (${3===f}) {\n              vec3 wValues = vec3(\n                getW(wR, wC, ${h}, d2),\n                getW(wR, wC, ${h} + 1, d2),\n                getW(wR, wC, ${h} + 2, d2)\n              );\n\n              if (${m}) {\n                vec3 xValues = vec3(\n                  getX(batch, xR, xC, ${h}),\n                  getX(batch, xR, xC, ${h} + 1),\n                  getX(batch, xR, xC, ${h} + 2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec3 xValues = vec3(\n                  getX(batch, ${h}, xR, xC),\n                  getX(batch, ${h} + 1, xR, xC),\n                  getX(batch, ${h} + 2, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            }\n          }\n        }\n\n        float result = dotProd;\n        ${v}\n        ${O}\n        setOutput(result);\n      }\n    `}}class Vd{constructor(e){this.variableNames=["x","W"],this.outputShape=e.outShape;const t=e.padInfo.front,n=e.padInfo.top,r=e.padInfo.left,a=e.strideDepth,s=e.strideHeight,o=e.strideWidth,i=e.dilationDepth,c=e.dilationHeight,u=e.dilationWidth,l=e.filterDepth,d=e.filterHeight,p=e.filterWidth,h=4*Math.floor(e.inChannels/4),f=e.inChannels%4;this.userCode=`\n      const ivec3 strides = ivec3(${a}, ${s}, ${o});\n      const ivec3 pads = ivec3(${t}, ${n}, ${r});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d2 = coords.u;\n\n        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xFCorner = xFRCCorner.x;\n        int xRCorner = xFRCCorner.y;\n        int xCCorner = xFRCCorner.z;\n\n        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get\n        // y(yF, yR, yC, d2). ? = to be determined. : = across all\n        // values in that axis.\n        float dotProd = 0.0;\n        for (int wF = 0; wF < ${l}; wF++) {\n          int xF = xFCorner + wF * ${i};\n\n          if (xF < 0 || xF >= ${e.inDepth}) {\n            continue;\n          }\n\n          for (int wR = 0; wR < ${d}; wR++) {\n            int xR = xRCorner + wR * ${c};\n\n            if (xR < 0 || xR >= ${e.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${p}; wC++) {\n              int xC = xCCorner + wC * ${u};\n\n              if (xC < 0 || xC >= ${e.inWidth}) {\n                continue;\n              }\n\n              for (int d1 = 0; d1 < ${h}; d1 += 4) {\n                vec4 xValues = vec4(\n                  getX(batch, xF, xR, xC, d1),\n                  getX(batch, xF, xR, xC, d1 + 1),\n                  getX(batch, xF, xR, xC, d1 + 2),\n                  getX(batch, xF, xR, xC, d1 + 3)\n                );\n                vec4 wValues = vec4(\n                  getW(wF, wR, wC, d1, d2),\n                  getW(wF, wR, wC, d1 + 1, d2),\n                  getW(wF, wR, wC, d1 + 2, d2),\n                  getW(wF, wR, wC, d1 + 3, d2)\n                );\n\n                dotProd += dot(xValues, wValues);\n              }\n\n              if (${1===f}) {\n                dotProd +=\n                  getX(batch, xF, xR, xC, ${h}) *\n                  getW(wF, wR, wC, ${h}, d2);\n              } else if (${2===f}) {\n                vec2 xValues = vec2(\n                  getX(batch, xF, xR, xC, ${h}),\n                  getX(batch, xF, xR, xC, ${h} + 1)\n                );\n                vec2 wValues = vec2(\n                  getW(wF, wR, wC, ${h}, d2),\n                  getW(wF, wR, wC, ${h} + 1, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else if (${3===f}) {\n                vec3 xValues = vec3(\n                  getX(batch, xF, xR, xC, ${h}),\n                  getX(batch, xF, xR, xC, ${h} + 1),\n                  getX(batch, xF, xR, xC, ${h} + 2)\n                );\n                vec3 wValues = vec3(\n                  getW(wF, wR, wC, ${h}, d2),\n                  getW(wF, wR, wC, ${h} + 1, d2),\n                  getW(wF, wR, wC, ${h} + 2, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class zd{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec3"},{name:"pad",type:"ivec2"},{name:"stride",type:"ivec2"},{name:"dilation",type:"ivec2"},{name:"inChannels",type:"int"},{name:"itemsPerBlockRow",type:"int"},{name:"outWidth",type:"int"}],this.outputShape=e,this.enableShapeUniforms=us(this.outputShape.length);const{dataFormat:n}=t,r=sa(),a="channelsLast"===n,s=a?0:1,o=a?1:2,i=this.enableShapeUniforms?"if(blockIndex < outShape[1] && pos < outShape[0]) {":`if(blockIndex < ${e[1]} && pos < ${e[0]}) {`;let c="";for(let u=0;u<=1;u++)for(let e=0;e<=1;e++)c+=`\n          blockIndex = rc.y + ${e};\n          pos = rc.x + ${u};\n\n          ${i}\n            offsetY = int(blockIndex / outWidth) * stride[0] - pad[0];\n            d0 = offsetY + dilation[0] * (pos / itemsPerBlockRow);\n\n            if(d0 < inputShape[${s}] && d0 >= 0) {\n              // Use custom imod instead mod. On Intel GPU, mod may generate\n              // unexpected value.\n              // https://github.com/tensorflow/tfjs/issues/5447\n              offsetX = imod(blockIndex, outWidth) * stride[1] - pad[1];\n              d1 = offsetX + dilation[1] * (imod(pos, itemsPerBlockRow) /\n                  inChannels);\n\n              if(d1 < inputShape[${o}] && d1 >= 0) {\n\n                ch = imod(pos, inChannels);\n\n                if (${a}) {\n                  innerDims = vec2(d1, ch);\n                  result[${2*u+e}] = getChannel(\n                    getA(d0, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                } else {\n                  innerDims = vec2(d0, d1);\n                  result[${2*u+e}] = getChannel(\n                    getA(ch, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                }\n              }\n            }\n          }\n        `;this.userCode=`\n      void main() {\n        ivec2 rc = getOutputCoords();\n\n        vec4 result = vec4(0);\n\n        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;\n        vec2 innerDims;\n\n        ${c}\n\n        ${r.output} = result;\n      }\n    `}}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Wd({x:e,filter:t,convInfo:n,backend:r,bias:a=null,preluActivationWeights:s=null,leakyreluAlpha:o=0,activation:i=null}){const u=e.shape,l=r.texData.get(e.dataId),d=n.inChannels,p=u[0]*u[1]*u[2],h=n.outChannels,f="channelsLast"===n.dataFormat,m=!1,b=!1;let g;const y=[],x=(1===p||1===h)&&d>Vu,O=!x&&l.isPacked&&f&&null!=l.texture&&u[2]%2!==0&&c["util"].arraysEqual(l.shape.slice(-3),u.slice(-3));if(O){const d=u[0]*u[1]*(u[2]+1),p={dataId:e.dataId,shape:[1,d,n.inChannels],dtype:e.dtype},h=l.shape;l.shape=l.shape.slice(),l.shape[l.shape.length-2]++,c["util"].assert(Ur(l.shape,p.shape),()=>`packed reshape ${l.shape} to ${p.shape} isn't free`);const f=Nu({inputs:{x:t},backend:r,attrs:{shape:[1,n.inChannels,n.outChannels]}});y.push(f);const x=zu({a:p,b:f,backend:r,transposeA:m,transposeB:b,bias:a,activation:i,preluActivationWeights:s,leakyreluAlpha:o}),O=r.texData.get(x.dataId);c["util"].assert(O.isPacked,()=>"batchMatMul result is expected to be packed"),l.shape=h,O.shape=n.outShape,g=tu({inputs:{x:x},backend:r}),g.shape=n.outShape,y.push(x)}else{const c=f?u[0]*u[1]*u[2]:u[0]*u[2]*u[3],l=Nu({inputs:{x:e},backend:r,attrs:{shape:[1,c,n.inChannels]}}),d=Nu({inputs:{x:t},backend:r,attrs:{shape:[1,n.inChannels,n.outChannels]}}),p=zu({a:l,b:d,transposeA:m,transposeB:b,backend:r,bias:a,activation:i,preluActivationWeights:s,leakyreluAlpha:o});g=Nu({inputs:{x:p},backend:r,attrs:{shape:n.outShape}}),y.push(l),y.push(d),y.push(p)}for(const c of y)r.disposeIntermediateTensorInfo(c);return g}function Ud({x:e,filter:t,convInfo:n,backend:r,bias:a=null,preluActivationWeights:s=null,leakyreluAlpha:o=0,activation:i=null}){const{filterWidth:u,filterHeight:l,inChannels:d,outWidth:p,outHeight:h,dataFormat:f}=n,m="channelsLast"===f,b=u*l*d,g=h*p,y=[b,g],x=!0,O=!1,v=[],w=Nu({inputs:{x:e},backend:r,attrs:{shape:e.shape.slice(1)}}),k=Nu({inputs:{x:t},backend:r,attrs:{shape:[1,b,c["util"].sizeFromShape(t.shape)/b]}});v.push(w),v.push(k);const j=new zd(y,n),S=[w.shape,[n.padInfo.top,n.padInfo.left],[n.strideHeight,n.strideWidth],[n.dilationHeight,n.dilationWidth],[n.inChannels],[n.filterWidth*n.inChannels],[n.outWidth]],N=r.runWebGLProgram(j,[w],"float32",S),C=Nu({inputs:{x:N},backend:r,attrs:{shape:[1,y[0],y[1]]}});v.push(N),v.push(C);const I=null!=a,T=null!=s,$="leakyrelu"===i,E=i?yu(i,!0):null,A=new xu(C.shape,k.shape,[1,g,n.outChannels],x,O,I,E,T,$),R=[C,k];if(a&&R.push(a),T&&R.push(s),$){const e=r.makeTensorInfo([],"float32",c["util"].createScalarValue(o,"float32"));R.push(e),v.push(e)}const _=r.runWebGLProgram(A,R,"float32"),F=m?[1,h,p,n.outChannels]:[1,n.outChannels,h,p],D=Nu({inputs:{x:_},backend:r,attrs:{shape:F}});v.push(_);for(const c of v)r.disposeIntermediateTensorInfo(c);return D}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Gd(e){const{inputs:t,backend:n,attrs:r}=e,{x:a,filter:s}=t,{strides:o,pad:i,dataFormat:u,dilations:l,dimRoundingMode:d}=r,p=c["backend_util"].convertConv2DDataFormat(u),h=c["backend_util"].computeConv2DInfo(a.shape,s.shape,o,l,i,d,!1,p);let f;if(1!==h.filterHeight||1!==h.filterWidth||1!==h.dilationHeight||1!==h.dilationWidth||1!==h.strideHeight||1!==h.strideWidth||"SAME"!==h.padInfo.type&&"VALID"!==h.padInfo.type)if(Object(c["env"])().getBool("WEBGL_CONV_IM2COL")&&1===a.shape[0])f=Ud({x:a,filter:s,convInfo:h,backend:n});else{const e=new Bd(h);f=n.runWebGLProgram(e,[a,s],"float32")}else f=Wd({x:a,filter:s,convInfo:h,backend:n});const m=Nu({inputs:{x:f},backend:n,attrs:{shape:h.outShape}});return n.disposeIntermediateTensorInfo(f),m}const Hd={kernelName:c["Conv2D"],backendName:"webgl",kernelFunc:Gd};
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class qd{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const t=e.strideHeight,n=e.strideWidth,r=e.padInfo.top,a=e.padInfo.left,s="channelsLast"===e.dataFormat;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int d2 = coords.w;\n\n        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int b = 0; b < ${e.batchSize}; b++) {\n          for (int yR = 0; yR < ${e.outHeight}; yR++) {\n            int xR = wR + yR * ${t} - ${r};\n\n            if (xR < 0 || xR >= ${e.inHeight}) {\n              continue;\n            }\n\n            for (int yC = 0; yC < ${e.outWidth}; yC++) {\n              int xC = wC + yC * ${n} - ${a};\n\n              if (xC < 0 || xC >= ${e.inWidth}) {\n                continue;\n              }\n\n              if (${s}) {\n                float dyValue = getDy(b, yR, yC, d2);\n                float xValue = getX(b, xR, xC, d1);\n                dotProd += (xValue * dyValue);\n              } else {\n                float dyValue = getDy(b, d2, yR, yC);\n                float xValue = getX(b, d1, xR, xC);\n                dotProd += (xValue * dyValue);\n              }\n\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class Kd{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const t=e.filterHeight,n=e.filterWidth,r=e.strideHeight,a=e.strideWidth,s="channelsLast"===e.dataFormat,o=t-1-e.padInfo.top,i=n-1-e.padInfo.left,c=s?1:2,u=s?2:3,l=s?3:1;this.userCode=`\n      const ivec2 pads = ivec2(${o}, ${i});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[${l}];\n\n        ivec2 dyCorner = ivec2(coords[${c}], coords[${u}]) - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${t}; wR++) {\n          float dyR = float(dyRCorner + wR) / ${r}.0;\n\n          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = ${t} - 1 - wR;\n\n          for (int wC = 0; wC < ${n}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${a}.0;\n\n            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = ${n} - 1 - wC;\n\n            for (int d2 = 0; d2 < ${e.outChannels}; d2++) {\n\n              if (${s}) {\n                float xValue = getDy(batch, idyR, idyC, d2);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              } else {\n                float xValue = getDy(batch, d2, idyR, idyC);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class Xd{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const t=e.strideDepth,n=e.strideHeight,r=e.strideWidth,a=e.padInfo.front,s=e.padInfo.top,o=e.padInfo.left;this.userCode=`\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int wF = coords.x;\n        int wR = coords.y;\n        int wC = coords.z;\n        int d1 = coords.w;\n        int d2 = coords.u;\n\n        float dotProd = 0.0;\n\n        for (int b = 0; b < ${e.batchSize}; b++) {\n          for (int yF = 0; yF < ${e.outDepth}; yF++) {\n            int xF = wF + yF * ${t} - ${a};\n\n            if (xF < 0 || xF >= ${e.inDepth}) {\n              continue;\n            }\n\n            for (int yR = 0; yR < ${e.outHeight}; yR++) {\n              int xR = wR + yR * ${n} - ${s};\n\n              if (xR < 0 || xR >= ${e.inHeight}) {\n                continue;\n              }\n\n              for (int yC = 0; yC < ${e.outWidth}; yC++) {\n                int xC = wC + yC * ${r} - ${o};\n\n                if (xC < 0 || xC >= ${e.inWidth}) {\n                  continue;\n                }\n\n                float dyValue = getDy(b, yF, yR, yC, d2);\n                float xValue = getX(b, xF, xR, xC, d1);\n                dotProd += (xValue * dyValue);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class Yd{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const t=e.filterDepth,n=e.filterHeight,r=e.filterWidth,a=e.strideDepth,s=e.strideHeight,o=e.strideWidth,i=t-1-e.padInfo.front,c=n-1-e.padInfo.top,u=r-1-e.padInfo.left;this.userCode=`\n      const ivec3 pads = ivec3(${i}, ${c}, ${u});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d1 = coords.u;\n\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyFCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        float dotProd = 0.0;\n        for (int wF = 0; wF < ${t}; wF++) {\n          float dyF = float(dyFCorner + wF) / ${a}.0;\n\n          if (dyF < 0.0 || dyF >= ${e.outDepth}.0 || fract(dyF) > 0.0) {\n            continue;\n          }\n          int idyF = int(dyF);\n\n          int wFPerm = ${t} - 1 - wF;\n\n          for (int wR = 0; wR < ${n}; wR++) {\n            float dyR = float(dyRCorner + wR) / ${s}.0;\n\n            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||\n              fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            int wRPerm = ${n} - 1 - wR;\n\n            for (int wC = 0; wC < ${r}; wC++) {\n              float dyC = float(dyCCorner + wC) / ${o}.0;\n\n              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              int wCPerm = ${r} - 1 - wC;\n\n              for (int d2 = 0; d2 < ${e.outChannels}; d2++) {\n                float xValue = getDy(batch, idyF, idyR, idyC, d2);\n                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Qd(e){const{inputs:t,backend:n,attrs:r}=e,{x:a,dy:s}=t,{strides:o,pad:i,dataFormat:u,dimRoundingMode:l,filterShape:d}=r,p=c["backend_util"].convertConv2DDataFormat(u),h=c["backend_util"].computeConv2DInfo(a.shape,d,o,1,i,l,!1,p),f=new qd(h);return n.runWebGLProgram(f,[a,s],"float32")}const Zd={kernelName:c["Conv2DBackpropFilter"],backendName:"webgl",kernelFunc:Qd};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Jd(e){const{inputs:t,backend:n,attrs:r}=e,{dy:a,filter:s}=t,{inputShape:o,strides:i,pad:u,dataFormat:l,dimRoundingMode:d}=r,p=c["backend_util"].convertConv2DDataFormat(l),h=c["backend_util"].computeConv2DInfo(o,s.shape,i,1,u,d,!1,p),f=new Kd(h);return n.runWebGLProgram(f,[a,s],"float32")}const ep={kernelName:c["Conv2DBackpropInput"],backendName:"webgl",kernelFunc:Jd};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tp(e){const{inputs:t,backend:n,attrs:r}=e,{x:a,filter:s}=t,{strides:o,pad:i,dilations:u}=r,l=c["backend_util"].computeConv3DInfo(a.shape,s.shape,o,u,i),d=new Vd(l);return n.runWebGLProgram(d,[a,s],"float32")}const np={kernelName:c["Conv3D"],backendName:"webgl",kernelFunc:tp};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rp(e){const{inputs:t,backend:n,attrs:r}=e,{x:a,dy:s}=t,{strides:o,pad:i,filterShape:u}=r,l=c["backend_util"].computeConv3DInfo(a.shape,u,o,1,i),d=new Xd(l);return n.runWebGLProgram(d,[a,s],"float32")}const ap={kernelName:c["Conv3DBackpropFilterV2"],backendName:"webgl",kernelFunc:rp};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sp(e){const{inputs:t,backend:n,attrs:r}=e,{dy:a,filter:s}=t,{pad:o,strides:i,inputShape:u}=r,l=c["backend_util"].computeConv3DInfo(u,s.shape,i,1,o),d=new Yd(l);return n.runWebGLProgram(d,[a,s],"float32")}const op={kernelName:c["Conv3DBackpropInputV2"],backendName:"webgl",kernelFunc:sp},ip=hu+"\n  return cos(x);\n",cp=bu({opSnippet:ip}),up={kernelName:c["Cos"],backendName:"webgl",kernelFunc:cp},lp="\n  float e2x = exp(-x);\n  return (e2x + 1.0 / e2x) / 2.0;\n",dp=bu({opSnippet:lp}),pp={kernelName:c["Cosh"],backendName:"webgl",kernelFunc:dp};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class hp{constructor(e,t,n,r,a){this.variableNames=["Image","Boxes","BoxInd"],this.outputShape=[];const[s,o,i,c]=e,[u]=t,[l,d]=n;this.outputShape=[u,l,d,c];const p="bilinear"===r?1:0,[h,f]=[o-1+".0",i-1+".0"],[m,b,g]=l>1?[""+(o-1)/(l-1),"(y2-y1) * height_ratio",`y1*${h} + float(y)*(height_scale)`]:["0.0","0.0","0.5 * (y1+y2) * "+h],[y,x,O]=d>1?[""+(i-1)/(d-1),"(x2-x1) * width_ratio",`x1*${f} + float(x)*(width_scale)`]:["0.0","0.0","0.5 * (x1+x2) * "+f];this.userCode=`\n      const float height_ratio = float(${m});\n      const float width_ratio = float(${y});\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int y = coords[1];\n        int x = coords[2];\n        int d = coords[3];\n\n        // get box vals\n        float y1 = getBoxes(b,0);\n        float x1 = getBoxes(b,1);\n        float y2 = getBoxes(b,2);\n        float x2 = getBoxes(b,3);\n\n        // get image in batch index\n        int bInd = round(getBoxInd(b));\n        if(bInd < 0 || bInd >= ${s}) {\n          return;\n        }\n\n        float height_scale = ${b};\n        float width_scale = ${x};\n\n        float in_y = ${g};\n        if( in_y < 0.0 || in_y > ${h} ) {\n          setOutput(float(${a}));\n          return;\n        }\n        float in_x = ${O};\n        if( in_x < 0.0 || in_x > ${f} ) {\n          setOutput(float(${a}));\n          return;\n        }\n\n        vec2 sourceFracIndexCR = vec2(in_x,in_y);\n        if(${p} == 1) {\n          // Compute the four integer indices.\n          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);\n          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));\n\n          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);\n          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);\n          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);\n          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);\n\n          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);\n\n          float top = topLeft + (topRight - topLeft) * fracCR.x;\n          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;\n          float newValue = top + (bottom - top) * fracCR.y;\n          setOutput(newValue);\n        } else {\n          // Compute the coordinators of nearest neighbor point.\n          ivec2 sourceNearestCR = ivec2(floor(\n            sourceFracIndexCR + vec2(0.5,0.5)));\n          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);\n          setOutput(newValue);\n        }\n      }\n    `}}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const fp=e=>{const{inputs:t,backend:n,attrs:r}=e,{image:a,boxes:s,boxInd:o}=t,{cropSize:i,method:c,extrapolationValue:u}=r,l=new hp(a.shape,s.shape,i,c,u);return n.runWebGLProgram(l,[a,s,o],"float32")},mp={kernelName:c["CropAndResize"],backendName:"webgl",kernelFunc:fp};class bp{constructor(e,t,n){this.variableNames=["x"],this.customUniforms=[{name:"index",type:"float"}],this.outputShape=e;const r=e.length,a=t?"0.0":`getX(${gp(r,"coords")})`,s=e[e.length-1];let o="",i="";t?(o=n?"end != "+(s-1):"end != 0",i=n?"end + 1":"end - 1"):(o=n?"end + pow2 < "+s:"end >= pow2",i=n?"end + pow2":"end - pow2"),this.userCode=`\n      void main() {\n        ${ts(r)} coords = getOutputCoords();\n        int end = ${yp(r,"coords")};\n        float val = ${a};\n        int pow2 = int(pow(2.0, index));\n        if (${o}) {\n          int idx = ${i};\n          ${yp(r,"coords")} = idx;\n          val += getX(${gp(r,"coords")});\n        }\n        setOutput(val);\n      }\n    `}}function gp(e,t){if(1===e)return""+t;if(2===e)return`${t}.x, ${t}.y`;if(3===e)return`${t}.x, ${t}.y, ${t}.z`;if(4===e)return`${t}.x, ${t}.y, ${t}.z, ${t}.w`;throw Error(`Cumulative sum for rank ${e} is not yet supported`)}function yp(e,t){if(1===e)return""+t;if(2===e)return t+".y";if(3===e)return t+".z";if(4===e)return t+".w";throw Error(`Cumulative sum for rank ${e} is not yet supported`)}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xp(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,exclusive:o,reverse:i}=r,u=a.shape.length,l=c["backend_util"].getAxesPermutation([s],u);let d=a;null!=l&&(d=Pu({inputs:{x:a},backend:n,attrs:{perm:l}}));const p=c["backend_util"].getInnerMostAxes(1,u)[0];if(p!==u-1)throw new Error(`WebGL cumsum shader expects an inner-most axis=${a.shape.length-1} but got axis=`+s);const h=d.shape[p];let f=tu({inputs:{x:d},backend:n});for(let c=0;c<=Math.ceil(Math.log2(h))-1;c++){const e=new bp(d.shape,!1,i),t=[[c]],r=f;f=n.runWebGLProgram(e,[f],f.dtype,t),n.disposeIntermediateTensorInfo(r)}if(o){const e=new bp(d.shape,o,i),t=f;f=n.runWebGLProgram(e,[f],f.dtype),n.disposeIntermediateTensorInfo(t)}if(null!=l){const e=c["backend_util"].getUndoAxesPermutation(l),t=Pu({inputs:{x:f},backend:n,attrs:{perm:e}});return n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(d),t}return f}const Op={kernelName:c["Cumsum"],backendName:"webgl",kernelFunc:xp};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vp(e){const{inputs:t,backend:n,attrs:r}=e,{x:a,weights:s}=t,{size:o,binaryOutput:i}=r;if(1===a.shape.length){const e=n.readSync(a.dataId),t=n.readSync(s.dataId),r=vi(e,t,s.dtype,s.shape,o);return n.makeTensorInfo([o],s.dtype,r)}if(2===a.shape.length){const e=n.bufferSync(a),t=n.bufferSync(s),r=wi(e,t,o,i);return n.makeTensorInfo(r.shape,s.dtype,r.values)}throw new Error("Error in denseBincount: input must be at most rank 2, but got rank"+a.shape.length+".")}const wp={kernelName:c["DenseBincount"],backendName:"webgl",kernelFunc:vp};
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class kp{constructor(e,t,n){this.variableNames=["x"],this.outputShape=[],this.outputShape=e,this.blockSize=t,this.dataFormat=n,this.userCode=`\n    void main() {\n      ivec4 coords = getOutputCoords();\n      int b = coords[0];\n      int h = ${this.getHeightCoordString()};\n      int w = ${this.getWidthCoordString()};\n      int d = ${this.getDepthCoordString()};\n\n      int in_h = h / ${t};\n      int offset_h = imod(h, ${t});\n      int in_w = w / ${t};\n      int offset_w = imod(w, ${t});\n      int offset_d = (offset_h * ${t} + offset_w) *\n        ${this.getOutputDepthSize()};\n      int in_d = d + offset_d;\n\n      float result = ${this.getInputSamplingString()};\n      setOutput(result);\n    }\n  `}getHeightCoordString(){return"NHWC"===this.dataFormat?"coords[1]":"coords[2]"}getWidthCoordString(){return"NHWC"===this.dataFormat?"coords[2]":"coords[3]"}getDepthCoordString(){return"NHWC"===this.dataFormat?"coords[3]":"coords[1]"}getOutputDepthSize(){return"NHWC"===this.dataFormat?this.outputShape[3]:this.outputShape[1]}getInputSamplingString(){return"NHWC"===this.dataFormat?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"}}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jp(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{blockSize:s,dataFormat:o}=r;c["util"].assert(s>1,()=>"blockSize should be > 1 for depthToSpace, but was: "+s);const i=a.shape[0],u="NHWC"===o?a.shape[1]:a.shape[2],l="NHWC"===o?a.shape[2]:a.shape[3],d="NHWC"===o?a.shape[3]:a.shape[1],p=u*s,h=l*s,f=d/(s*s),m="NHWC"===o?[i,p,h,f]:[i,f,p,h],b=new kp(m,s,o);return n.runWebGLProgram(b,[a],a.dtype)}const Sp={kernelName:c["DepthToSpace"],backendName:"webgl",kernelFunc:jp};
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Np{constructor(e,t=!1,n=null,r=!1,a=!1){this.variableNames=["x","W"],this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=us(this.outputShape.length);const s=e.filterHeight,o=e.filterWidth,i=e.outChannels/e.inChannels;let c="",u="";n&&(c=r?`float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          ${n}\n        }`:a?`float activation(float a) {\n          float b = getLeakyreluAlphaAtOutCoords();\n          ${n}\n        }`:`\n          float activation(float x) {\n            ${n}\n          }\n        `,u="result = activation(result);");const l=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),a&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n      ${c}\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2 / ${i};\n        int q = d2 - d1 * ${i};\n\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.\n        for (int wR = 0; wR < ${s}; wR++) {\n          int xR = xRCorner + wR * dilations[0];\n\n          if (xR < 0 || xR >= inDims[0]) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${o}; wC++) {\n            int xC = xCCorner + wC * dilations[1];\n\n            if (xC < 0 || xC >= inDims[1]) {\n              continue;\n            }\n\n            float xVal = getX(batch, xR, xC, d1);\n            float wVal = getW(wR, wC, d1, q);\n            dotProd += xVal * wVal;\n          }\n        }\n\n        float result = dotProd;\n        ${l}\n        ${u}\n        setOutput(result);\n      }\n    `}}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Cp{constructor(e,t=!1,n=null,r=!1,a=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=us(this.outputShape.length);const s=e.outChannels/e.inChannels,o=e.padInfo.left,i=e.strideWidth,u=e.dilationWidth,l=e.filterHeight,d=e.filterWidth,p=d;let h="\n      int xR; int xC; int xCOffset;\n      vec4 wTexel; vec4 previous; vec4 final;";for(let c=0;c<d;c++)h+=`\n          vec4 xTexelC${2*c};\n          int xTexelC${2*c}Ready;\n          vec4 xTexelC${2*c+1};\n          int xTexelC${2*c+1}Ready;\n          vec4 xC${c};`;for(let g=0;g<l;g++){for(let e=0;e<d;e++)h+=`\n          xTexelC${2*e} = vec4(0.0);\n          xTexelC${2*e}Ready = 0;\n          xTexelC${2*e+1} = vec4(0.0);\n          xTexelC${2*e+1}Ready = 0;\n          xC${e} = vec4(0.0);`;h+=`\n        xR = xRCorner + ${g} * dilations[0];\n        if (xR >=0 && xR < inDims[0]) {\n      `;for(let e=0;e<(p+1)/2;e++){const t=2*e;if(h+=`\n          xC = xCCorner + ${t*u};\n          `,1===i){if(t<d&&(o%2===1?(h+=`\n                xCOffset = xC + 1;\n                if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${t}Ready == 0) {\n                  xTexelC${t} = getX(batch, xR, xCOffset, d1);\n\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xCOffset + 1 >= inDims[1]) {\n                    xTexelC${t}.zw = vec2(0.0);\n                  }\n                  xTexelC${t}Ready = 1;\n                }\n              `,h+=1===u&&t>0?`\n                xC${t} = vec4(xTexelC${t-2}.zw, xTexelC${t}.xy);\n                `:`\n                  xCOffset = xC + 1 - 2;\n\n                  if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                    previous = getX(batch, xR, xCOffset, d1);\n\n                    // Need to manually clear unused channels in case\n                    // we're reading from recycled texture.\n                    if (xCOffset + 1 >= inDims[1]) {\n                      previous.zw = vec2(0.0);\n                    }\n\n                    xC${t} = vec4(previous.zw, xTexelC${t}.xy);\n                  } else {\n                    xC${t} = vec4(0.0, 0.0, xTexelC${t}.xy);\n                  }\n                  `):h+=`\n                if (xC >= 0 && xC < inDims[1] && xTexelC${t}Ready == 0) {\n                  xTexelC${t} = getX(batch, xR, xC, d1);\n                  if (xC + 1 >= inDims[1]) {\n                    xTexelC${t}.zw = vec2(0.0);\n                  }\n                  xTexelC${t}Ready = 1;\n                }\n\n                xC${t} = xTexelC${t};\n                `,t+1<d)){const e=o%2===0?c["util"].nearestLargerEven(u):u;u%2===0&&o%2===1||u%2!==0&&o%2!==1?(h+=`\n                  xCOffset = xC + imod(pads[1], 2) + ${e};\n\n                  if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${t+1}Ready == 0) {\n                    xTexelC${t+1} = getX(batch, xR, xCOffset, d1);\n\n                    // Need to manually clear unused channels in case\n                    // we're reading from recycled texture.\n                    if (xCOffset + 1 >= inDims[1]) {\n                      xTexelC${t+1}.zw = vec2(0.0);\n                    }\n                    xTexelC${t+1}Ready = 1;\n                  }\n                  `,u>1&&(h+=`\n                    xCOffset -= 2;\n                    if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${t}Ready == 0) {\n                      xTexelC${t} = getX(batch, xR, xCOffset, d1);\n                      xTexelC${t}Ready = 1;\n                    }\n                    `),h+=`\n                  xC${t+1} = vec4(xTexelC${t}.zw, xTexelC${t+1}.xy);\n                  `):h+=1===e?`\n                    xC${t+1} = xTexelC${t};\n                    `:`\n                    xCOffset = xC + ${e};\n\n                    if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${t+1}Ready == 0) {\n                      xTexelC${t+1} = getX(batch, xR, xCOffset, d1);\n                      if (xCOffset + 1 >= inDims[1]) {\n                        xTexelC${t+1}.zw = vec2(0.0);\n                      }\n                      xTexelC${t+1}Ready = 1;\n                    }\n\n                    xC${t+1} = xTexelC${t+1};\n                    `}}else t<d&&(o%2===1?(h+=`\n                xCOffset = xC + 1 - strides[1];\n                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${t}Ready == 0) {\n                  xTexelC${t} = getX(batch, xR, xCOffset, d1);\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xCOffset + 1 >= inDims[1]) {\n                    xTexelC${t}.zw = vec2(0.0);\n                  }\n                  xTexelC${t}Ready = 1;\n                }\n\n                if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${t+1}Ready == 0) {\n                  xTexelC${t+1} = getX(batch, xR, xC + 1, d1);\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xC + 2 >= inDims[1]) {\n                    xTexelC${t+1}.zw = vec2(0.0);\n                  }\n                  xTexelC${t+1}Ready = 1;\n                }\n\n                xC${t} = vec4(xTexelC${t}.zw, xTexelC${t+1}.zw);\n              `,t+1<d&&(h+=`\n                  final = vec4(0.0);\n                  xCOffset = xC + 1 + strides[1];\n                  if(xCOffset >= 0 && xCOffset < inDims[1]) {\n                    final = getX(batch, xR, xCOffset, d1);\n                  }\n                  xC${t+1} = vec4(xTexelC${t+1}.xy, final.xy);\n                `)):(h+=`\n                if(xC >= 0 && xC < inDims[1] && xTexelC${t}Ready == 0) {\n                  xTexelC${t} = getX(batch, xR, xC, d1);\n                  if (xC + 1 >= inDims[1]) {\n                    xTexelC${t}.zw = vec2(0.0);\n                  }\n                  xTexelC${t}Ready = 1;\n                }\n\n                xCOffset = xC + strides[1];\n                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${t+1}Ready == 0) {\n                  xTexelC${t+1} = getX(batch, xR, xCOffset, d1);\n                  if (xCOffset + 1 >= inDims[1]) {\n                    xTexelC${t+1}.zw = vec2(0.);\n                  }\n                  xTexelC${t+1}Ready = 1;\n                }\n\n                xC${t} = vec4(\n                  xTexelC${t}.xy, xTexelC${t+1}.xy);\n              `,t+1<d&&(h+=`\n                  xC${t+1} = vec4(xTexelC${t}.zw, xTexelC${t+1}.zw);\n                `)));t<d&&(h+=`\n            wTexel = getW(${g}, ${t}, d1, q);\n            dotProd += xC${t} * vec4(wTexel.xz, wTexel.xz);\n          `,t+1<d&&(h+=`\n              wTexel = getW(${g}, ${t+1}, d1, q);\n              dotProd += xC${t+1} * vec4(wTexel.xz, wTexel.xz);\n            `))}h+="\n        }\n      "}let f="",m="";n&&(f=r?`vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          ${n}\n        }`:a?`vec4 activation(vec4 a) {\n          vec4 b = getLeakyreluAlphaAtOutCoords();\n          ${n}\n        }`:`vec4 activation(vec4 x) {\n          ${n}\n        }`,m="result = activation(result);");const b=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),a&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n      ${f}\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2 / ${s};\n        int q = d2 - d1 * ${s};\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.\n        vec4 dotProd = vec4(0.000000000000001);\n\n        ${h}\n\n        vec4 result = dotProd - vec4(0.000000000000001);\n        ${b}\n        ${m}\n        setOutput(result);\n      }\n    `}}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ip(e){const{inputs:t,backend:n,attrs:r}=e,{x:a,filter:s}=t,{strides:o,pad:i,dilations:u,dimRoundingMode:l}=r;let d=u;null==d&&(d=[1,1]),c["util"].assert(c["backend_util"].eitherStridesOrDilationsAreOne(o,d),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${o} and dilations '${d}'`);const p=c["backend_util"].computeConv2DInfo(a.shape,s.shape,o,d,i,l,!0);let h;h=Object(c["env"])().getBool("WEBGL_PACK_DEPTHWISECONV")&&p.strideWidth<=2&&p.outChannels/p.inChannels===1?new Cp(p):new Np(p);const f=[[p.padInfo.top,p.padInfo.left],[p.strideHeight,p.strideWidth],[p.dilationHeight,p.dilationWidth],[p.inHeight,p.inWidth]];return n.runWebGLProgram(h,[a,s],"float32",f)}const Tp={kernelName:c["DepthwiseConv2dNative"],backendName:"webgl",kernelFunc:Ip};
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class $p{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const t=e.strideHeight,n=e.strideWidth,r=e.padInfo.top,a=e.padInfo.left,s=e.outChannels/e.inChannels;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int dm = coords.w;\n        int d2 = d1 * ${s} + dm;\n\n        float dotProd = 0.0;\n\n        // TO DO: Vec4 over the batch size\n        for (int b = 0; b < ${e.batchSize}; b++) {\n          for (int yR = 0; yR < ${e.outHeight}; yR++) {\n            int xR = wR + yR * ${t} - ${r};\n\n            if (xR < 0 || xR >= ${e.inHeight}) {\n              continue;\n            }\n\n            for (int yC = 0; yC < ${e.outWidth}; yC++) {\n              int xC = wC + yC * ${n} - ${a};\n\n              if (xC < 0 || xC >= ${e.inWidth}) {\n                continue;\n              }\n\n              float dyValue = getDy(b, yR, yC, d2);\n              float xValue = getX(b, xR, xC, d1);\n              dotProd += (xValue * dyValue);\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class Ep{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const t=e.filterHeight,n=e.filterWidth,r=e.strideHeight,a=e.strideWidth,s=t-1-e.padInfo.top,o=n-1-e.padInfo.left,i=e.outChannels/e.inChannels;this.userCode=`\n      const ivec2 pads = ivec2(${s}, ${o});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[3];\n        ivec2 dyCorner = coords.yz - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        float dotProd = 0.0;\n\n        for (int wR = 0; wR < ${t}; wR++) {\n          float dyR = float(dyRCorner + wR) / ${r}.0;\n\n          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = ${t} - 1 - wR;\n\n          for (int wC = 0; wC < ${n}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${a}.0;\n\n            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = ${n} - 1 - wC;\n\n            // TO DO: Vec4 over the channelMul\n            for (int dm = 0; dm < ${i}; dm++) {\n              int d2 = d1 * ${i} + dm;\n              float xValue = getDy(batch, idyR, idyC, d2);\n              float wValue = getW(wRPerm, wCPerm, d1, dm);\n              dotProd += xValue * wValue;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ap(e){const{inputs:t,backend:n,attrs:r}=e,{x:a,dy:s}=t,{strides:o,dilations:i,pad:u,dimRoundingMode:l,filterShape:d}=r,p=c["backend_util"].computeConv2DInfo(a.shape,d,o,i,u,l,!0),h=new $p(p);return n.runWebGLProgram(h,[a,s],"float32")}const Rp={kernelName:c["DepthwiseConv2dNativeBackpropFilter"],backendName:"webgl",kernelFunc:Ap};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _p(e){const{inputs:t,backend:n,attrs:r}=e,{dy:a,filter:s}=t,{strides:o,dilations:i,pad:u,dimRoundingMode:l,inputShape:d}=r,p=c["backend_util"].computeConv2DInfo(d,s.shape,o,i,u,l,!0),h=new Ep(p);return n.runWebGLProgram(h,[a,s],"float32")}const Fp={kernelName:c["DepthwiseConv2dNativeBackpropInput"],backendName:"webgl",kernelFunc:_p};
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Dp{constructor(e){this.variableNames=["X"],this.outputShape=[e,e],this.userCode="\n      void main() {\n          ivec2 coords = getOutputCoords();\n          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;\n          setOutput(val);\n      }\n    "}}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Mp(e){const{inputs:t,backend:n}=e,{x:r}=t,a=[...r.shape,...r.shape],s=c["util"].sizeFromShape(r.shape),o=Nu({inputs:{x:r},backend:n,attrs:{shape:[s]}}),i=new Dp(s),u=n.runWebGLProgram(i,[o],o.dtype),l=Nu({inputs:{x:u},backend:n,attrs:{shape:a}});return n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(u),l}const Lp={kernelName:c["Diag"],backendName:"webgl",kernelFunc:Mp};
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Pp{constructor(e){this.variableNames=["x","W"],this.outputShape=e.outShape;const{inHeight:t,inWidth:n,padInfo:r,strideHeight:a,strideWidth:s,filterHeight:o,filterWidth:i,dilationHeight:c,dilationWidth:u}=e,{top:l,left:d}=r;this.userCode=`\n      const ivec2 strides = ivec2(${a}, ${s});\n      const ivec2 pads = ivec2(${l}, ${d});\n      const float neg_infinity = -3.4e38;\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        int d1 = coords.w;\n        ivec2 outTopLeftCorner =\n            coords.yz * strides - pads;\n        int hBeg = outTopLeftCorner.x;\n        int wBeg = outTopLeftCorner.y;\n\n        float curVal = neg_infinity;\n        for (int h = 0; h < ${o}; h++) {\n          int hIn = hBeg + h * ${c};\n\n          if (hIn >= 0 && hIn < ${t}) {\n            for (int w = 0; w < ${i}; w++) {\n              int wIn = wBeg + w * ${u};\n\n              if (wIn >= 0 && wIn < ${n}) {\n                float xVal = getX(batch, hIn, wIn, d1);\n                float wVal = getW(h, w, d1);\n\n                float val = xVal + wVal;\n                if (val > curVal) {\n                  curVal = val;\n                }\n              }\n            }\n          }\n        }\n\n        float result = curVal;\n        setOutput(result);\n      }\n    `}}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Bp(e){const{inputs:t,backend:n,attrs:r}=e,{x:a,filter:s}=t,{strides:o,pad:i,dilations:u}=r,l=c["backend_util"].computeDilation2DInfo(a.shape,s.shape,o,i,"NHWC",u);let d;const p=new Pp(l);d=n.runWebGLProgram(p,[a,s],"float32");const h=Nu({inputs:{x:d},backend:n,attrs:{shape:l.outShape}});return n.disposeIntermediateTensorInfo(d),h}const Vp={kernelName:c["Dilation2D"],backendName:"webgl",kernelFunc:Bp};
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zp(e){const{inputs:t,backend:n,attrs:r}=e,{equation:a}=r,s=t,{allDims:o,summedDims:i,idDims:u}=c["backend_util"].decodeEinsumEquation(a,s.length);c["backend_util"].checkEinsumDimSizes(o.length,u,s);const{path:l,steps:d}=c["backend_util"].getEinsumComputePath(i,u),p=d.length;let h=null,f=o.length;const m=[];for(let b=0;b<p;++b){for(const e of d[b]){const{permutationIndices:t,expandDims:r}=c["backend_util"].getEinsumPermutation(f,u[e]);let a;c["backend_util"].isIdentityPermutation(t)?a=s[e]:(a=Pu({inputs:{x:s[e]},backend:n,attrs:{perm:t}}),m.push(a));const o=a.shape.slice();for(let e=0;e<r.length;++e)o.splice(r[e],0,1);c["util"].arraysEqual(a.shape,o)||(a=Nu({inputs:{x:a},backend:n,attrs:{shape:o}}),m.push(a)),null===h?h=a:(h=ku({inputs:{a:a,b:h},backend:n}),m.push(h))}b<p-1&&(l[b]>=0&&(h=Mu({inputs:{x:h},backend:n,attrs:{axis:l[b]-(o.length-f),keepDims:!1}}),m.push(h)),f--)}for(const c of m)c!==h&&n.disposeIntermediateTensorInfo(c);return h}const Wp={kernelName:c["Einsum"],backendName:"webgl",kernelFunc:zp},Up="return (x >= 0.0) ? x : (exp(x) - 1.0);",Gp="\n  vec4 result;\n\n  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);\n  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);\n  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);\n  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);\n\n  return result;\n",Hp=bu({opSnippet:Up,packedOpSnippet:Gp}),qp={kernelName:c["Elu"],backendName:"webgl",kernelFunc:Hp},Kp="return (b >= 1.0) ? a : a * (b + 1.0);",Xp="\n  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));\n  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));\n",Yp=e=>{const{inputs:t,backend:n}=e,{dy:r,y:a}=t,s=Object(c["env"])().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new eu(Xp,r.shape,a.shape):new Zc(Kp,r.shape,a.shape);return n.runWebGLProgram(s,[r,a],r.dtype)},Qp={kernelName:c["EluGrad"],backendName:"webgl",kernelFunc:Yp},Zp="\n  return vec4(equal(a, b));\n",Jp="return float(a == b);",eh=gu({opSnippet:Jp,packedOpSnippet:Zp,dtype:"bool",cpuKernelImpl:Si}),th={kernelName:c["Equal"],backendName:"webgl",kernelFunc:eh},nh=`\n  // Error function is calculated approximately with elementary function.\n  // See "Handbook of Mathematical Functions with Formulas,\n  // Graphs, and Mathematical Tables", Abramowitz and Stegun.\n  float p = ${c["backend_util"].ERF_P};\n  float a1 = ${c["backend_util"].ERF_A1};\n  float a2 = ${c["backend_util"].ERF_A2};\n  float a3 = ${c["backend_util"].ERF_A3};\n  float a4 = ${c["backend_util"].ERF_A4};\n  float a5 = ${c["backend_util"].ERF_A5};\n\n  float sign = sign(x);\n  x = abs(x);\n  float t = 1.0 / (1.0 + p * x);\n  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));\n`,rh=bu({opSnippet:nh}),ah={kernelName:c["Erf"],backendName:"webgl",kernelFunc:rh},sh="return exp(x);",oh=bu({opSnippet:sh,packedOpSnippet:sh,cpuKernelImpl:Ni}),ih={kernelName:c["Exp"],backendName:"webgl",kernelFunc:oh};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function ch(e){const{inputs:t,attrs:n,backend:r}=e,{dim:a}=n,{input:s}=t,o=s.shape.length,i=s.shape.slice();let u=a;return a<0&&(c["util"].assert(-(o+1)<=a,()=>`Axis must be in the interval [${-(o+1)}, ${o}]`),u=o+a+1),i.splice(u,0,1),Nu({inputs:{x:s},backend:r,attrs:{shape:i}})}const uh={kernelName:c["ExpandDims"],backendName:"webgl",kernelFunc:ch},lh="return exp(x) - 1.0;",dh=bu({opSnippet:lh,packedOpSnippet:lh,cpuKernelImpl:Ci}),ph={kernelName:c["Expm1"],backendName:"webgl",kernelFunc:dh};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class hh{constructor(e,t,n){this.variableNames=["real","imag"];const r=t[1];this.outputShape=t;const a=n?"2.0 * "+Math.PI:"-2.0 * "+Math.PI,s=n?r+".0":"1.0";let o;if("real"===e)o="return real * expR - imag * expI;";else{if("imag"!==e)throw new Error(`FFT component must be either "real" or "imag", got ${e}.`);o="return real * expI + imag * expR;"}this.userCode=`\n      const float exponentMultiplier = ${a};\n\n      float unaryOpComplex(float real, float expR, float imag, float expI) {\n        ${o}\n      }\n\n      float mulMatDFT(int batch, int index) {\n        float indexRatio = float(index) / float(${r});\n        float exponentMultiplierTimesIndexRatio =\n            exponentMultiplier * indexRatio;\n\n        float result = 0.0;\n\n        for (int i = 0; i < ${r}; i++) {\n          // x = (-2|2 * PI / N) * index * i;\n          float x = exponentMultiplierTimesIndexRatio * float(i);\n          float expR = cos(x);\n          float expI = sin(x);\n          float real = getReal(batch, i);\n          float imag = getImag(batch, i);\n\n          result +=\n              unaryOpComplex(real, expR, imag, expI) / ${s};\n        }\n\n        return result;\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        setOutput(mulMatDFT(coords[0], coords[1]));\n      }\n    `}}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fh(e,t,n){const r=n.texData.get(e.dataId),a=c["util"].sizeFromShape(e.shape),s=e.shape[e.shape.length-1],o=a/s,i=Nu({inputs:{x:e},backend:n,attrs:{shape:[o,s]}}),u=i.shape,l=new hh("real",u,t),d=new hh("imag",u,t),p=[{dataId:r.complexTensorInfos.real.dataId,dtype:r.complexTensorInfos.real.dtype,shape:u},{dataId:r.complexTensorInfos.imag.dataId,dtype:r.complexTensorInfos.imag.dtype,shape:u}],h=n.runWebGLProgram(l,p,"float32"),f=n.runWebGLProgram(d,p,"float32"),m=ru({inputs:{real:h,imag:f},backend:n});n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(f);const b=Nu({inputs:{x:m},backend:n,attrs:{shape:e.shape}});return n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(m),b}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mh(e){const{inputs:t,backend:n}=e,{input:r}=t;return fh(r,!1,n)}const bh={kernelName:c["FFT"],backendName:"webgl",kernelFunc:mh};
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class gh{constructor(e,t){this.outputShape=[],this.customUniforms=[{name:"value",type:"float"}],this.variableNames=["x"],this.outputShape=e,this.userCode="\n      void main() {\n        // Input can be obtained from uniform value.\n        setOutput(value);\n      }\n    "}}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yh(e){const{backend:t,attrs:n}=e,{shape:r,value:a}=n;let{dtype:s}=n;if(s=s||c["util"].inferDtype(a),"string"===s){const e=c["util"].getArrayFromDType(s,c["util"].sizeFromShape(r));return e.fill(a),t.makeTensorInfo(r,s,e)}{const e=new gh(r,a),n=[[a]];return t.runWebGLProgram(e,[],s,n)}}const xh={kernelName:c["Fill"],backendName:"webgl",kernelFunc:yh};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Oh{constructor(e){this.variableNames=["Image"],this.outputShape=[];const t=e[2];this.outputShape=e,this.userCode=`\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int x = coords[2];\n\n          int coordX = ${t} - x - 1;\n          float outputValue;\n          if(coordX >= 0 && coordX < ${t}) {\n            outputValue = getImage(coords[0], coords[1], coordX, coords[3]);\n          } else {\n            outputValue = getImage(coords[0], coords[1], coords[2], coords[3]);\n          }\n          setOutput(outputValue);\n        }\n    `}}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vh={kernelName:c["FlipLeftRight"],backendName:"webgl",kernelFunc:({inputs:e,backend:t})=>{const{image:n}=e,r=t,a=new Oh(n.shape),s=r.runWebGLProgram(a,[n],n.dtype);return s}},wh="return floor(x);",kh=bu({opSnippet:wh,packedOpSnippet:wh,cpuKernelImpl:Ii}),jh={kernelName:c["Floor"],backendName:"webgl",kernelFunc:kh},Sh="\n  float s = sign(a) * sign(b);\n  int ia = round(a);\n  int ib = round(b);\n  if (ib != 0) {\n    // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n    return float(idiv(ia, ib, s));\n  } else {\n    return NAN;\n  }\n",Nh="\n  ivec4 ia = round(a);\n  ivec4 ib = round(b);\n  bvec4 cond = notEqual(ib, ivec4(0));\n  ivec4 result = ivec4(0);\n  vec4 s = sign(a) * sign(b);\n\n  // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n  if (cond[0]) {\n    result[0] = idiv(ia[0], ib[0], s[0]);\n  }\n  if (cond[1]) {\n    result[1] = idiv(ia[1], ib[1], s[1]);\n  }\n  if (cond[2]) {\n    result[2] = idiv(ia[2], ib[2], s[2]);\n  }\n  if (cond[3]) {\n    result[3] = idiv(ia[3], ib[3], s[3]);\n  }\n  return vec4(result);\n",Ch=gu({opSnippet:Sh,packedOpSnippet:Nh,dtype:"int32"}),Ih={kernelName:c["FloorDiv"],backendName:"webgl",kernelFunc:Ch};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class Th{constructor(e){this.variableNames=["A"];const t=sa(),[n,r]=e;this.outputShape=e,this.userCode=`\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${r}.0, ${n}.0);\n\n        vec4 values = ${t.texture2D}(A, uv);\n        float value;\n        if (depth == 0) {\n          value = values.r;\n        } else if (depth == 1) {\n          value = values.g;\n        } else if (depth == 2) {\n          value = values.b;\n        } else if (depth == 3) {\n          value = values.a;\n        }\n\n        setOutput(floor(value * 255.0 + 0.5));\n      }\n    `}}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class $h{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0;const t=sa(),[n,r]=e;this.outputShape=e,this.userCode=`\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n\n        vec4 result = vec4(0.);\n\n        for(int row=0; row<=1; row++) {\n          for(int col=0; col<=1; col++) {\n            texC = coords[1] + row;\n            depth = coords[2] + col;\n\n            vec2 uv = (vec2(texC, texR) + halfCR) /\n                       vec2(${r}.0, ${n}.0);\n            vec4 values = ${t.texture2D}(A, uv);\n            float value;\n            if (depth == 0) {\n              value = values.r;\n            } else if (depth == 1) {\n              value = values.g;\n            } else if (depth == 2) {\n              value = values.b;\n            } else if (depth == 3) {\n              value = values.a;\n            }\n\n            result[row * 2 + col] = floor(value * 255.0 + 0.5);\n          }\n        }\n\n        ${t.output} = result;\n      }\n    `}}
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Eh={kernelName:c["FromPixels"],backendName:"webgl",kernelFunc:Rh};let Ah;function Rh(e){const{inputs:t,backend:n,attrs:r}=e;let{pixels:a}=t;const{numChannels:s}=r,o="undefined"!==typeof HTMLVideoElement&&a instanceof HTMLVideoElement,i="undefined"!==typeof HTMLImageElement&&a instanceof HTMLImageElement,[u,l]=o?[a.videoWidth,a.videoHeight]:[a.width,a.height],d=[l,u],p=[l,u,s];(i||o)&&(null==Ah&&(Ah=document.createElement("canvas").getContext("2d")),Ah.canvas.width=u,Ah.canvas.height=l,Ah.drawImage(a,0,0,u,l),a=Ah.canvas);const h=n.makeTensorInfo(d,"int32");n.texData.get(h.dataId).usage=tr.PIXELS,n.gpgpu.uploadPixelDataToTexture(n.getTexture(h.dataId),a);const f=Object(c["env"])().getBool("WEBGL_PACK")?new $h(p):new Th(p),m=n.runWebGLProgram(f,[h],"int32");return n.disposeData(h.dataId),m}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _h(e){const{inputs:t,backend:n,attrs:r}=e,{x:a,filter:s,bias:o,preluActivationWeights:i}=t,{strides:u,pad:l,dataFormat:d,dilations:p,dimRoundingMode:h,activation:f,leakyreluAlpha:m}=r,b=c["backend_util"].convertConv2DDataFormat(d),g=c["backend_util"].computeConv2DInfo(a.shape,s.shape,u,p,l,h,!1,b);let y;const x=[];if(1!==g.filterHeight||1!==g.filterWidth||1!==g.dilationHeight||1!==g.dilationWidth||1!==g.strideHeight||1!==g.strideWidth||"SAME"!==g.padInfo.type&&"VALID"!==g.padInfo.type)if(Object(c["env"])().getBool("WEBGL_CONV_IM2COL")&&1===a.shape[0])y=Ud({x:a,filter:s,convInfo:g,backend:n,bias:o,activation:f,preluActivationWeights:i,leakyreluAlpha:m});else{const e=null!=o,t=null!=i,r="leakyrelu"===f,u=f?yu(f,!1):null,l=new Bd(g,e,u,t,r),d=[a,s];if(o&&d.push(o),i&&d.push(i),r){const e=n.makeTensorInfo([],"float32",c["util"].createScalarValue(m,"float32"));d.push(e),x.push(e)}y=n.runWebGLProgram(l,d,"float32")}else y=Wd({x:a,filter:s,convInfo:g,backend:n,bias:o,activation:f,preluActivationWeights:i,leakyreluAlpha:m});const O=Nu({inputs:{x:y},backend:n,attrs:{shape:g.outShape}});return x.push(y),x.forEach(e=>n.disposeIntermediateTensorInfo(e)),O}const Fh={kernelName:c["FusedConv2D"],backendName:"webgl",kernelFunc:_h};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Dh(e){const{inputs:t,backend:n,attrs:r}=e,{x:a,filter:s,bias:o,preluActivationWeights:i}=t,{strides:u,pad:l,dilations:d,dimRoundingMode:p,activation:h,leakyreluAlpha:f}=r,m=[];let b=d;null==b&&(b=[1,1]),c["util"].assert(c["backend_util"].eitherStridesOrDilationsAreOne(u,b),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${u} and dilations '${b}'`);const g=c["backend_util"].computeConv2DInfo(a.shape,s.shape,u,b,l,p,!0),y=Object(c["env"])().getBool("WEBGL_PACK_DEPTHWISECONV")&&g.strideWidth<=2&&g.outChannels/g.inChannels===1,x=h?yu(h,y):null,O=[a,s],v=null!=o,w=null!=i,k="leakyrelu"===h;if(v&&O.push(o),w&&O.push(i),k){const e=n.makeTensorInfo([],"float32",c["util"].createScalarValue(f,"float32"));O.push(e),m.push(e)}let j;j=y?new Cp(g,v,x,w,k):new Np(g,v,x,w,k);const S=[[g.padInfo.top,g.padInfo.left],[g.strideHeight,g.strideWidth],[g.dilationHeight,g.dilationWidth],[g.inHeight,g.inWidth]],N=n.runWebGLProgram(j,O,"float32",S);return m.forEach(e=>n.disposeIntermediateTensorInfo(e)),N}const Mh={kernelName:c["FusedDepthwiseConv2D"],backendName:"webgl",kernelFunc:Dh};class Lh{constructor(e,t,n){this.sliceDim=e,this.strides=t,this.variableNames=["x","indices"],this.outputShape=n;const r=ts(t.length),a=ts(n.length),s=this.sliceDim>1?"strides[j]":"strides";this.userCode=`\n        ${r} strides = ${r}(${this.strides});\n         void main() {\n          ${a} coords = getOutputCoords();\n          int flattenIndex = 0;\n          for (int j = 0; j < ${this.sliceDim}; j++) {\n            int index = round(getIndices(coords[0], j));\n            flattenIndex += index * ${s};\n          }\n          setOutput(getX(flattenIndex, coords[1]));\n        }\n      `}}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ph(e){const{inputs:t,backend:n}=e,{params:r,indices:a}=t,s=a.shape,o=s[s.length-1],i=c["util"].sizeFromShape(r.shape),[u,l,d,p]=c["backend_util"].prepareAndValidate(r,a),h=Nu({inputs:{x:a},backend:n,attrs:{shape:[l,o]}}),f=Nu({inputs:{x:r},backend:n,attrs:{shape:[c["util"].sizeFromShape(r.shape)/d,d]}});if(n.shouldExecuteOnCPU([r,a])||"string"===r.dtype){const e=n.readSync(a.dataId),t=n.bufferSync(r),s=Ti(e,t,r.dtype,l,o,d,p,r.shape,i);return n.makeTensorInfo(u,r.dtype,s.values)}const m=new Lh(o,p,[l,d]),b=n.runWebGLProgram(m,[f,h],f.dtype),g=Nu({inputs:{x:b},backend:n,attrs:{shape:u}});return n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(b),g}const Bh={kernelName:c["GatherNd"],backendName:"webgl",kernelFunc:Ph};
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Vh{constructor(e,t){this.variableNames=["A","indices"],this.outputShape=t,this.rank=t.length;const n=ts(this.rank),r=zh(e,2);this.userCode=`\n      void main() {\n        ${n} resRC = getOutputCoords();\n        setOutput(getA(${r}));\n      }\n    `}}function zh(e,t){const n=["resRC.x","resRC.y","resRC.z","resRC.w"],r=[];for(let a=0;a<e.length;a++)2===a?r.push("int(getIndices(resRC.x, resRC.z))"):r.push(""+n[a]);return r.join()}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Wh(e){const{inputs:t,backend:n,attrs:r}=e,{x:a,indices:s}=t,{axis:o,batchDims:i}=r,u=c["util"].parseAxisParam(o,a.shape)[0],l=c["backend_util"].segment_util.collectGatherOpShapeInfo(a,s,u,i),d=c["util"].sizeFromShape(s.shape),p=[],h=Nu({inputs:{x:a},backend:n,attrs:{shape:[l.batchSize,l.outerSize,l.dimSize,l.sliceSize]}}),f=Nu({inputs:{x:s},backend:n,attrs:{shape:[l.batchSize,d/l.batchSize]}});p.push(h),p.push(f);const m=[l.batchSize,l.outerSize,d/l.batchSize,l.sliceSize];if(n.shouldExecuteOnCPU([a,s])||"string"===a.dtype){const e=n.bufferSync(f),t=n.bufferSync(h),r=$i(t,e,m);return p.forEach(e=>n.disposeIntermediateTensorInfo(e)),n.makeTensorInfo(l.outputShape,r.dtype,r.values)}const b=new Vh(h.shape,m),g=n.runWebGLProgram(b,[h,f],h.dtype);p.push(g);const y=Nu({inputs:{x:g},backend:n,attrs:{shape:l.outputShape}});return p.forEach(e=>n.disposeIntermediateTensorInfo(e)),y}const Uh={kernelName:c["GatherV2"],backendName:"webgl",kernelFunc:Wh},Gh="return float(a > b);",Hh="\n  return vec4(greaterThan(a, b));\n",qh=gu({opSnippet:Gh,packedOpSnippet:Hh,cpuKernelImpl:Ei,dtype:"bool"}),Kh={kernelName:c["Greater"],backendName:"webgl",kernelFunc:qh},Xh="return float(a >= b);",Yh="\n  return vec4(greaterThanEqual(a, b));\n",Qh=gu({opSnippet:Xh,packedOpSnippet:Yh,dtype:"bool",cpuKernelImpl:Ai}),Zh={kernelName:c["GreaterEqual"],backendName:"webgl",kernelFunc:Qh};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Jh(e){const{inputs:t,backend:n}=e,{input:r}=t;return fh(r,!0,n)}const ef={kernelName:c["IFFT"],backendName:"webgl",kernelFunc:Jh},tf="return float(!isnan(x) && !isinf(x));",nf=bu({opSnippet:tf,dtype:"bool"}),rf={kernelName:c["IsFinite"],backendName:"webgl",kernelFunc:nf},af="return float(isinf(x));",sf=bu({opSnippet:af,dtype:"bool"}),of={kernelName:c["IsInf"],backendName:"webgl",kernelFunc:sf},cf="return float(isnan(x));",uf=bu({opSnippet:cf,dtype:"bool"}),lf={kernelName:c["IsNan"],backendName:"webgl",kernelFunc:uf},df="return float(a < b);",pf="\n  return vec4(lessThan(a, b));\n",hf=gu({opSnippet:df,packedOpSnippet:pf,cpuKernelImpl:Ri,dtype:"bool"}),ff={kernelName:c["Less"],backendName:"webgl",kernelFunc:hf},mf="return float(a <= b);",bf="\n  return vec4(lessThanEqual(a, b));\n",gf=gu({opSnippet:mf,packedOpSnippet:bf,cpuKernelImpl:_i,dtype:"bool"}),yf={kernelName:c["LessEqual"],backendName:"webgl",kernelFunc:gf};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function xf(e){const{backend:t,attrs:n}=e,{start:r,stop:a,num:s}=n,o=Fi(r,a,s);return t.makeTensorInfo([o.length],"float32",o)}const Of={kernelName:c["LinSpace"],backendName:"webgl",kernelFunc:xf},vf="if (x < 0.0) return NAN;\n  return log(x);",wf="\n  vec4 result = log(x);\n  vec4 isNaN = vec4(lessThan(x, vec4(0.0)));\n  result.r = isNaN.r == 1.0 ? NAN : result.r;\n  result.g = isNaN.g == 1.0 ? NAN : result.g;\n  result.b = isNaN.b == 1.0 ? NAN : result.b;\n  result.a = isNaN.a == 1.0 ? NAN : result.a;\n\n  return result;\n",kf=bu({opSnippet:vf,packedOpSnippet:wf,cpuKernelImpl:Di}),jf={kernelName:c["Log"],backendName:"webgl",kernelFunc:kf},Sf="return log(1.0 + x);",Nf=bu({opSnippet:Sf}),Cf={kernelName:c["Log1p"],backendName:"webgl",kernelFunc:Nf},If="return float(a >= 1.0 && b >= 1.0);",Tf="\n  return vec4(\n    vec4(greaterThanEqual(a, vec4(1.0))) *\n    vec4(greaterThanEqual(b, vec4(1.0))));\n",$f=gu({opSnippet:If,packedOpSnippet:Tf,dtype:"bool"}),Ef={kernelName:c["LogicalAnd"],backendName:"webgl",kernelFunc:$f},Af="return float(!(x >= 1.0));",Rf=bu({opSnippet:Af}),_f={kernelName:c["LogicalNot"],backendName:"webgl",kernelFunc:Rf},Ff="return float(a >= 1.0 || b >= 1.0);",Df="\n  return min(\n    vec4(greaterThanEqual(a, vec4(1.0))) +\n    vec4(greaterThanEqual(b, vec4(1.0))),\n    vec4(1.0));\n",Mf=gu({opSnippet:Ff,packedOpSnippet:Df,dtype:"bool"}),Lf={kernelName:c["LogicalOr"],backendName:"webgl",kernelFunc:Mf};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class Pf{constructor(e,t,n,r,a){this.variableNames=["x"],this.outputShape=[];const s=t,o=e[3]-1;let i;this.outputShape=e;const c=`float(${n}) + float(${r}) * sum`;i=.5===a?`inversesqrt(${c})`:1===a?`1.0/(${c})`:`exp(log(${c}) * float(-${a}));`,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n        int d = coords[3];\n        float x = getX(b, r, c, d);\n        float sum = 0.0;\n        for (int j = -${s}; j <= ${s}; j++) {\n          int idx = d + j;\n          if (idx >= 0 && idx <=  ${o}) {\n            float z = getX(b, r, c, idx);\n            sum += z * z;\n          }\n        }\n        float val = x * ${i};\n        setOutput(val);\n      }\n    `}}
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Bf{constructor(e,t,n,r,a){this.variableNames=["x"],this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0;const s=t,o=e[3]-1;let i;this.outputShape=e;const c=`float(${n}) + float(${r}) * sum`;i=.5===a?`inversesqrt(${c})`:1===a?`1.0/(${c})`:`exp(log(${c}) * float(-${a}));`,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords.x;\n        int r = coords.y;\n        int c = coords.z;\n        int d = coords.w;\n\n        bool hasNextCol = d < ${this.outputShape[3]};\n        bool hasNextRow = c < ${this.outputShape[2]};\n\n        vec4 sum = vec4(0.);\n        vec4 xFragAtOutputCoords = getX(b, r, c, d);\n\n        vec4 xAtOutputCoords = vec4(\n          getChannel(xFragAtOutputCoords, vec2(c, d)),\n          hasNextCol ?\n            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,\n          hasNextRow ?\n            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0\n        );\n\n        int firstChannel = d - ${s};\n        vec2 cache = vec2(0.);\n        if(firstChannel >= 0){\n          vec4 firstChannelFrag = getX(b, r, c, firstChannel);\n          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));\n            if(hasNextRow){\n              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));\n            }\n        }\n\n        ivec2 depth = ivec2(d, d + 1);\n        for (int j = - ${s}; j <= ${s}; j++) {\n          ivec2 idx = depth + j;\n          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));\n          bvec2 belowUpperBound = lessThanEqual(idx, ivec2(${o}));\n\n          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;\n          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;\n\n          if(depthInRange || depthPlusOneInRange){\n            vec4 z = vec4(0.);\n            vec4 xFragAtCurrentDepth;\n            z.xz = cache.xy;\n            if(depthPlusOneInRange && hasNextCol){\n              xFragAtCurrentDepth = idx.y != d ?\n                getX(b, r, c, idx.y) : xFragAtOutputCoords;\n              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));\n              if(hasNextRow){\n                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));\n              }\n            }\n            cache.xy = z.yw;\n            sum += z * z;\n          }\n        }\n        vec4 result = xAtOutputCoords * ${i};\n        setOutput(result);\n      }\n    `}}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Vf=e=>{const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{depthRadius:s,bias:o,alpha:i,beta:u}=r,l=Object(c["env"])().getBool("WEBGL_PACK_NORMALIZATION")?new Bf(a.shape,s,o,i,u):new Pf(a.shape,s,o,i,u);return n.runWebGLProgram(l,[a],a.dtype)},zf={kernelName:c["LRN"],backendName:"webgl",kernelFunc:Vf};
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class Wf{constructor(e,t,n,r,a){this.variableNames=["inputImage","outputImage","dy"],this.outputShape=[],this.outputShape=e,this.depth=e[3],this.depthRadius=t,this.bias=n,this.alpha=r,this.beta=a,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n\n        float result = 0.0;\n        for (int d = 0; d < ${this.depth}; ++d) {\n          int depthBegin = int(max(0.0, float(d - ${t})));\n          int depthEnd = int(min(float(${this.depth}),\n              float(d + ${t} + 1)));\n\n          const int MIN_DEPTH_BEGIN = 0;\n          const int MAX_DEPTH_END = ${this.depth};\n\n          float norm = 0.0;\n          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd) {\n              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);\n            }\n            else {\n              break;\n            }\n          }\n\n          norm = float(${r}) * norm + float(${n});\n\n          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd){\n              float dyi = -2.0 * float(${r})\n                * float(${a})\n                * getInputImage(b ,r ,c, k) * getOutputImage(b, r, c, d)\n                / norm;\n              if (k == d) {\n                dyi += pow(norm, -1.0 * ${a});\n              }\n              if (k == coords[3]) {\n                dyi *= getDy(b, r, c, d);\n                result += dyi;\n              }\n            }\n            else {\n              break;\n            }\n          }\n      }\n      setOutput(result);\n      }\n    `}}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Uf=e=>{const{inputs:t,backend:n,attrs:r}=e,{x:a,y:s,dy:o}=t,{depthRadius:i,bias:c,alpha:u,beta:l}=r,d=new Wf(a.shape,i,c,u,l);return n.runWebGLProgram(d,[a,s,o],a.dtype)},Gf={kernelName:c["LRNGrad"],backendName:"webgl",kernelFunc:Uf};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Hf(e,t,n,r){const a=c["util"].sizeFromShape(t),s=c["util"].sizeFromShape(e.shape),o=s/a,i=Nu({inputs:{x:e},attrs:{shape:[o,a]},backend:r}),u=Eu(i,e.dtype,"max",r),l=Nu({inputs:{x:u},attrs:{shape:n},backend:r});return r.disposeIntermediateTensorInfo(i),r.disposeIntermediateTensorInfo(u),l}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qf(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{reductionIndices:s,keepDims:o}=r,i=a.shape.length,u=c["util"].parseAxisParam(s,a.shape);let l=u;const d=c["backend_util"].getAxesPermutation(l,i),p=null!=d,h=n.shouldExecuteOnCPU([a]);let f=a;if(p){if(h){const e=n.texData.get(f.dataId),t=e.values,r=new Array(i);for(let n=0;n<r.length;n++)r[n]=a.shape[d[n]];const s=oc(t,a.shape,a.dtype,d,r);f=n.makeTensorInfo(r,a.dtype);const o=n.texData.get(f.dataId);o.values=s}else f=Fu(a,d,n);l=c["backend_util"].getInnerMostAxes(l.length,i)}c["backend_util"].assertAxesAreInnerMostDims("max",l,i);const[m,b]=c["backend_util"].computeOutAndReduceShapes(f.shape,l);let g,y=m;if(o&&(y=c["backend_util"].expandShapeToKeepDim(m,u)),h){const e=n.texData.get(f.dataId),t=e.values,r=Mi(t,c["util"].sizeFromShape(b),y,a.dtype);g=n.makeTensorInfo(y,a.dtype);const s=n.texData.get(g.dataId);s.values=r}else g=Hf(f,b,y,n);return p&&n.disposeIntermediateTensorInfo(f),g}const Kf={kernelName:c["Max"],backendName:"webgl",kernelFunc:qf},Xf=Qc+"\n  return max(a, b);\n",Yf="\n  vec4 result = vec4(max(a, b));\n  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));\n  "+Jc+"\n  return result;\n",Qf=gu({opSnippet:Xf,packedOpSnippet:Yf,cpuKernelImpl:Li}),Zf={kernelName:c["Maximum"],backendName:"webgl",kernelFunc:Qf};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Jf(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t;ra(a,"maxPool");const{filterSize:s,strides:o,pad:i,dimRoundingMode:u}=r,l=1;c["util"].assert(c["backend_util"].eitherStridesOrDilationsAreOne(o,l),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${o} and dilations '${l}'`);const d=c["backend_util"].computePool2DInfo(a.shape,s,o,l,i,u);if(1===d.filterWidth&&1===d.filterHeight&&c["util"].arraysEqual(d.inShape,d.outShape))return tu({inputs:{x:a},backend:n});const p=new Dl(d,"max",!1);return n.runWebGLProgram(p,[a],a.dtype)}const em={kernelName:c["MaxPool"],backendName:"webgl",kernelFunc:Jf};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tm(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{filterSize:s,strides:o,pad:i,dataFormat:u,dimRoundingMode:l}=r,d=[1,1,1],p=c["backend_util"].computePool3DInfo(a.shape,s,o,d,i,l,u),h=new Ml(p,"max",!1);return n.runWebGLProgram(h,[a],a.dtype)}const nm={kernelName:c["MaxPool3D"],backendName:"webgl",kernelFunc:tm};
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class rm{constructor(e){this.variableNames=["dy","maxPos"],this.outputShape=e.inShape;const t=e.strideHeight,n=e.strideWidth,r=e.dilationHeight,a=e.effectiveFilterHeight,s=e.effectiveFilterWidth,o=a-1-e.padInfo.top,i=s-1-e.padInfo.left,c=a*s-1;this.userCode=`\n      const ivec2 pads = ivec2(${o}, ${i});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${a};\n          wR += ${r}) {\n          float dyR = float(dyRCorner + wR) / ${t}.0;\n\n          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < ${s}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${n}.0;\n\n            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n            int maxPosValue = ${c} - int(getMaxPos(b, idyR, idyC, d));\n\n            // Get the current value, check it against the value from the\n            // position matrix.\n            int curPosValue = wR * ${s} + wC;\n            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n            dotProd += dyValue * mask;\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class am{constructor(e){this.variableNames=["dy","maxPos"],this.outputShape=e.inShape;const t=e.strideDepth,n=e.strideHeight,r=e.strideWidth,a=e.dilationDepth,s=e.dilationHeight,o=e.dilationWidth,i=e.effectiveFilterDepth,c=e.effectiveFilterHeight,u=e.effectiveFilterWidth,l=i-1-e.padInfo.front,d=c-1-e.padInfo.top,p=u-1-e.padInfo.left,h=i*c*u-1;this.userCode=`\n      const ivec3 pads = ivec3(${l}, ${d}, ${p});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < ${i};\n           wD += ${a}) {\n          float dyD = float(dyDCorner + wD) / ${t}.0;\n\n          if (dyD < 0.0 || dyD >= ${e.outDepth}.0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < ${c};\n              wR += ${s}) {\n            float dyR = float(dyRCorner + wR) / ${n}.0;\n\n            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < ${u};\n                wC += ${o}) {\n              float dyC = float(dyCCorner + wC) / ${r}.0;\n\n              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n              int maxPosValue = ${h} -\n                  int(getMaxPos(batch, idyD, idyR, idyC, ch));\n\n              // Get the current value, check it against the value from the\n              // position matrix.\n              int curPosValue =\n                  wD * ${c} * ${u} +\n                  wR * ${u} + wC;\n              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n              dotProd += dyValue * mask;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sm(e){const{inputs:t,backend:n,attrs:r}=e,{dy:a,input:s}=t,o=s,{filterSize:i,strides:u,pad:l,dimRoundingMode:d}=r,p=[1,1,1],h=c["backend_util"].computePool3DInfo(o.shape,i,u,p,l,d),f=new Ml(h,"max",!0),m=n.runWebGLProgram(f,[o],o.dtype),b=new am(h),g=n.runWebGLProgram(b,[a,m],o.dtype);return n.disposeIntermediateTensorInfo(m),g}const om={kernelName:c["MaxPool3DGrad"],backendName:"webgl",kernelFunc:sm};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function im(e){const{inputs:t,backend:n,attrs:r}=e,{dy:a,input:s,output:o}=t,i=s;ra([s,o],"maxPoolGrad");const{filterSize:u,strides:l,pad:d,dimRoundingMode:p}=r,h=c["backend_util"].computePool2DInfo(i.shape,u,l,1,d,p),f=!0,m=new Dl(h,"max",f),b=n.runWebGLProgram(m,[i],i.dtype),g=new rm(h),y=n.runWebGLProgram(g,[a,b],i.dtype);return n.disposeIntermediateTensorInfo(b),y}const cm={kernelName:c["MaxPoolGrad"],backendName:"webgl",kernelFunc:im};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function um(e,t,n,r){let a=new Dl(n,"max",!1);const s=r.runWebGLProgram(a,[e],"float32");a=new Dl(n,"max",!0,!0,t);const o=r.runWebGLProgram(a,[e],"float32");return[s,o]}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const lm={kernelName:c["MaxPoolWithArgmax"],backendName:"webgl",kernelFunc:({inputs:e,attrs:t,backend:n})=>{const{x:r}=e,{filterSize:a,strides:s,pad:o,includeBatchInIndex:i}=t,u=n;c["util"].assert(4===r.shape.length,()=>`Error in maxPool: input must be rank 4 but got rank ${r.shape.length}.`);const l=[1,1];c["util"].assert(c["backend_util"].eitherStridesOrDilationsAreOne(s,l),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${s} and dilations '${l}'`);const d=c["backend_util"].computePool2DInfo(r.shape,a,s,l,o),[p,h]=um(r,i,d,u);return[p,h]}};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dm(e,t,n,r){const a=c["util"].sizeFromShape(t),s=c["util"].sizeFromShape(e.shape),o=s/a,i=Nu({inputs:{x:e},attrs:{shape:[o,a]},backend:r}),u=Eu(i,"float32","mean",r),l=Nu({inputs:{x:u},attrs:{shape:n},backend:r});return r.disposeIntermediateTensorInfo(i),r.disposeIntermediateTensorInfo(u),l}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const pm={kernelName:c["Mean"],backendName:"webgl",kernelFunc:({inputs:e,attrs:t,backend:n})=>{const{x:r}=e,{keepDims:a,axis:s}=t,o=n,i=r.shape.length,u=c["util"].parseAxisParam(s,r.shape);let l=u;const d=c["backend_util"].getAxesPermutation(l,i),p=null!=d,h=o.shouldExecuteOnCPU([r]),f=[];let m=r;if(p){if(h){const e=o.texData.get(m.dataId),t=e.values,n=new Array(i);for(let o=0;o<n.length;o++)n[o]=r.shape[d[o]];const a=oc(t,r.shape,r.dtype,d,n);m=o.makeTensorInfo(n,r.dtype);const s=o.texData.get(m.dataId);s.values=a}else m=Fu(r,d,o);f.push(m),l=c["backend_util"].getInnerMostAxes(l.length,i)}c["backend_util"].assertAxesAreInnerMostDims("sum",l,i);const[b,g]=c["backend_util"].computeOutAndReduceShapes(m.shape,l);let y=b;a&&(y=c["backend_util"].expandShapeToKeepDim(b,u));const x=dm(m,g,y,o);for(const c of f)o.disposeIntermediateTensorInfo(c);return x}};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hm(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,keepDims:o}=r,i=a.shape.length,u=c["util"].parseAxisParam(s,a.shape);let l=u;const d=c["backend_util"].getAxesPermutation(l,i);let p=a;null!=d&&(p=Pu({inputs:{x:a},backend:n,attrs:{perm:d}}),l=c["backend_util"].getInnerMostAxes(l.length,a.shape.length)),c["backend_util"].assertAxesAreInnerMostDims("min",l,i);const[h,f]=c["backend_util"].computeOutAndReduceShapes(p.shape,l),m=c["util"].sizeFromShape(f),b=Nu({inputs:{x:p},backend:n,attrs:{shape:[-1,m]}}),g=Eu(b,b.dtype,"min",n);let y;if(o){const e=c["backend_util"].expandShapeToKeepDim(h,u);y=Nu({inputs:{x:g},backend:n,attrs:{shape:e}})}else y=Nu({inputs:{x:g},backend:n,attrs:{shape:h}});return n.disposeIntermediateTensorInfo(b),n.disposeIntermediateTensorInfo(g),null!=d&&n.disposeIntermediateTensorInfo(p),y}const fm={kernelName:c["Min"],backendName:"webgl",kernelFunc:hm},mm=Qc+"\n  return min(a, b);\n",bm="\n  vec4 result = vec4(min(a, b));\n  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));\n  "+Jc+"\n  return result;\n",gm=gu({opSnippet:mm,packedOpSnippet:bm,cpuKernelImpl:Pi}),ym={kernelName:c["Minimum"],backendName:"webgl",kernelFunc:gm};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class xm{constructor(e,t,n){this.variableNames=["x"],this.outputShape=t.map((t,n)=>t[0]+e[n]+t[1]);const r=e.length,a=ts(r),s=t.map(e=>e[0]).join(","),o=t.map((t,n)=>t[0]+e[n]).join(","),i=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,r),c="reflect"===n?0:1;this.userCode=1!==r?`\n      ${a} start = ${a}(${s});\n      ${a} end = ${a}(${o});\n\n      void main() {\n        ${a} outC = getOutputCoords();\n        for (int i = 0; i < ${r}; i++) {\n          if (outC[i] < start[i]) {\n            outC[i] = start[i] * 2 - outC[i] - ${c};\n          } else if(outC[i] >= end[i]) {\n            outC[i] = (end[i] - 1) * 2 - outC[i] + ${c};\n          }\n        }\n        ${a} coords = outC - start;\n        setOutput(getX(${i}));\n      }\n    `:`\n        int start = ${s};\n        int end = ${o};\n\n        void main() {\n          int outC = getOutputCoords();\n          if (outC < start) {\n            outC = start * 2 - outC - ${c};\n          } else if(outC >= end) {\n            outC = (end - 1) * 2 - outC + ${c};\n          }\n          setOutput(getX(outC - start));\n        }\n      `}}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Om{constructor(e,t,n){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t.map((t,n)=>t[0]+e[n]+t[1]);const r=e.length,a=ts(r),s=t.map(e=>e[0]).join(","),o=t.map((t,n)=>t[0]+e[n]).join(","),i=uc("rc",r),c=uc("source",r),u=`${i[r-1]} < ${this.outputShape[r-1]}`,l=1===r?"source":`vec2(${c.slice(-2).join()})`,d="reflect"===n?0:1;let p="";if(1===r){const e=`\n        ${a} source = rc;\n        if (source < start) {\n          source = start * 2 - source - ${d};\n        } else if (source >= end) {\n          source = (end - 1) * 2 - source + ${d};\n        }\n        source -= start;\n      `;p=`\n        ${a} rc = outputLoc;\n        ${e}\n        result[0] = getChannel(getX(${c.join()}), ${l});\n        ${i[r-1]} += 1;\n        if(${u}) {\n          ${e}\n          result[1] = getChannel(getX(${c.join()}), ${l});\n        }\n      `}else{const e=`\n        ${a} source = rc;\n        ${a} lt = ${a}(lessThan(source, start));\n        ${a} gte = ${a}(greaterThanEqual(source, end));\n        ${a} orig = 1 - (lt + gte);\n        source = orig * source +\n                lt * (start * 2 - source - ${d}) +\n                gte * ((end - 1) * 2 - source + ${d});\n        source -= start;\n      `;p=`\n        ${a} rc = outputLoc;\n        ${e}\n        result[0] = getChannel(getX(${c.join()}), ${l});\n        ${i[r-1]} += 1;\n        if(${u}) {\n          ${e}\n          result[1] = getChannel(getX(${c.join()}), ${l});\n        }\n        rc = outputLoc;\n        ${i[r-2]} += 1;\n        if(${i[r-2]} < ${this.outputShape[r-2]}) {\n          ${e}\n          result[2] = getChannel(getX(${c.join()}), ${l});\n          ${i[r-1]} += 1;\n          if(${u}) {\n            ${e}\n            result[3] = getChannel(getX(${c.join()}), ${l});\n          }\n        }\n      `}this.userCode=`\n      const ${a} start = ${a}(${s});\n      const ${a} end = ${a}(${o});\n\n      void main() {\n        ${a} outputLoc = getOutputCoords();\n        vec4 result = vec4(0.);\n        ${p}\n        setOutput(result);\n      }\n    `}}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vm=({inputs:e,backend:t,attrs:n})=>{const{x:r}=e,{paddings:a,mode:s}=n,o=Object(c["env"])().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new Om(r.shape,a,s):new xm(r.shape,a,s),i=t.runWebGLProgram(o,[r],r.dtype);return i},wm={kernelName:c["MirrorPad"],backendName:"webgl",kernelFunc:vm},km="if (b == 0.0) return NAN;\n  return mod(a, b);",jm="\n  vec4 result = mod(a, b);\n  vec4 isNaN = vec4(equal(b, vec4(0.0)));\n  "+Jc+"\n  return result;\n",Sm=gu({opSnippet:km,packedOpSnippet:jm}),Nm={kernelName:c["Mod"],backendName:"webgl",kernelFunc:Sm};
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class Cm{constructor(e,t,n){this.variableNames=["probs"],this.customUniforms=[{name:"seed",type:"float"}],this.outputShape=[e,n],this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n\n        float r = random(seed);\n        float cdf = 0.0;\n\n        for (int i = 0; i < ${t-1}; i++) {\n          cdf += getProbs(batch, i);\n\n          if (r < cdf) {\n            setOutput(float(i));\n            return;\n          }\n        }\n\n        // If no other event happened, last event happened.\n        setOutput(float(${t-1}));\n      }\n    `}}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Im="\nif (a == b) {\n  return 1.0;\n};\nreturn a / b;",Tm="\n  // vec4 one = vec4(equal(a, b));\n  // return one + (vec4(1.0) - one) * a / b;\n  vec4 result = a / b;\n  if(a.x == b.x) {\n    result.x = 1.;\n  }\n  if(a.y == b.y) {\n    result.y = 1.;\n  }\n  if(a.z == b.z) {\n    result.z = 1.;\n  }\n  if(a.w == b.w) {\n    result.w = 1.;\n  }\n\n  return result;\n",$m=gu({opSnippet:Im,packedOpSnippet:Tm,checkOutOfBounds:!0}),Em={kernelName:c["RealDiv"],backendName:"webgl",kernelFunc:$m},Am="return a - b;",Rm=gu({opSnippet:Am,packedOpSnippet:Am,supportsComplex:!0,cpuKernelImpl:rc}),_m={kernelName:c["Sub"],backendName:"webgl",kernelFunc:Rm};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Fm(e){const{inputs:t,backend:n,attrs:r}=e,{logits:a}=t,{dim:s}=r,o=c["util"].parseAxisParam([s],a.shape),i=qf({inputs:{x:a},backend:n,attrs:{reductionIndices:o,keepDims:!1}}),u=c["backend_util"].expandShapeToKeepDim(i.shape,o),l=Nu({inputs:{x:i},backend:n,attrs:{shape:u}}),d=Rm({inputs:{a:a,b:l},backend:n}),p=oh({inputs:{x:d},backend:n}),h=Mu({inputs:{x:p},backend:n,attrs:{axis:o,keepDims:!1}}),f=Nu({inputs:{x:h},backend:n,attrs:{shape:u}}),m=$m({inputs:{a:p,b:f},backend:n});return n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(l),n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(f),m}const Dm={kernelName:c["Softmax"],backendName:"webgl",kernelFunc:Fm};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Mm(e){const{inputs:t,backend:n,attrs:r}=e,{logits:a}=t,{numSamples:s,seed:o,normalized:i}=r,c=i?a:Fm({inputs:{logits:a},backend:n,attrs:{dim:a.shape.length-1}}),u=c.shape[0],l=c.shape[1],d=new Cm(u,l,s),p=[[o]],h=n.runWebGLProgram(d,[c],"int32",p);return i||n.disposeIntermediateTensorInfo(c),h}const Lm={kernelName:c["Multinomial"],backendName:"webgl",kernelFunc:Mm},Pm="return -x;";
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Bm(e){const{inputs:t,backend:n}=e,{x:r}=t;if(n.shouldExecuteOnCPU([r])){const e=n.texData.get(r.dataId),[t,a]=Vi(e.values,r.shape,r.dtype);return n.makeTensorInfo(a,r.dtype,t)}let a;return a=Object(c["env"])().getBool("WEBGL_PACK_UNARY_OPERATIONS")?new Pc(r.shape,Pm):new Sc(r.shape,Pm),n.runWebGLProgram(a,[r],r.dtype)}const Vm={kernelName:c["Neg"],backendName:"webgl",kernelFunc:Bm},zm=c["kernel_impls"].nonMaxSuppressionV3Impl;
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Wm(e){c["backend_util"].warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:t,backend:n,attrs:r}=e,{boxes:a,scores:s}=t,{maxOutputSize:o,iouThreshold:i,scoreThreshold:u}=r,l=n.readSync(a.dataId),d=n.readSync(s.dataId),{selectedIndices:p}=zm(l,d,o,i,u);return n.makeTensorInfo([p.length],"int32",new Int32Array(p))}const Um={kernelName:c["NonMaxSuppressionV3"],backendName:"webgl",kernelFunc:Wm},Gm=c["kernel_impls"].nonMaxSuppressionV4Impl;
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Hm(e){c["backend_util"].warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:t,backend:n,attrs:r}=e,{boxes:a,scores:s}=t,{maxOutputSize:o,iouThreshold:i,scoreThreshold:u,padToMaxOutputSize:l}=r,d=n.readSync(a.dataId),p=n.readSync(s.dataId),{selectedIndices:h,validOutputs:f}=Gm(d,p,o,i,u,l);return[n.makeTensorInfo([h.length],"int32",new Int32Array(h)),n.makeTensorInfo([],"int32",new Int32Array([f]))]}const qm={kernelName:c["NonMaxSuppressionV4"],backendName:"webgl",kernelFunc:Hm},Km=c["kernel_impls"].nonMaxSuppressionV5Impl;
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Xm(e){c["backend_util"].warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:t,backend:n,attrs:r}=e,{boxes:a,scores:s}=t,{maxOutputSize:o,iouThreshold:i,scoreThreshold:u,softNmsSigma:l}=r,d=n.readSync(a.dataId),p=n.readSync(s.dataId),h=o,f=i,m=u,b=l,{selectedIndices:g,selectedScores:y}=Km(d,p,h,f,m,b);return[n.makeTensorInfo([g.length],"int32",new Int32Array(g)),n.makeTensorInfo([y.length],"float32",new Float32Array(y))]}const Ym={kernelName:c["NonMaxSuppressionV5"],backendName:"webgl",kernelFunc:Xm};
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Qm{constructor(e,t,n,r){this.variableNames=["indices"],this.outputShape=[e,t],this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int index = round(getIndices(coords.x));\n        setOutput(mix(float(${r}), float(${n}),\n                      float(index == coords.y)));\n      }\n    `}}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Zm=e=>{const{inputs:t,backend:n,attrs:r}=e,{indices:a}=t,{depth:s,onValue:o,offValue:i}=r,u=c["util"].sizeFromShape(a.shape),l=new Qm(u,s,o,i),d=Nu({inputs:{x:a},backend:n,attrs:{shape:[u]}}),p=n.runWebGLProgram(l,[d],a.dtype);n.disposeIntermediateTensorInfo(d);const h=[...a.shape,s],f=Nu({inputs:{x:p},backend:n,attrs:{shape:h}});return n.disposeIntermediateTensorInfo(p),f},Jm={kernelName:c["OneHot"],backendName:"webgl",kernelFunc:Zm};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function eb(e){const{inputs:t,backend:n}=e,{x:r}=t;if("complex64"===r.dtype){const e=fd({inputs:{input:r},backend:n}),t=eb({inputs:{x:e},backend:n}),a=_d({inputs:{input:r},backend:n}),s=eb({inputs:{x:a},backend:n}),o=ru({inputs:{real:t,imag:s},backend:n});return n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(t),n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(s),o}return yh({attrs:{shape:r.shape,dtype:r.dtype,value:"string"===r.dtype?"":0},backend:n})}const tb={kernelName:c["ZerosLike"],backendName:"webgl",kernelFunc:eb};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nb(e){const{inputs:t,backend:n}=e,{x:r}=t;if("string"===r.dtype)throw new Error("onesLike is not supported under string dtype");if("complex64"===r.dtype){const e=fd({inputs:{input:r},backend:n}),t=nb({inputs:{x:e},backend:n}),a=_d({inputs:{input:r},backend:n}),s=eb({inputs:{x:a},backend:n}),o=ru({inputs:{real:t,imag:s},backend:n});return n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(t),n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(s),o}return yh({attrs:{shape:r.shape,dtype:r.dtype,value:1},backend:n})}const rb={kernelName:c["OnesLike"],backendName:"webgl",kernelFunc:nb};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ab(e){const{inputs:t,backend:n,attrs:r}=e,{axis:a}=r;if(1===t.length)return ch({inputs:{input:t[0]},backend:n,attrs:{dim:a}});const s=t[0].shape,o=t[0].dtype;t.forEach(e=>{c["util"].assertShapesMatch(s,e.shape,"All tensors passed to stack must have matching shapes"),c["util"].assert(o===e.dtype,()=>"All tensors passed to stack must have matching dtypes")});const i=[],u=t.map(e=>{const t=ch({inputs:{input:e},backend:n,attrs:{dim:a}});return i.push(t),t}),l=Ld({inputs:u,backend:n,attrs:{axis:a}});return i.forEach(e=>n.disposeIntermediateTensorInfo(e)),l}const sb={kernelName:c["Pack"],backendName:"webgl",kernelFunc:ab};
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ob{constructor(e,t,n){this.variableNames=["x"],this.customUniforms=[{name:"value",type:"float"}],this.outputShape=t.map((t,n)=>t[0]+e[n]+t[1]);const r=e.length,a=ts(r),s=t.map(e=>e[0]).join(","),o=t.map((t,n)=>t[0]+e[n]).join(","),i=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,r);this.userCode=1!==r?`\n      ${a} start = ${a}(${s});\n      ${a} end = ${a}(${o});\n\n      void main() {\n        ${a} outC = getOutputCoords();\n        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {\n          setOutput(value);\n        } else {\n          ${a} coords = outC - start;\n          setOutput(getX(${i}));\n        }\n      }\n    `:`\n        int start = ${s};\n        int end = ${o};\n\n        void main() {\n          int outC = getOutputCoords();\n          if (outC < start || outC >= end) {\n            setOutput(value);\n          } else {\n            setOutput(getX(outC - start));\n          }\n        }\n      `}}
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ib{constructor(e,t,n){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"value",type:"float"}],this.outputShape=t.map((t,n)=>t[0]+e[n]+t[1]);const r=e.length,a=ts(r),s=t.map(e=>e[0]).join(","),o=t.map((t,n)=>t[0]+e[n]).join(","),i=uc("rc",r),c=uc("source",r),u=`${i[r-1]} < ${this.outputShape[r-1]}`,l=1===r?"source":`vec2(${c.slice(-2).join()})`,d=[a+" rc = outputLoc;",`${i[r-1]} += 1;\n       if(${u}) {\n      `,1===r?"":`}\n       rc = outputLoc;\n       ${i[r-2]} += 1;\n       if(${i[r-2]} < ${this.outputShape[r-2]}) {`,1===r?"":`  ${i[r-1]} += 1;\n         if(${u}) {`],p=1===r?"rc < start || rc >= end":"any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))";let h="";for(let f=0,m=1===r?2:4;f<m;f++)h+=`\n        ${d[f]}\n        if (${p}) {\n          result[${f}] = float(value);\n        } else {\n          ${a} source = rc - start;\n          result[${f}] = getChannel(getX(${c.join()}), ${l});\n        }\n      `;h+=1===r?"} ":"}}",this.userCode=`\n      const ${a} start = ${a}(${s});\n      const ${a} end = ${a}(${o});\n\n      void main() {\n        ${a} outputLoc = getOutputCoords();\n        vec4 result = vec4(0.);\n        ${h}\n        setOutput(result);\n      }\n    `}}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const cb=e=>{const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{paddings:s,constantValue:o}=r;if(0===c["util"].sizeFromShape(a.shape)){const e=s.map((e,t)=>e[0]+a.shape[t]+e[1]);return yh({backend:n,attrs:{shape:e,value:o,dtype:a.dtype}})}const i=Object(c["env"])().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new ib(a.shape,s,o):new ob(a.shape,s,o),u=[[o]];return n.runWebGLProgram(i,[a],a.dtype,u)},ub={kernelName:c["PadV2"],backendName:"webgl",kernelFunc:cb},lb="\n  if(a < 0.0 && floor(b) < b){\n    return NAN;\n  }\n  if (b == 0.0) {\n    return 1.0;\n  }\n  return (round(mod(b, 2.0)) != 1) ?\n      pow(abs(a), b) : sign(a) * pow(abs(a), b);\n",db="\n  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.\n  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));\n  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);\n  vec4 result = multiplier * pow(abs(a), b);\n\n  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS\n  bvec4 isExpZero = equal(b, vec4(0.0));\n  result.r = isExpZero.r ? 1.0 : result.r;\n  result.g = isExpZero.g ? 1.0 : result.g;\n  result.b = isExpZero.b ? 1.0 : result.b;\n  result.a = isExpZero.a ? 1.0 : result.a;\n\n  vec4 isNaN = vec4(lessThan(a, vec4(0.0))) * vec4(lessThan(floor(b), b));\n  "+Jc+"\n  return result;\n",pb=gu({opSnippet:lb,packedOpSnippet:db}),hb={kernelName:c["Pow"],backendName:"webgl",kernelFunc:pb};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function fb(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,keepDims:o}=r,i=a.shape.length,u=[],l=c["util"].parseAxisParam(s,a.shape);let d=l;const p=c["backend_util"].getAxesPermutation(d,i);let h,f=a;if(null!=p&&(f=Pu({inputs:{x:a},backend:n,attrs:{perm:p}}),d=c["backend_util"].getInnerMostAxes(d.length,i),u.push(f)),c["backend_util"].assertAxesAreInnerMostDims("prod",d,i),n.shouldExecuteOnCPU([f])){const e=n.texData.get(f.dataId).values,{outVals:t,outShape:r,outDtype:a}=Wi(f.shape,f.dtype,e,d);h=n.makeTensorInfo(r,a,t)}else{const[e,t]=c["backend_util"].computeOutAndReduceShapes(f.shape,d),r=c["util"].sizeFromShape(t),s=Nu({inputs:{x:f},backend:n,attrs:{shape:[-1,r]}}),o=Object(c["sumOutType"])(a.dtype),i=Eu(s,o,"prod",n);h=Nu({inputs:{x:i},backend:n,attrs:{shape:e}}),u.push(s),u.push(i)}if(o){u.push(h);const e=c["backend_util"].expandShapeToKeepDim(h.shape,l);h=Nu({inputs:{x:h},backend:n,attrs:{shape:e}})}return u.forEach(e=>n.disposeIntermediateTensorInfo(e)),h}const mb={kernelName:c["Prod"],backendName:"webgl",kernelFunc:fb},bb=e=>{const{backend:t,attrs:n}=e,{start:r,stop:a,step:s,dtype:o}=n,i=Ui(r,a,s,o);return t.makeTensorInfo([i.length],o,i)},gb={kernelName:c["Range"],backendName:"webgl",kernelFunc:bb},yb="return 1.0 / x;",xb=bu({opSnippet:yb}),Ob={kernelName:c["Reciprocal"],backendName:"webgl",kernelFunc:xb},vb=Nc+"\n  return (x < 0.0) ? 0.0 : x;\n",wb="\n  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",kb=bu({opSnippet:vb,packedOpSnippet:wb}),jb={kernelName:c["Relu"],backendName:"webgl",kernelFunc:kb},Sb=Nc+"\n  return (x < 0.0) ? 0.0 : min(6.0, x);\n",Nb="\n  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",Cb=bu({opSnippet:Sb,packedOpSnippet:Nb}),Ib={kernelName:c["Relu6"],backendName:"webgl",kernelFunc:Cb};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class Tb{constructor(e,t,n,r,a){this.variableNames=["A"],this.outputShape=[];const[s,o,i,c]=e;this.outputShape=[s,t,n,c];const u=[r&&t>1?o-1:o,r&&n>1?i-1:i],l=[r&&t>1?t-1:t,r&&n>1?n-1:n];let d;d=a?"(vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC - vec2(0.5)":"vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          ${u[0]/l[0]},\n          ${u[1]/l[1]});\n      const vec2 inputShapeRC = vec2(${o}.0, ${i}.0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = ${d};\n\n        // Compute the four integer indices.\n        ivec2 sourceFloorRC = ivec2(max(sourceFracIndexRC, vec2(0.0)));\n        ivec2 sourceCeilRC = ivec2(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);\n        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);\n        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);\n        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);\n\n        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);\n\n        float top = topLeft + (topRight - topLeft) * fracRC.y;\n        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;\n        float newValue = top + (bottom - top) * fracRC.x;\n\n        setOutput(newValue);\n      }\n    `}}
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class $b{constructor(e,t,n,r,a){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[s,o,i,c]=e;this.outputShape=[s,t,n,c];const u=[r&&t>1?o-1:o,r&&n>1?i-1:i],l=[r&&t>1?t-1:t,r&&n>1?n-1:n];let d;d=a?"(vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC - vec3(0.5)":"vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec3 effectiveInputOverOutputRatioRC = vec3(\n          ${u[0]/l[0]},\n          ${u[1]/l[1]},\n          ${u[1]/l[1]});\n      const vec3 inputShapeRC = vec3(${o}.0, ${i}.0,\n                                     ${i}.0);\n\n      float getAValue(int b, int r, int c, int d) {\n        return getChannel(getA(b, r, c, d), vec2(c, d));\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        // Calculate values for next column in yRC.z.\n        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);\n\n        // Fractional source index.\n        vec3 sourceFracIndexRC = ${d};\n\n        // Compute the four integer indices.\n        ivec3 sourceFloorRC = ivec3(max(sourceFracIndexRC, vec3(0.0)));\n        ivec3 sourceCeilRC = ivec3(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        // Should we calculate next column and row elements in 2x2 packed cell.\n        bool hasNextCol = d < ${c-1};\n        bool hasNextRow = coords.z < ${n-1};\n\n        // In parallel, construct four corners for all four components in\n        // packed 2x2 cell.\n        vec4 topLeft = vec4(\n          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 bottomLeft = vec4(\n          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 topRight = vec4(\n          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec4 bottomRight = vec4(\n          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);\n\n        vec4 top = mix(topLeft, topRight, fracRC.yyzz);\n        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);\n        vec4 newValue = mix(top, bottom, fracRC.x);\n\n        setOutput(newValue);\n      }\n    `}}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Eb(e){const{inputs:t,backend:n,attrs:r}=e,{images:a}=t,{alignCorners:s,halfPixelCenters:o,size:i}=r,[u,l]=i,d=Object(c["env"])().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new $b(a.shape,u,l,s,o):new Tb(a.shape,u,l,s,o);return n.runWebGLProgram(d,[a],"float32")}const Ab={kernelName:c["ResizeBilinear"],backendName:"webgl",kernelFunc:Eb};
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Rb{constructor(e,t,n){this.variableNames=["dy"],this.outputShape=[],this.outputShape=t;const[,r,a]=t,[,s,o]=e,i=[n&&s>1?r-1:r,n&&o>1?a-1:a],c=[n&&s>1?s-1:s,n&&o>1?o-1:o],u=i[0]/c[0],l=i[1]/c[1],d=1/u,p=1/l,h=2*Math.ceil(d)+2,f=2*Math.ceil(p)+2;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float(${u});\n        const float widthScale = float(${l});\n\n        const float invHeightScale = float(${d});\n        const float invWidthScale = float(${p});\n\n        const int winHeight = int(${h});\n        const int winWidth = int(${f});\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(startRLerp - float(winHeight / 2));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(startCLerp - float(winWidth / 2));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= ${s}) {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= ${o}) {\n              continue;\n            }\n\n            float dxR = float(dyR) * heightScale;\n            int topDxRIndex = int(floor(dxR));\n            int bottomDxRIndex = int(min(ceil(dxR), ${r-1}.0));\n            float dxRLerp = dxR - float(topDxRIndex);\n            float inverseDxRLerp = 1.0 - dxRLerp;\n\n            float dxC = float(dyC) * widthScale;\n            int leftDxCIndex = int(floor(dxC));\n            int rightDxCIndex = int(min(ceil(dxC), ${a-1}.0));\n            float dxCLerp = dxC - float(leftDxCIndex);\n            float inverseDxCLerp = 1.0 - dxCLerp;\n\n            if (r == topDxRIndex && c == leftDxCIndex) {\n              // topLeft\n              accumulator +=\n                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;\n            }\n\n            if (r == topDxRIndex && c == rightDxCIndex) {\n              // topRight\n              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == leftDxCIndex) {\n              // bottomLeft\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == rightDxCIndex) {\n              // bottomRight\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    `}}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _b(e){const{inputs:t,backend:n,attrs:r}=e,{images:a,dy:s}=t,{alignCorners:o}=r,i=new Rb(s.shape,a.shape,o);return n.runWebGLProgram(i,[s],s.dtype)}const Fb={kernelName:c["ResizeBilinearGrad"],backendName:"webgl",kernelFunc:_b};
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Db{constructor(e,t,n,r,a){this.variableNames=["A"],this.outputShape=[];const[s,o,i,c]=e;this.outputShape=[s,t,n,c];const u=[r&&t>1?o-1:o,r&&n>1?i-1:i],l=[r&&t>1?t-1:t,r&&n>1?n-1:n],d=r?"0.5":"0.0";let p;p=a?"max((vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC, vec2(0.0))":"vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          ${u[0]/l[0]},\n          ${u[1]/l[1]});\n      const vec2 inputShapeRC = vec2(${o}.0, ${i}.0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = ${p};\n\n        // Compute the coordinators of nearest neighbor point.\n        ivec2 sourceNearestRC = ivec2(\n          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${d})));\n        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);\n\n        setOutput(newValue);\n      }\n    `}}
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Mb{constructor(e,t,n,r,a){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[s,o,i,c]=e;this.outputShape=[s,t,n,c];const u=[r&&t>1?o-1:o,r&&n>1?i-1:i],l=[r&&t>1?t-1:t,r&&n>1?n-1:n],d=r?"0.5":"0.0";let p;p=a?"max((vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC, vec3(0.0))":"vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec3 effectiveInputOverOutputRatioRC = vec3(\n          ${u[0]/l[0]},\n          ${u[1]/l[1]},\n          ${u[1]/l[1]});\n      const vec3 inputShapeRC = vec3(${o}.0, ${i}.0,\n                                     ${i}.0);\n\n      float getAValue(int b, int r, int c, int d) {\n        return getChannel(getA(b, r, c, d), vec2(c, d));\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        // Calculate values for next column in yRC.z.\n        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);\n\n        // Fractional source index.\n        vec3 sourceFracIndexRC = ${p};\n\n        // Compute the coordinators of nearest neighbor point.\n        ivec3 sourceNearestRC = ivec3(\n          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${d})));\n\n        // Should we calculate next column and row elements in 2x2 packed cell.\n        bool hasNextCol = d < ${c-1};\n        bool hasNextRow = coords.z < ${n-1};\n\n        vec4 newValue = vec4(\n          getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d),\n          hasNextCol ? getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d + 1) : 0.0);\n\n        setOutput(newValue);\n      }\n    `}}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Lb(e){const{inputs:t,backend:n,attrs:r}=e,{images:a}=t,{alignCorners:s,halfPixelCenters:o,size:i}=r,[u,l]=i,d=Object(c["env"])().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new Mb(a.shape,u,l,s,o):new Db(a.shape,u,l,s,o);return n.runWebGLProgram(d,[a],a.dtype)}const Pb={kernelName:c["ResizeNearestNeighbor"],backendName:"webgl",kernelFunc:Lb};
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Bb{constructor(e,t,n){this.variableNames=["dy"],this.outputShape=[],this.outputShape=t;const[,r,a]=t,[,s,o]=e,i=[n&&s>1?r-1:r,n&&o>1?a-1:a],c=[n&&s>1?s-1:s,n&&o>1?o-1:o],u=i[0]/c[0],l=i[1]/c[1],d=1/u,p=1/l,h=2*Math.ceil(d)+2,f=2*Math.ceil(p)+2;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float(${u});\n        const float widthScale = float(${l});\n\n        const float invHeightScale = float(${d});\n        const float invWidthScale = float(${p});\n\n        const int winHeight = int(${h});\n        const int winWidth = int(${f});\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(floor(startRLerp - float(winHeight / 2)));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(floor(startCLerp - float(winWidth / 2)));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= ${s}) {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= ${o}) {\n              continue;\n            }\n\n            float sourceFracRow =\n              float(${i[0]}) *\n                (float(dyR) / float(${c[0]}));\n\n            float sourceFracCol =\n                float(${i[1]}) *\n                  (float(dyC) / float(${c[1]}));\n\n            int sourceNearestRow = int(min(\n                float(int(${r}) - 1),\n                ${n} ? float(round(sourceFracRow)) :\n                                  float(floor(sourceFracRow))));\n\n            int sourceNearestCol = int(min(\n                float(int(${a}) - 1),\n                ${n} ? float(round(sourceFracCol)) :\n                                  float(floor(sourceFracCol))));\n\n            if (r == sourceNearestRow && c == sourceNearestCol) {\n              accumulator += getDy(b, dyR, dyC, d);\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    `}}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Vb(e){const{inputs:t,backend:n,attrs:r}=e,{images:a,dy:s}=t,{alignCorners:o}=r,i=new Bb(s.shape,a.shape,o);return n.runWebGLProgram(i,[s],s.dtype)}const zb={kernelName:c["ResizeNearestNeighborGrad"],backendName:"webgl",kernelFunc:Vb};
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Wb{constructor(e,t){this.variableNames=["x"];const n=e.length;if(n>4)throw new Error(`WebGL backend: Reverse of rank-${n} tensor is not yet supported`);if(this.outputShape=e,1===n)return void(this.userCode=`\n        void main() {\n          int coord = getOutputCoords();\n          setOutput(getX(${e[0]} - coord - 1));\n        }\n      `);const r=n=>-1!==t.indexOf(n)&&1!==e[n]?`${e[n]} - coords[${n}] - 1`:`coords[${n}]`,a=e.map((e,t)=>r(t)).join(","),s=ts(n);this.userCode=`\n      void main() {\n        ${s} coords = getOutputCoords();\n        setOutput(getX(${a}));\n      }\n    `}}
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Ub{constructor(e,t){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0;const n=e.length;if(n>4)throw new Error(`WebGL backend: Reverse of rank-${n} tensor is not yet supported`);this.outputShape=e;const r=uc("rc",n),a=`${r[n-1]} + 1 < ${this.outputShape[n-1]}`,s=`${r[n-2]} + 1 < ${this.outputShape[n-2]}`,o=ts(n);function i(e){return d(e)}function c(e){return e[n-1]="("+e[n-1]+" + 1)",d(e)}function u(e){return e[n-2]="("+e[n-2]+" + 1)",d(e)}function l(e){return e[n-1]="("+e[n-1]+" + 1)",e[n-2]="("+e[n-2]+" + 1)",d(e)}function d(t){const n=e.map((e,n)=>p(n,t)),r=n.join(","),a=n.slice(-2).join(",");return`getChannel(getX(${r}), vec2(${a}))`}function p(n,r){return-1!==t.indexOf(n)&&1!==e[n]?`${e[n]} - ${r[n]} - 1`:""+r[n]}this.userCode=1===n?`\n        void main(){\n          int rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = getChannel(getX(${e[0]} - rc - 1),\n            ${e[0]} - rc - 1);\n          if(${a}){\n              result.g = getChannel(getX(${e[0]} - (rc  + 1) - 1),\n                ${e[0]} - (rc  + 1) - 1);\n          }\n          setOutput(result);\n        }\n      `:`\n        void main() {\n          ${o} rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = ${i(r.slice())};\n          if(${a}){\n            result.g = ${c(r.slice())};\n          }\n          if(${s}) {\n            result.b = ${u(r.slice())};\n            if(${a}) {\n              result.a = ${l(r.slice())};\n            }\n          }\n          setOutput(result);\n        }\n    `}}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Gb(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{dims:s}=r,o=a.shape.length,i=c["util"].parseAxisParam(s,a.shape);if(0===o)return tu({inputs:{x:a},backend:n});const u=Object(c["env"])().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new Ub(a.shape,i):new Wb(a.shape,i);return n.runWebGLProgram(u,[a],a.dtype)}const Hb={kernelName:c["Reverse"],backendName:"webgl",kernelFunc:Gb};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class qb{constructor(e,t){this.variableNames=["Image"],this.outputShape=[],this.customUniforms=[{name:"params",type:"vec4"}];const n=e[1],r=e[2];this.outputShape=e;let a="";a="number"===typeof t?`float outputValue = ${t.toFixed(2)};`:`\n        vec3 fill = vec3(${t.join(",")});\n        float outputValue = fill[coords[3]];`,this.userCode=`\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int x = coords[2];\n          int y = coords[1];\n          float coordXFloat = (float(x) - params[0]) * params[3] -\n            (float(y) - params[1]) * params[2];\n          float coordYFloat = (float(x) - params[0]) * params[2] +\n            (float(y) - params[1]) * params[3];\n          int coordX = int(round(coordXFloat + params[0]));\n          int coordY = int(round(coordYFloat + params[1]));\n          ${a}\n          if(coordX >= 0 && coordX < ${r} && coordY >= 0 && coordY < ${n}) {\n            outputValue = getImage(coords[0], coordY, coordX, coords[3]);\n          }\n          setOutput(outputValue);\n        }\n    `}}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Kb={kernelName:c["RotateWithOffset"],backendName:"webgl",kernelFunc:({inputs:e,attrs:t,backend:n})=>{const{image:r}=e,{radians:a,fillValue:s,center:o}=t,i=n,u=new qb(r.shape,s),[l,d]=c["backend_util"].getImageCenter(o,r.shape[1],r.shape[2]),p=[[l,d,Math.sin(a),Math.cos(a)]],h=i.runWebGLProgram(u,[r],r.dtype,p);return h}},Xb="\n  // OpenGL ES does not support round function.\n  // The algorithm is based on banker's rounding.\n  float base = floor(x);\n  if ((x - base) < 0.5) {\n    return floor(x);\n  } else if ((x - base) > 0.5) {\n    return ceil(x);\n  } else {\n    if (mod(base, 2.0) == 0.0) {\n      return base;\n    } else {\n      return base + 1.0;\n    }\n  }\n",Yb=bu({opSnippet:Xb}),Qb={kernelName:c["Round"],backendName:"webgl",kernelFunc:Yb},Zb="return inversesqrt(x);",Jb=bu({opSnippet:Zb,cpuKernelImpl:Gi}),eg={kernelName:c["Rsqrt"],backendName:"webgl",kernelFunc:Jb};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class tg{constructor(e,t,n,r,a,s,o=!0){this.variableNames=["updates","indices","defaultValue"],this.outputShape=s;const i=ts(a.length),c=ts(s.length);let u="";1===n?u="i":2===n&&(u="i, j");const l=`getIndices(${u})`;let d="";1===r?d="i":2===r&&(d="i, coords[1]");const p=`getUpdates(${d})`,h=t>1?"strides[j]":"strides";this.userCode=`\n        ${i} strides = ${i}(${a});\n\n        void main() {\n          ${c} coords = getOutputCoords();\n          float sum = 0.0;\n          bool found = false;\n          for (int i = 0; i < ${e}; i++) {\n            int flattenedIndex = 0;\n            for (int j = 0; j < ${t}; j++) {\n              int index = round(${l});\n              flattenedIndex += index * ${h};\n            }\n            if (flattenedIndex == coords[0]) {\n              sum += ${p};\n              found = true;\n            }\n          }\n          setOutput(mix(getDefaultValue(), sum, float(found)));\n        }\n      `}}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ng(e){const{inputs:t,backend:n,attrs:r}=e,{indices:a,updates:s}=t,{shape:o}=r,{sliceRank:i,numUpdates:u,sliceSize:l,strides:d,outputSize:p}=c["backend_util"].calculateShapes(s,a,o),h=[p/l,l];if(0===p)return n.makeTensorInfo(o,a.dtype);const f=Nu({inputs:{x:a},backend:n,attrs:{shape:[u,i]}}),m=Nu({inputs:{x:s},backend:n,attrs:{shape:[u,l]}}),b=n.makeTensorInfo([],"float32",new Float32Array([0])),g=new tg(u,i,f.shape.length,m.shape.length,d,h),y=n.runWebGLProgram(g,[m,f,b],m.dtype),x=Nu({inputs:{x:y},backend:n,attrs:{shape:o}});return n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(y),n.disposeIntermediateTensorInfo(b),x}const rg={kernelName:c["ScatterNd"],backendName:"webgl",kernelFunc:ng};
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ag{constructor(e,t,n){let r,a;if(this.variableNames=["c","a","b"],this.outputShape=t,n>4)throw Error(`Where for rank ${n} is not yet supported`);if(1===n)a="resRC",r="resRC";else{const n=["resRC.x","resRC.y","resRC.z","resRC.w"],s=[],o=[];for(let r=0;r<t.length;r++)o.push(""+n[r]),r<e&&s.push(""+n[r]);r=s.join(),a=o.join()}const s=ts(n);this.userCode=`\n      void main() {\n        ${s} resRC = getOutputCoords();\n        float cVal = getC(${r});\n        if (cVal >= 1.0) {\n          setOutput(getA(${a}));\n        } else {\n          setOutput(getB(${a}));\n        }\n      }\n    `}}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sg(e){const{inputs:t,backend:n}=e,{condition:r,t:a,e:s}=t,o=new ag(r.shape.length,a.shape,a.shape.length);return n.runWebGLProgram(o,[r,a,s],Object(c["upcastType"])(a.dtype,s.dtype))}const og={kernelName:c["Select"],backendName:"webgl",kernelFunc:sg},ig=`\n  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.\n  // see: https://arxiv.org/abs/1706.02515\n  float scaleAlpha = ${c["backend_util"].SELU_SCALEALPHA};\n  float scale = ${c["backend_util"].SELU_SCALE};\n  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);\n`,cg=bu({opSnippet:ig}),ug={kernelName:c["Selu"],backendName:"webgl",kernelFunc:cg},lg="return 1.0 / (1.0 + exp(-1.0 * x));",dg=bu({opSnippet:lg,packedOpSnippet:lg,cpuKernelImpl:Hi}),pg={kernelName:c["Sigmoid"],backendName:"webgl",kernelFunc:dg},hg="\n  if (isnan(x)) { return 0.0; }\n  return sign(x);\n",fg=bu({opSnippet:hg}),mg={kernelName:c["Sign"],backendName:"webgl",kernelFunc:fg},bg=hu+"\n  return sin(x);\n",gg=bu({opSnippet:bg}),yg={kernelName:c["Sin"],backendName:"webgl",kernelFunc:gg},xg="\n  float e2x = exp(x);\n  return (e2x - 1.0 / e2x) / 2.0;\n",Og=bu({opSnippet:xg}),vg={kernelName:c["Sinh"],backendName:"webgl",kernelFunc:Og},wg="\n  float epsilon = 1.1920928955078125e-7;\n  float threshold = log(epsilon) + 2.0;\n\n  bool too_large = x > -threshold;\n  bool too_small = x < threshold;\n\n  float result;\n  float exp_x = exp(x);\n\n  if (too_large){\n    result = x;\n  }\n  else if (too_small){\n    result = exp_x;\n  }\n  else{\n    result = log(exp_x + 1.0);\n  }\n  return result;\n",kg=bu({opSnippet:wg}),jg={kernelName:c["Softplus"],backendName:"webgl",kernelFunc:kg},Sg=e=>{const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{blockShape:s,paddings:o}=r;c["util"].assert(a.shape.length<=4,()=>"spaceToBatchND for rank > 4 with a WebGL backend not implemented yet");const i=s.reduce((e,t)=>e*t),u=[[0,0]];u.push(...o);for(let c=1+s.length;c<a.shape.length;++c)u.push([0,0]);const l=[],d=cb({inputs:{x:a},backend:n,attrs:{paddings:u,constantValue:0}}),p=c["backend_util"].getReshaped(d.shape,s,i,!1),h=c["backend_util"].getPermuted(p.length,s.length,!1),f=c["backend_util"].getReshapedPermuted(d.shape,s,i,!1),m=Nu({inputs:{x:d},backend:n,attrs:{shape:p}}),b=Pu({inputs:{x:m},backend:n,attrs:{perm:h}}),g=Nu({inputs:{x:b},backend:n,attrs:{shape:f}});return l.push(d),l.push(m),l.push(b),l.forEach(e=>n.disposeIntermediateTensorInfo(e)),g},Ng={kernelName:c["SpaceToBatchND"],backendName:"webgl",kernelFunc:Sg};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Cg(e){const{inputs:t,backend:n}=e,{indices:r,values:a,denseShape:s,defaultValue:o}=t;if(1!==s.shape.length)throw new Error("Dense shape must be a vector, saw:\n         "+s.shape);if(2!==r.shape.length)throw new Error("Indices must be a matrix, saw:\n         "+r.shape);if(1!==a.shape.length)throw new Error("Values must be a vector, saw:\n         "+a.shape);if(0!==o.shape.length)throw new Error("Default value must be a scalar, saw:\n        "+o.shape);const i=n.readSync(r.dataId),c=n.readSync(a.dataId),u=n.readSync(s.dataId),l=n.readSync(o.dataId)[0],[d,p,h,f,m]=Xi(i,r.shape,r.dtype,c,a.dtype,u,l);return[n.makeTensorInfo(p,r.dtype,d),n.makeTensorInfo([p[0]],a.dtype,h),n.makeTensorInfo([f.length],"bool",new Uint8Array(f.map(e=>Number(e)))),n.makeTensorInfo([m.length],r.dtype,new Int32Array(m))]}const Ig={kernelName:c["SparseFillEmptyRows"],backendName:"webgl",kernelFunc:Cg};
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Tg(e){const{inputs:t,backend:n}=e,{inputIndices:r,inputShape:a,newShape:s}=t;if(2!==r.shape.length)throw new Error("Input indices should be a matrix but received shape "+r.shape);if(1!==a.shape.length)throw new Error("Input shape should be a vector but received shape "+a.shape);if(1!==s.shape.length)throw new Error("Target shape should be a vector but received shape "+s.shape);const o=Array.from(n.readSync(a.dataId)),i=n.readSync(r.dataId),c=Array.from(n.readSync(s.dataId)),[u,l,d]=Yi(i,r.shape,r.dtype,o,c);return[n.makeTensorInfo(l,r.dtype,u),n.makeTensorInfo([d.length],s.dtype,new Int32Array(d))]}const $g={kernelName:c["SparseReshape"],backendName:"webgl",kernelFunc:Tg};
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Eg(e){const{inputs:t,backend:n}=e,{data:r,indices:a,segmentIds:s}=t;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==a.shape.length)throw new Error("Indices should be a vector but received shape\n              "+a.shape);if(1!==s.shape.length)throw new Error("Segment ids should be a vector but received shape\n              "+s.shape);const o=n.readSync(r.dataId),i=n.readSync(a.dataId),c=n.readSync(s.dataId),[u,l]=Qi(o,r.shape,r.dtype,i,c,!0);return n.makeTensorInfo(l,r.dtype,u)}const Ag={kernelName:c["SparseSegmentMean"],backendName:"webgl",kernelFunc:Eg};
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Rg(e){const{inputs:t,backend:n}=e,{data:r,indices:a,segmentIds:s}=t;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==a.shape.length)throw new Error("Indices should be a vector but received shape\n             "+a.shape);if(1!==s.shape.length)throw new Error("Segment ids should be a vector but received shape\n             "+s.shape);const o=n.readSync(r.dataId),i=n.readSync(a.dataId),c=n.readSync(s.dataId),[u,l]=Qi(o,r.shape,r.dtype,i,c);return n.makeTensorInfo(l,r.dtype,u)}const _g={kernelName:c["SparseSegmentSum"],backendName:"webgl",kernelFunc:Rg};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Fg(e){const{inputs:t,backend:n,attrs:r}=e,{sparseIndices:a,sparseValues:s,defaultValue:o}=t,{outputShape:i}=r,{sliceRank:u,numUpdates:l,strides:d,outputSize:p}=c["backend_util"].calculateShapes(s,a,i),h=!1,f=new tg(l,u,a.shape.length,s.shape.length,d,[p,1],h),m=n.runWebGLProgram(f,[s,a,o],s.dtype),b=Nu({inputs:{x:m},backend:n,attrs:{shape:i}});return n.disposeIntermediateTensorInfo(m),b}const Dg={kernelName:c["SparseToDense"],backendName:"webgl",kernelFunc:Fg};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Mg(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{numOrSizeSplits:s,axis:o}=r,i=c["util"].parseAxisParam(o,a.shape)[0],u=c["backend_util"].prepareSplitSize(a,s,i),l=a.shape.length,d=new Array(l).fill(0),p=a.shape.slice();return u.map(e=>{const t=[...p];t[i]=e;const r=sd({inputs:{x:a},backend:n,attrs:{begin:d,size:t}});return d[i]+=e,r})}const Lg={kernelName:c["SplitV"],backendName:"webgl",kernelFunc:Mg},Pg="return sqrt(x);",Bg=bu({opSnippet:Pg,packedOpSnippet:Pg,cpuKernelImpl:Zi}),Vg={kernelName:c["Sqrt"],backendName:"webgl",kernelFunc:Bg},zg="return x * x;",Wg=bu({opSnippet:zg}),Ug={kernelName:c["Square"],backendName:"webgl",kernelFunc:Wg},Gg="return (a - b) * (a - b);",Hg=gu({opSnippet:Gg,packedOpSnippet:Gg}),qg={kernelName:c["SquaredDifference"],backendName:"webgl",kernelFunc:Hg};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Kg({inputs:e,attrs:t,backend:n}){const{x:r}=e,a=Nc+`\n    return x > 0.0 ? 1.0 : float(${t.alpha});\n  `,s=new Sc(r.shape,a);return n.runWebGLProgram(s,[r],r.dtype)}const Xg={kernelName:c["Step"],backendName:"webgl",kernelFunc:Kg};
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Yg{constructor(e,t,n){this.variableNames=["x"],this.outputShape=n;const r=n.length,a=ts(n.length),s=ts(n.length);let o="";if(1===r)o="coords * strides + begin";else{let e=0;o=n.map((t,r)=>(e++,1===n.length?`coords * strides[${r}] + begin[${r}]`:`coords[${e-1}] * strides[${r}] + begin[${r}]`)).join(",")}this.userCode=`\n      ${a} begin = ${a}(${e});\n      ${a} strides = ${a}(${t});\n\n      void main() {\n        ${s} coords = getOutputCoords();\n        setOutput(getX(${o}));\n      }\n    `}}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Qg(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{begin:s,end:o,strides:i,beginMask:u,endMask:l,ellipsisMask:d,newAxisMask:p,shrinkAxisMask:h}=r,{nonStrided:f,$begin:m,$strides:b,size:g,newShape:y,outShape:x}=c["slice_util"].sliceInfo(a.shape,s,o,i,u,l,d,p,h),O=Nu({inputs:{x:a},backend:n,attrs:{shape:y}});let v;if(f){const e=sd({inputs:{x:O},backend:n,attrs:{begin:m,size:g}});v=Nu({inputs:{x:e},backend:n,attrs:{shape:x}}),n.disposeIntermediateTensorInfo(e)}else if(x.some(e=>0===e))v=n.makeTensorInfo(x,a.dtype,[]);else{const e=n.shouldExecuteOnCPU([O]);if(e){const e=n.texData.get(O.dataId),t=e.values,r=Object(c["buffer"])(O.shape,O.dtype,t),a=Ji(x,r,b,m);v=n.makeTensorInfo(x,O.dtype,a.values)}else{const e=new Yg(m,b,x);v=n.runWebGLProgram(e,[O],O.dtype)}}const w=Nu({inputs:{x:v},backend:n,attrs:{shape:x}});return n.disposeIntermediateTensorInfo(O),n.disposeIntermediateTensorInfo(v),w}const Zg={kernelName:c["StridedSlice"],backendName:"webgl",kernelFunc:Qg};
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Jg(e){const{inputs:t,backend:n,attrs:r}=e,{separator:a,nGramWidths:s,leftPad:o,rightPad:i,padWidth:c,preserveShortSequences:u}=r,{data:l,dataSplits:d}=t,p=n.readSync(l.dataId),h=n.readSync(d.dataId),[f,m]=ec(p,h,a,s,o,i,c,u);return[n.makeTensorInfo([f.length],"string",f),n.makeTensorInfo(d.shape,"int32",m)]}const ey={kernelName:c["StringNGrams"],backendName:"webgl",kernelFunc:Jg};
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ty(e){const{inputs:t,backend:n,attrs:r}=e,{skipEmpty:a}=r,{input:s,delimiter:o}=t;if("string"!==s.dtype)throw new Error("Input must be of datatype string");if(1!==s.shape.length)throw new Error("Input must be a vector, got shape: "+s.shape);if(0!==o.shape.length)throw new Error("Delimiter must be a scalar, got shape: "+o.shape);const i=n.readSync(s.dataId),c=n.readSync(o.dataId)[0],[u,l,d]=tc(i,c,a),p=l.length;return[n.makeTensorInfo([p,2],"int32",u),n.makeTensorInfo([p],"string",l),n.makeTensorInfo([2],"int32",new Int32Array(d))]}const ny={kernelName:c["StringSplit"],backendName:"webgl",kernelFunc:ty};
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ry(e){const{inputs:t,backend:n,attrs:r}=e,{numBuckets:a}=r,{input:s}=t;if("string"!==s.dtype)throw new Error("Input must be of datatype string");if(a<=0)throw new Error("Number of buckets must be at least 1");const o=n.readSync(s.dataId),i=nc(o,a);return n.makeTensorInfo(s.shape,"int32",i)}const ay={kernelName:c["StringToHashBucketFast"],backendName:"webgl",kernelFunc:ry},sy="return tan(x);",oy=bu({opSnippet:sy}),iy={kernelName:c["Tan"],backendName:"webgl",kernelFunc:oy},cy="\n  float e2x = exp(-2.0 * abs(x));\n  return sign(x) * (1.0 - e2x) / (1.0 + e2x);\n",uy=bu({opSnippet:cy}),ly={kernelName:c["Tanh"],backendName:"webgl",kernelFunc:uy};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class dy{constructor(e,t){this.variableNames=["A"];const n=new Array(e.length);for(let s=0;s<n.length;s++)n[s]=e[s]*t[s];this.outputShape=n,this.rank=n.length;const r=ts(this.rank),a=py(e);this.userCode=`\n      void main() {\n        ${r} resRC = getOutputCoords();\n        setOutput(getA(${a}));\n      }\n    `}}function py(e){const t=e.length;if(t>5)throw Error(`Tile for rank ${t} is not yet supported`);if(1===t)return`imod(resRC, ${e[0]})`;const n=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u"],r=[];for(let a=0;a<e.length;a++)r.push(`imod(${n[a]}, ${e[a]})`);return r.join()}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hy(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{reps:s}=r;if("string"===a.dtype||a.shape.length>5){const e=n.readSync(a.dataId),t="string"===a.dtype?e.map(e=>c["util"].decodeString(e)):e,r=Object(c["buffer"])(a.shape,a.dtype,t),o=ac(r,s);return n.makeTensorInfo(o.shape,o.dtype,o.values)}const o=new dy(a.shape,s),i=n.runWebGLProgram(o,[a],a.dtype);return i}const fy={kernelName:c["Tile"],backendName:"webgl",kernelFunc:hy};class my{constructor(e){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"negativeInf",type:"float"},{name:"dir",type:"int"},{name:"inc",type:"int"}],this.outputShape=e,this.userCode="\n       void main() {\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int elemIdx = coords[1];\n\n         // We compare elements pair-wise within a group of size 2 * inc.\n         // The comparing rule for each group alternates between ascending\n         // and descending. Within each group, we compare each pair at\n         // positions i and i+inc. To decide whether an element at position i\n         // is x0 or x1, we mod it by 2 * inc, if the result is smaller than\n         // inc, it is in the first half of the group, we denote it as x0,\n         // otherwise we denote it as x1.\n         // For example, as shown in the Bitonic top K paper referenced above,\n         // Figure5(a) shows that element[1] is in the\n         // second half of the group when group size is 2, but it is in the\n         // first half of the group when group size is 4.\n\n         bool isFirstInPair = imod(elemIdx, 2 * inc) < inc;\n         int i = isFirstInPair ? elemIdx : elemIdx - inc;\n\n         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));\n         int i1 = firstPass == 1 ? i + inc : int(getIndices(batch, i + inc));\n         float x0 = i0 < n ? getX(batch, i0) : negativeInf;\n         float x1 = i1 < n ? getX(batch, i1) : negativeInf;\n\n         // Denotes which direction indices are in (ascending or descending).\n         bool reverse = imod(elemIdx, 2 * dir) >= dir;\n         bool isGreater = x0 > x1 || (x0 == x1 && i1 > i0);\n         if (reverse == isGreater) { // Elements in opposite order of direction\n           int iTemp = i0;\n           i0 = i1;\n           i1 = iTemp;\n         }\n         if (isFirstInPair) {\n            setOutput(float(i0));\n         } else {\n            setOutput(float(i1));\n         }\n       }\n     "}}class by{constructor(e){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"k",type:"int"}],this.outputShape=e,this.userCode="\n    void main() {\n         // Takes max of indices (0, k), (1, k + 1), (2, k + 2) ...\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int elemIdx = coords[1];\n\n         // The output size is half of the previous size.\n         // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _ (k=4),\n         // we only need to output the indices at positions |, the indices at\n         // positions _ can be thrown away, see Figure5(b) After Phase 2\n         // (Merge phase) in the Bitonic Top K paper referenced above.\n         // For example, the paper shows we only need to output the orange bars.\n         // The output sequence should look like this | | | | | | | |.\n         // Because the sequence is halved, to map the output index back\n         // to the previous sequence to find the corresponding value,\n         // we need to double the index. When we double the index,\n         // we basically interpolate a position, so 2i looks like\n         // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k position\n         // of each 2k positions by - elemIdx % k. E.g. for output at\n         // index 4,5,6,7, we want to get the corresponding element at\n         // original index 8,9,10,11, for output at index 8,9,10,11,\n         // we want to get the corresponding element at original index\n         // 16,17,18,19, so on and so forth.\n\n         int i = elemIdx < k ? elemIdx : (elemIdx * 2 - imod(elemIdx, k));\n         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));\n         int i1 = firstPass == 1 ? i + k : int(getIndices(batch, i + k));\n\n         float x0 = getX(batch, i0);\n         float x1 = i1 < n ? getX(batch, i1) : x0;\n\n         setOutput(x0 >= x1 ? float(i0) : float(i1));\n       }\n     "}}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gy(e,t){null!==t&&e.disposeIntermediateTensorInfo(t)}function yy(e){let t=1;while(t<e)t*=2;return t}function xy(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{k:s,sorted:o}=r,i=Object(c["env"])().getNumber("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD"),u=Object(c["env"])().getNumber("TOPK_K_CPU_HANDOFF_THRESHOLD"),l=a.shape,d=l[l.length-1];if(n.shouldExecuteOnCPU([a])||d<i||s>u){const e=n.readSync(a.dataId),[t,r]=sc(e,l,a.dtype,s,o);return[n.makeTensorInfo(t.shape,t.dtype,t.values),n.makeTensorInfo(r.shape,r.dtype,r.values)]}if(0===s)return l[l.length-1]=0,[n.makeTensorInfo(l,a.dtype,[]),n.makeTensorInfo(l,"int32",[])];if(1===d)return[a,yh({attrs:{shape:l,dtype:"int32",value:0},backend:n})];const p=n.texData.get(a.dataId),h=null!==p&&p.isPacked,f=h?n.unpackTensor(a):a,m=c["util"].sizeFromShape(l),b=m/d,g=Nu({inputs:{x:f},attrs:{shape:[b,d]},backend:n});h&&gy(n,f);const y=yy(s),x=yy(d);let O=null;const v=()=>null===O?[g,g]:[g,O],w=(e,t,r)=>{const a=v(),s=new my(r),o=null===O?1:0,i=[[d],[o],[Number.NEGATIVE_INFINITY],[e],[t]],c=O;O=n.runWebGLProgram(s,a,"int32",i),gy(n,c)};for(let c=1;c<y;c*=2){const e=2*c;for(let t=c;t>=1;t/=2)w(e,t,[b,x])}for(let c=x;c>y;c/=2){const e=v(),t=new by([b,c/2]),r=null===O?1:0,a=[[d],[r],[y]],s=O;O=n.runWebGLProgram(t,e,"int32",a),gy(n,s);const o=y/2,i=2*o;for(let n=o;n>=1;n/=2)w(i,n,O.shape)}let k=O;O=sd({inputs:{x:O},backend:n,attrs:{begin:0,size:[b,s]}}),gy(n,k);let j=Wh({inputs:{x:g,indices:O},backend:n,attrs:{axis:1,batchDims:1}});gy(n,g);const S=l.slice(0,-1);S.push(s),k=O,O=Nu({inputs:{x:O},attrs:{shape:S},backend:n}),gy(n,k);const N=j;return j=Nu({inputs:{x:j},attrs:{shape:S},backend:n}),gy(n,N),[j,O]}const Oy={kernelName:c["TopK"],backendName:"webgl",kernelFunc:xy};
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class vy{constructor(e,t,n,r,a,s){this.variableNames=["Image","Transforms"],this.outputShape=s;const o="nearest"===n?1:2;let i;switch(r){case"constant":i=1;break;case"reflect":i=2;break;case"wrap":i=3;break;case"nearest":i=4;break;default:i=1;break}this.userCode=`\n            float mapCoord(float outCoord, float len) {\n              float inCoord = outCoord;\n              if(${i} == 2) {\n                if (inCoord < 0.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz2 = 2.0 * len;\n                    if (inCoord < sz2) {\n                      inCoord = sz2 * float(int(float(-inCoord / sz2))) +\n                      inCoord;\n                    }\n                    inCoord = inCoord < -len ? inCoord + sz2 : -inCoord - 1.0;\n                  }\n                } else if (inCoord > len - 1.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz2 = 2.0 * len;\n                    inCoord -= sz2 * float(int(float(inCoord / sz2)));\n                    if (inCoord >= len) {\n                      inCoord = sz2 - inCoord - 1.0;\n                    }\n                  }\n                }\n                return clamp(inCoord, 0.0, len - 1.0);\n              } else if (${i} == 3) {\n                if (inCoord < 0.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz = len - 1.0;\n                    inCoord += len * (float(int(float(-inCoord / sz))) + 1.0);\n                  }\n                } else if (inCoord > len - 1.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz = len - 1.0;\n                    inCoord -= len * float(int(float(inCoord / sz)));\n                  }\n                }\n                return clamp(inCoord, 0.0, len - 1.0);\n              } else if (${i} == 4) {\n                return clamp(outCoord, 0.0, len - 1.0);\n              } else {\n                return outCoord;\n              }\n            }\n\n            float readWithFillValue(int batch, int coordY, int coordX,\n              int channel) {\n              float outputValue;\n              if (0 <= coordY && coordY < ${e} && 0 <= coordX && coordX < ${t}) {\n                  outputValue = getImage(batch, coordY, coordX, channel);\n              } else {\n                outputValue = float(${a});\n              }\n              return outputValue;\n            }\n\n            void main() {\n              ivec4 coords = getOutputCoords();\n              float outputValue;\n              int batch = coords[0];\n              int x = coords[2];\n              int y = coords[1];\n              int channel = coords[3];\n              float xf = float(x);\n              float yf = float(y);\n              float a1 = getTransforms(batch, 0);\n              float a2 = getTransforms(batch, 1);\n              float a3 = getTransforms(batch, 2);\n              float b1 = getTransforms(batch, 3);\n              float b2 = getTransforms(batch, 4);\n              float b3 = getTransforms(batch, 5);\n              float c1 = getTransforms(batch, 6);\n              float c2 = getTransforms(batch, 7);\n              float projection = c1 * xf + c2 * yf + 1.0;\n              if (projection == 0.0) {\n                outputValue = float(${a});\n              } else {\n                float inX = (a1 * xf + a2 * yf + a3) / projection;\n                float inY = (b1 * xf + b2 * yf + b3) / projection;\n                float mapX = mapCoord(inX, float(${t}));\n                float mapY = mapCoord(inY, float(${e}));\n\n                if (${o} == 1) {\n                  int coordY = int(round(mapY));\n                  int coordX = int(round(mapX));\n                  outputValue = readWithFillValue(batch, coordY, coordX,\n                    channel);\n                } else {\n                  float yFloor = floor(mapY);\n                  float xFloor = floor(mapX);\n                  float yCeil = yFloor + 1.0;\n                  float xCeil = xFloor + 1.0;\n                  float valueYFloor = (xCeil - mapX) *\n                  readWithFillValue(batch, int(yFloor), int(xFloor), channel) +\n                  (mapX - xFloor) *\n                  readWithFillValue(batch, int(yFloor), int(xCeil), channel);\n                  float valueYCeil = (xCeil - mapX) *\n                  readWithFillValue(batch, int(yCeil), int(xFloor), channel) +\n                  (mapX - xFloor) *\n                  readWithFillValue(batch, int(yCeil), int(xCeil), channel);\n                  outputValue = (yCeil - mapY) * valueYFloor +\n                  (mapY - yFloor) * valueYCeil;\n                }\n              }\n              setOutput(outputValue);\n            }\n        `}}
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wy(e){const{inputs:t,backend:n,attrs:r}=e,{image:a,transforms:s}=t,{interpolation:o,fillMode:i,fillValue:c,outputShape:u}=r,[l,d,p,h]=a.shape,[f,m]=null!=u?u:[d,p],b=[l,f,m,h],g=new vy(d,p,o,i,c,b);return n.runWebGLProgram(g,[a,s],"float32")}const ky={kernelName:c["Transform"],backendName:"webgl",kernelFunc:wy};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jy(e){const{inputs:t,attrs:n,backend:r}=e,{axis:a}=n,{x:s}=t;ra(s,"unique"),console.warn("WARNING: ","UI might be locked temporarily as data is being downloaded");const o=r.readSync(s.dataId),{outputValues:i,outputShape:c,indices:u}=ic(o,a,s.shape,s.dtype);return[r.makeTensorInfo(c,s.dtype,i),r.makeTensorInfo([u.length],"int32",u)]}const Sy={kernelName:c["Unique"],backendName:"webgl",kernelFunc:jy};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ny(e){const{inputs:t,backend:n,attrs:r}=e,{value:a}=t;let{axis:s}=r;s<0&&(s+=a.shape.length);const o=a,i=o.shape.length,c=a.shape[s],u=new Array(i-1);let l=0;for(let m=0;m<i;m++)m!==s&&(u[l++]=o.shape[m]);const d=[],p=new Array(i).fill(0),h=o.shape.slice();h[s]=1;const f=new Array(c);for(let m=0;m<f.length;m++){p[s]=m;const e=sd({inputs:{x:o},backend:n,attrs:{begin:p,size:h}}),t=Nu({inputs:{x:e},backend:n,attrs:{shape:u}});f[m]=t,d.push(e)}return d.forEach(e=>n.disposeIntermediateTensorInfo(e)),f}const Cy={kernelName:c["Unpack"],backendName:"webgl",kernelFunc:Ny};
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Iy{constructor(e,t){this.variableNames=["x","segmentIds"];const n=e.windowSize,r=e.batchSize,a=e.inSize,s=e.numSegments,o=s*Math.ceil(a/n);this.outputShape=[r,o];const i="0.0",c="sumValue",u=4*Math.floor(n/4),l=n%4,d="\n        sumValue += dot(values, segFilter);\n    ";let p="";a%n>0&&(p=`\n        if (inIdx < 0 || inIdx >= ${a}) {\n          return initializationValue;\n        }\n      `);let h="";a%n>0&&(h=`\n        if (inIdx < 0 || inIdx >= ${a}) {\n          return -1.0;\n        }\n      `),this.userCode=`\n      const float initializationValue = ${i};\n\n      float getValue(int batch, int inIdx) {\n        ${p}\n        return getX(batch, inIdx);\n      }\n\n      float getSegmentIdAtIndex(int inIdx) {\n        ${h}\n        return getSegmentIds(inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = int(floor(float(outIdx) / float(\n          ${s})) * float(${n}));\n        int currentSeg = int(mod(float(outIdx), float(${s})));\n\n        float sumValue = 0.0;\n\n        for (int i = 0; i < ${u}; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0\n          );\n\n          ${d}\n        }\n\n        int inIdx = inOffset + ${u};\n        if (${1===l}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            0,\n            0,\n            0\n          );\n\n          ${d}\n        } else if (${2===l}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n              0,\n              0\n          );\n\n          ${d}\n        } else if (${3===l}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            0\n          );\n\n          ${d}\n        }\n        setOutput(${c});\n      }\n    `}}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ty(e){const{inputs:t,backend:n,attrs:r}=e,{x:a,segmentIds:s}=t,{numSegments:o}=r,i=a.shape.length,u=[];let l=0;const d=c["backend_util"].getAxesPermutation([l],i);let p=a;null!=d&&(p=Pu({inputs:{x:a},backend:n,attrs:{perm:d}}),u.push(p),l=c["backend_util"].getInnerMostAxes(1,i)[0]);const h=c["backend_util"].segment_util.computeOutShape(p.shape,l,o),f=c["util"].sizeFromShape([p.shape[l]]),m=Nu({inputs:{x:p},backend:n,attrs:{shape:[-1,f]}});u.push(m);const b=Object(c["sumOutType"])(a.dtype),g=(e,t,r,a,s)=>{const o=e.shape[0],i=e.shape[1],l=c["backend_util"].segment_util.segOpComputeOptimalWindowSize(i,s),d={windowSize:l,inSize:i,batchSize:o,numSegments:s},p=new Iy(d,t),h=n.compileAndRun(p,[e,r],a);if(u.push(h),h.shape[1]===s)return h;const f=bb({backend:n,attrs:{start:0,stop:s,step:1,dtype:"float32"}}),m=hy({inputs:{x:f},backend:n,attrs:{reps:[i/l]}});u.push(f),u.push(m);const b=g(h,t,m,a,s);return b},y=g(m,"unsortedSegmentSum",s,b,o),x=Nu({inputs:{x:y},backend:n,attrs:{shape:h}});let O=x;if(null!=d){u.push(x);const e=c["backend_util"].getUndoAxesPermutation(d);O=Pu({inputs:{x:O},backend:n,attrs:{perm:e}})}return u.forEach(e=>n.disposeIntermediateTensorInfo(e)),O}const $y={kernelName:c["UnsortedSegmentSum"],backendName:"webgl",kernelFunc:Ty},Ey=[zf,Gf,Uu,qu,Yu,Ju,nl,ol,cl,ll,gl,xl,wl,Sl,Al,Il,Fl,Vl,Pl,Gl,ql,Xl,Jl,cd,ld,xd,wd,Nd,$d,au,Pd,Zd,ep,Hd,ap,op,np,up,pp,mp,Op,wp,Sp,Rp,Fp,Tp,Lp,Vp,Wp,qp,Qp,th,ah,ih,uh,ph,bh,xh,vh,jh,Ih,Eh,Fh,Mh,Bh,Uh,Kh,Zh,nu,ef,Fd,rf,of,lf,cu,ff,yf,Of,Cf,jf,Ef,_f,Lf,Kf,nm,em,om,cm,lm,Zf,pm,fm,ym,wm,Nm,Lm,ju,Vm,Um,qm,Ym,hd,Jm,rb,sb,ub,hb,pu,mb,gb,md,Em,Ob,Ib,jb,Cu,Ab,Fb,Pb,zb,Hb,Kb,Qb,eg,rg,og,ug,pg,mg,yg,vg,od,Dm,jg,Ng,Ig,$g,Ag,_g,Dg,Lg,Vg,Ug,qg,Xg,Zg,ey,ny,ay,_m,Lu,iy,ly,fy,Oy,ky,Bu,Sy,Cy,$y,tb];
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */for(const My of Ey)Object(c["registerKernel"])(My);
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var Ay=n("0a07"),Ry={components:{},props:{},data:function(){return{loading:!1,infoList:[],imageUrl:n("927c")}},computed:{},watch:{},created:function(){},mounted:function(){console.log(c),console.log(r)},methods:{identify:function(){var e=this;return Object(i["a"])(regeneratorRuntime.mark((function t(){var n,r;return regeneratorRuntime.wrap((function(t){while(1)switch(t.prev=t.next){case 0:return e.loading=!0,n=document.getElementById("img"),t.next=4,Gn();case 4:return r=t.sent,t.next=7,r.classify(n);case 7:e.infoList=t.sent,e.loading=!1,console.log("infoList: "),console.log(e.infoList);case 11:case"end":return t.stop()}}),t)})))()},selectFile:function(){var e=this;return Object(i["a"])(regeneratorRuntime.mark((function t(){var n;return regeneratorRuntime.wrap((function(t){while(1)switch(t.prev=t.next){case 0:return t.next=2,Object(Ay["a"])();case 2:n=t.sent,console.log(n,"======"),e.imageUrl=n[0];case 5:case"end":return t.stop()}}),t)})))()}}},_y=Ry,Fy=(n("1528"),n("2877")),Dy=Object(Fy["a"])(_y,s,o,!1,null,"0c3a4303",null);t["default"]=Dy.exports},"73b8":function(e,t,n){"use strict";n.d(t,"c",(function(){return c})),n.d(t,"b",(function(){return u})),n.d(t,"d",(function(){return l})),n.d(t,"f",(function(){return d})),n.d(t,"e",(function(){return p})),n.d(t,"h",(function(){return h})),n.d(t,"g",(function(){return f})),n.d(t,"a",(function(){return m}));var r=n("b333"),a=n("f490"),s=n("b294");
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const o=Object(a["a"])("kernelRegistry",()=>new Map),i=Object(a["a"])("gradRegistry",()=>new Map);function c(e,t){const n=b(e,t);return o.get(n)}function u(e){return i.get(e)}function l(e){const t=o.entries(),n=[];while(1){const{done:r,value:a}=t.next();if(r)break;const[s,o]=a,[i]=s.split("_");i===e&&n.push(o)}return n}function d(e){const{kernelName:t,backendName:n}=e,r=b(t,n);o.has(r)&&s["b"](`The kernel '${t}' for backend '${n}' is already registered`),o.set(r,e)}function p(e){const{kernelName:t}=e;i.has(t)&&Object(r["c"])().getBool("DEBUG")&&s["b"](`Overriding the gradient for '${t}'`),i.set(t,e)}function h(e,t){const n=b(e,t);if(!o.has(n))throw new Error(`The kernel '${e}' for backend '${t}' is not registered`);o.delete(n)}function f(e){if(!i.has(e))throw new Error(`The gradient '${e}' for backend is not registered`);i.delete(e)}function m(e,t){const n=l(e);n.forEach(e=>{const n=Object.assign({},e,{backendName:t});d(n)})}function b(e,t){return`${t}_${e}`}},"73d3":function(e,t,n){"use strict";n.d(t,"a",(function(){return u}));var r=n("6ae2"),a=n("c05b"),s=n("6ad5"),o=n("54ef"),i=n("35c9");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function c(e,t,n,o,c,u="NHWC",l){s["b"](e.length===t.rank,()=>`Length of inShape (${e.length}) and rank of dy (${t.rank}) must match`);let d=e,p=t,h=!1;3===t.rank&&(h=!0,p=Object(i["a"])(t,[1,t.shape[0],t.shape[1],t.shape[2]]),d=[1,e[0],e[1],e[2]]),s["b"](4===d.length,()=>"Error in conv2dDerInput: inShape must be length 4, but got length "+d.length+"."),s["b"](4===p.rank,()=>"Error in conv2dDerInput: dy must be rank 4, but got rank "+p.rank),s["b"](4===n.rank,()=>"Error in conv2dDerInput: filter must be rank 4, but got rank "+n.rank);const f="NHWC"===u?d[3]:d[1],m="NHWC"===u?p.shape[3]:p.shape[1];s["b"](f===n.shape[2],()=>`Error in conv2dDerInput: depth of input (${f}) must match input depth for filter ${n.shape[2]}.`),s["b"](m===n.shape[3],()=>`Error in conv2dDerInput: depth of output (${m}) must match output depth for filter ${n.shape[3]}.`),null!=l&&s["b"](s["v"](c),()=>`Error in conv2dDerInput: pad must be an integer when using, dimRoundingMode ${l} but got pad ${c}.`);const b={dy:p,filter:n},g={strides:o,pad:c,dataFormat:u,dimRoundingMode:l,inputShape:d},y=r["a"].runKernel(a["F"],b,g);return h?Object(i["a"])(y,[y.shape[1],y.shape[2],y.shape[3]]):y}const u=Object(o["b"])({conv2DBackpropInput_:c})},7568:function(e,t,n){"use strict";
/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function r(e,t=!1){console.log(e.toString(t))}n.d(t,"a",(function(){return r}))},7580:function(e,t,n){"use strict";n.d(t,"a",(function(){return u}));var r=n("6ae2"),a=n("c05b"),s=n("a3f7"),o=n("6ad5"),i=n("54ef");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function c(e,t,n){const i=Object(s["a"])(e,"x","spaceToBatchND");o["b"](i.rank>=1+t.length,()=>`input rank ${i.rank} should be > than [blockShape] ${t.length}`),o["b"](n.length===t.length,()=>`paddings.shape[0] ${n.length} must be equal to [blockShape] ${t.length}`),o["b"](i.shape.reduce((e,r,a)=>a>0&&a<=t.length?e&&(r+n[a-1][0]+n[a-1][1])%t[a-1]===0:e,!0),()=>`input spatial dimensions ${i.shape.slice(1)} with paddings ${n.toString()} must be divisible by blockShapes ${t.toString()}`);const c={x:i},u={blockShape:t,paddings:n};return r["a"].runKernel(a["Jc"],c,u)}const u=Object(i["b"])({spaceToBatchND_:c})},"75ab":function(e,t,n){"use strict";n.d(t,"a",(function(){return c}));var r=n("6ae2"),a=n("c05b"),s=n("a3f7"),o=n("54ef");
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function i(e,...t){const n=t.map((e,t)=>Object(s["a"])(e,"tensors"+t,"einsum")),o={equation:e};return r["a"].runKernel(a["W"],n,o)}const c=Object(o["b"])({einsum_:i})},7675:function(e,t,n){"use strict";n.d(t,"a",(function(){return l}));var r=n("a3f7"),a=n("6ad5"),s=n("dd7e"),o=n("b818"),i=n("54ef"),c=n("35c9");function u(e,t,n,i,u="NWC",l=1,d){const p=Object(r["a"])(e,"x","conv1d"),h=Object(r["a"])(t,"filter","conv1d");let f=p,m=!1;2===p.rank&&(m=!0,f=Object(c["a"])(p,[1,p.shape[0],p.shape[1]])),a["b"](3===f.rank,()=>`Error in conv1d: input must be rank 3, but got rank ${f.rank}.`),a["b"](3===h.rank,()=>"Error in conv1d: filter must be rank 3, but got rank "+h.rank+"."),null!=d&&a["b"](a["v"](i),()=>`Error in conv1d: pad must be an integer when using, dimRoundingMode ${d} but got pad ${i}.`),a["b"](f.shape[2]===h.shape[1],()=>`Error in conv1d: depth of input (${f.shape[2]}) must match input depth for filter ${h.shape[1]}.`),a["b"](o["h"](n,l),()=>`Error in conv1D: Either stride or dilation must be 1. Got stride ${n} and dilation '${l}'`),a["b"]("NWC"===u,()=>`Error in conv1d: got dataFormat of ${u} but only NWC is currently supported.`);const b=Object(c["a"])(h,[1,h.shape[0],h.shape[1],h.shape[2]]),g=Object(c["a"])(f,[f.shape[0],1,f.shape[1],f.shape[2]]),y=[1,n],x=[1,l],O="NHWC",v=Object(s["a"])(g,b,y,i,O,x,d);return m?Object(c["a"])(v,[v.shape[2],v.shape[3]]):Object(c["a"])(v,[v.shape[0],v.shape[2],v.shape[3]])}const l=Object(i["b"])({conv1d_:u})},"76c2":function(e,t,n){"use strict";n.r(t),n.d(t,"makeTypesMatch",(function(){return o})),n.d(t,"assertTypesMatch",(function(){return i})),n.d(t,"isTensorInList",(function(){return c})),n.d(t,"getTensorsInContainer",(function(){return u}));var r=n("34d7"),a=n("23bf"),s=n("6ad5");
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function o(e,t){if(e.dtype===t.dtype)return[e,t];const n=Object(a["c"])(e.dtype,t.dtype);return[e.cast(n),t.cast(n)]}function i(e,t){Object(s["b"])(e.dtype===t.dtype,()=>`The dtypes of the first(${e.dtype}) and second(${t.dtype}) input must match`)}function c(e,t){return t.some(t=>t.id===e.id)}function u(e){const t=[],n=new Set;return l(e,t,n),t}function l(e,t,n){if(null==e)return;if(e instanceof r["a"])return void t.push(e);if(!d(e))return;const a=e;for(const r in a){const e=a[r];n.has(e)||(n.add(e),l(e,t,n))}}function d(e){return Array.isArray(e)||"object"===typeof e}},"7aec":function(e,t,n){(function(e){var r;(function(e,a,s){function o(e){var t=this;function n(e,t){var n,r,a,s,o,i=[],c=128;for(t===(0|t)?(r=t,t=null):(t+="\0",r=0,c=Math.max(c,t.length)),a=0,s=-32;s<c;++s)t&&(r^=t.charCodeAt((s+32)%t.length)),0===s&&(o=r),r^=r<<10,r^=r>>>15,r^=r<<4,r^=r>>>13,s>=0&&(o=o+1640531527|0,n=i[127&s]^=r+o,a=0==n?a+1:0);for(a>=128&&(i[127&(t&&t.length||0)]=-1),a=127,s=512;s>0;--s)r=i[a+34&127],n=i[a=a+1&127],r^=r<<13,n^=n<<17,r^=r>>>15,n^=n>>>12,i[a]=r^n;e.w=o,e.X=i,e.i=a}t.next=function(){var e,n,r=t.w,a=t.X,s=t.i;return t.w=r=r+1640531527|0,n=a[s+34&127],e=a[s=s+1&127],n^=n<<13,e^=e<<17,n^=n>>>15,e^=e>>>12,n=a[s]=n^e,t.i=s,n+(r^r>>>16)|0},n(t,e)}function i(e,t){return t.i=e.i,t.w=e.w,t.X=e.X.slice(),t}function c(e,t){null==e&&(e=+new Date);var n=new o(e),r=t&&t.state,a=function(){return(n.next()>>>0)/4294967296};return a.double=function(){do{var e=n.next()>>>11,t=(n.next()>>>0)/4294967296,r=(e+t)/(1<<21)}while(0===r);return r},a.int32=n.next,a.quick=a,r&&(r.X&&i(r,n),a.state=function(){return i(n,{})}),a}a&&a.exports?a.exports=c:n("07d6")&&n("3c35")?(r=function(){return c}.call(t,n,t,a),void 0===r||(a.exports=r)):this.xor4096=c})(0,e,n("07d6"))}).call(this,n("62e4")(e))},"7e36":function(e,t,n){"use strict";n.d(t,"a",(function(){return c}));var r=n("6ae2"),a=n("c05b"),s=n("a3f7"),o=n("54ef");
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function i(e){const t=Object(s["a"])(e,"x","atan"),n={x:t};return r["a"].runKernel(a["l"],n)}const c=Object(o["b"])({atan_:i})},"7e6a":function(e,t,n){"use strict";n.d(t,"a",(function(){return i}));var r=n("043e"),a=n("54ef"),s=n("d4e4");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function o(e,t=0,n=1,a,o){if(null!=a&&"bool"===a)throw new Error("Unsupported data type $ { dtype }");const i=new s["a"](t,n,a,!0,o),c=Object(r["a"])(e,a);for(let r=0;r<c.values.length;r++)c.values[r]=i.nextValue();return c.toTensor()}const i=Object(a["b"])({truncatedNormal_:o})},"7ed6":function(e,t,n){"use strict";
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function r(){return"undefined"!==typeof navigator&&null!=navigator}function a(e){if(e||r()){if(e||(e=navigator),"ReactNative"===e.product)return!0;const t=e.userAgent||e.vendor||("undefined"!==typeof window?window.opera:"");if(!t){const t=e;return t.userAgentData&&t.userAgentData.mobile}return/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(t)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(t.substr(0,4))}return!1}function s(){return"undefined"!==typeof window&&null!=window.document||"undefined"!==typeof WorkerGlobalScope}n.r(t),n.d(t,"isMobile",(function(){return a})),n.d(t,"isBrowser",(function(){return s}))},"804a":function(e,t,n){"use strict";n.d(t,"a",(function(){return f}));var r=n("538e"),a=n("a3f7"),s=n("deb3"),o=n("4f20"),i=n("1359"),c=n("c021"),u=n("a5aa"),l=n("54ef"),d=n("a009"),p=n("e053");
/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function h(e,t=-1){const n=Object(a["a"])(e,"logits","logSoftmax");if(-1===t&&(t=n.rank-1),t!==n.rank-1)throw Error(`Log Softmax along a non-last dimension is not yet supported. Logits was rank ${n.rank} and axis was ${t}`);const l=Object(r["a"])((e,n)=>{const r=!0,a=Object(c["a"])(e,t,!0),l=Object(d["a"])(e,a),h=Object(d["a"])(Object(s["a"])(l,"float32"),Object(i["a"])(Object(p["a"])(Object(o["a"])(l),t,r)));n([h]);const f=(e,n)=>{const[r]=n,a=!0,s=Object(o["a"])(r);return Object(d["a"])(e,Object(u["a"])(Object(p["a"])(e,t,a),s))};return{value:h,gradFunc:f}});return l(n)}const f=Object(l["b"])({logSoftmax_:h})},8389:function(e,t,n){"use strict";
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function r(e,t,n){const r=a(e,t,n),s=r<0?-(r+1):r;e.splice(s,0,t)}function a(e,t,n){return o(e,t,n||s)}function s(e,t){return e>t?1:e<t?-1:0}function o(e,t,n){let r=0,a=e.length,s=0,o=!1;while(r<a){s=r+(a-r>>>1);const i=n(t,e[s]);i>0?r=s+1:(a=s,o=!i)}return o?r:-r-1}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function i(e,t,n,r,a){return l(e,t,n,r,a,0)}function c(e,t,n,r,a,s){return l(e,t,n,r,a,0,!1,s,!0)}function u(e,t,n,r,a,s){return l(e,t,n,r,a,s,!0)}function l(e,t,n,a,s,o,i=!1,c=!1,u=!1){const l=[];for(let r=0;r<t.length;r++)t[r]>s&&l.push({score:t[r],boxIndex:r,suppressBeginIndex:0});l.sort(h);const f=o>0?-.5/o:0,m=[],b=[];while(m.length<n&&l.length>0){const t=l.pop(),{score:n,boxIndex:o,suppressBeginIndex:i}=t;if(n<s)break;let c=!1;for(let r=m.length-1;r>=i;--r){const n=d(e,o,m[r]);if(n>=a){c=!0;break}if(t.score=t.score*p(a,f,n),t.score<=s)break}t.suppressBeginIndex=m.length,c||(t.score===n?(m.push(o),b.push(t.score)):t.score>s&&r(l,t,h))}const g=m.length,y=n-g;c&&y>0&&(m.push(...new Array(y).fill(0)),b.push(...new Array(y).fill(0)));const x={selectedIndices:m};return i&&(x["selectedScores"]=b),u&&(x["validOutputs"]=g),x}function d(e,t,n){const r=e.subarray(4*t,4*t+4),a=e.subarray(4*n,4*n+4),s=Math.min(r[0],r[2]),o=Math.min(r[1],r[3]),i=Math.max(r[0],r[2]),c=Math.max(r[1],r[3]),u=Math.min(a[0],a[2]),l=Math.min(a[1],a[3]),d=Math.max(a[0],a[2]),p=Math.max(a[1],a[3]),h=(i-s)*(c-o),f=(d-u)*(p-l);if(h<=0||f<=0)return 0;const m=Math.max(s,u),b=Math.max(o,l),g=Math.min(i,d),y=Math.min(c,p),x=Math.max(g-m,0)*Math.max(y-b,0);return x/(h+f-x)}function p(e,t,n){const r=Math.exp(t*n*n);return n<=e?r:0}function h(e,t){return e.score-t.score||e.score===t.score&&t.boxIndex-e.boxIndex}n.d(t,"a",(function(){return i})),n.d(t,"b",(function(){return c})),n.d(t,"c",(function(){return u}))},"838f":function(e,t,n){"use strict";n.d(t,"a",(function(){return l}));var r=n("6ae2"),a=n("c05b"),s=n("a3f7"),o=n("6ad5"),i=n("54ef"),c=n("35c9");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function u(e,t,n,i,u="NHWC",l=[1,1],d){const p=Object(s["a"])(e,"x","depthwiseConv2d"),h=Object(s["a"])(t,"filter","depthwiseConv2d");let f=p,m=!1;3===p.rank&&(m=!0,f=Object(c["a"])(p,[1,p.shape[0],p.shape[1],p.shape[2]])),o["b"](4===f.rank,()=>`Error in depthwiseConv2d: input must be rank 4, but got rank ${f.rank}.`),o["b"](4===h.rank,()=>"Error in depthwiseConv2d: filter must be rank 4, but got rank "+h.rank+"."),o["b"](f.shape[3]===h.shape[2],()=>`Error in depthwiseConv2d: number of input channels (${f.shape[3]}) must match the inChannels dimension in filter ${h.shape[2]}.`),null!=d&&o["b"](o["v"](i),()=>`Error in depthwiseConv2d: pad must be an integer when using, dimRoundingMode ${d} but got pad ${i}.`);const b={x:f,filter:h},g={strides:n,pad:i,dataFormat:u,dilations:l,dimRoundingMode:d},y=r["a"].runKernel(a["P"],b,g);return m?Object(c["a"])(y,[y.shape[1],y.shape[2],y.shape[3]]):y}const l=Object(i["b"])({depthwiseConv2d_:u})},"84d6":function(e,t,n){"use strict";n.d(t,"a",(function(){return s}));var r=n("6ae2"),a=n("c05b");
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function s(e,t,n=1,s="float32"){if(0===n)throw new Error("Cannot have a step of zero");const o={start:e,stop:t,step:n,dtype:s};return r["a"].runKernel(a["kc"],{},o)}},"853e":function(e,t,n){"use strict";n.d(t,"a",(function(){return u}));var r=n("6ae2"),a=n("c05b"),s=n("a3f7"),o=n("6ad5"),i=n("54ef");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function c(e,t=0){const n=Object(s["a"])(e,"x","unique","string_or_numeric");Object(o["b"])(n.rank>0,()=>"The input tensor must be at least 1D");const i={x:n},c={axis:t},[u,l]=r["a"].runKernel(a["gd"],i,c);return{values:u,indices:l}}const u=Object(i["b"])({unique_:c})},8629:function(e,t,n){"use strict";n.d(t,"a",(function(){return i}));var r=n("043e"),a=n("54ef"),s=n("d4e4");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function o(e,t=0,n=1,a="float32",o){const i=Object(r["a"])(e,a),c=new s["c"](t,n,null,o);for(let r=0;r<i.values.length;r++)i.values[r]=c.nextValue();return i.toTensor()}const i=Object(a["b"])({randomUniform_:o})},8888:function(e,t,n){"use strict";n.d(t,"a",(function(){return c}));var r=n("6ae2"),a=n("c05b"),s=n("a3f7"),o=n("54ef");
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function i(e){const t=Object(s["a"])(e,"x","tanh"),n={x:t};return r["a"].runKernel(a["bd"],n)}const c=Object(o["b"])({tanh_:i})},"89ed":function(e,t,n){(function(e){var r;(function(e,a,s){function o(e){var t=this,n="";t.next=function(){var e=t.b,n=t.c,r=t.d,a=t.a;return e=e<<25^e>>>7^n,n=n-r|0,r=r<<24^r>>>8^a,a=a-e|0,t.b=e=e<<20^e>>>12^n,t.c=n=n-r|0,t.d=r<<16^n>>>16^a,t.a=a-e|0},t.a=0,t.b=0,t.c=-1640531527,t.d=1367130551,e===Math.floor(e)?(t.a=e/4294967296|0,t.b=0|e):n+=e;for(var r=0;r<n.length+20;r++)t.b^=0|n.charCodeAt(r),t.next()}function i(e,t){return t.a=e.a,t.b=e.b,t.c=e.c,t.d=e.d,t}function c(e,t){var n=new o(e),r=t&&t.state,a=function(){return(n.next()>>>0)/4294967296};return a.double=function(){do{var e=n.next()>>>11,t=(n.next()>>>0)/4294967296,r=(e+t)/(1<<21)}while(0===r);return r},a.int32=n.next,a.quick=a,r&&("object"==typeof r&&i(r,n),a.state=function(){return i(n,{})}),a}a&&a.exports?a.exports=c:n("07d6")&&n("3c35")?(r=function(){return c}.call(t,n,t,a),void 0===r||(a.exports=r)):this.tychei=c})(0,e,n("07d6"))}).call(this,n("62e4")(e))},"8ae0":function(e,t,n){"use strict";n.d(t,"a",(function(){return c}));var r=n("6ae2"),a=n("c05b"),s=n("a3f7"),o=n("54ef");
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function i(e){const t=Object(s["a"])(e,"x","abs");if("complex64"===t.dtype){const e={x:t};return r["a"].runKernel(a["B"],e)}{const e={x:t};return r["a"].runKernel(a["a"],e)}}const c=Object(o["b"])({abs_:i})},"8b87":function(e,t,n){"use strict";n.d(t,"a",(function(){return s})),n.d(t,"b",(function(){return o}));
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const r=1e-7,a=1e-4;class s{constructor(e,t){this.backend=e,this.dataMover=t,this.data=new WeakMap,this.dataIdsCount=0}get(e){return this.data.has(e)||this.dataMover.moveData(this.backend,e),this.data.get(e)}set(e,t){this.dataIdsCount++,this.data.set(e,t)}has(e){return this.data.has(e)}delete(e){return this.dataIdsCount--,this.data.delete(e)}numDataIds(){return this.dataIdsCount}}class o{refCount(e){return i("refCount")}incRef(e){return i("incRef")}timerAvailable(){return!0}time(e){return i("time")}read(e){return i("read")}readSync(e){return i("readSync")}numDataIds(){return i("numDataIds")}disposeData(e,t){return i("disposeData")}write(e,t,n){return i("write")}move(e,t,n,r,a){return i("move")}memory(){return i("memory")}floatPrecision(){return i("floatPrecision")}epsilon(){return 32===this.floatPrecision()?r:a}dispose(){return i("dispose")}}function i(e){throw new Error(`'${e}' not yet implemented or not found in the registry. This kernel may not be supported by the tfjs backend you have chosen`)}},"8bc9":function(e,t,n){"use strict";n.d(t,"a",(function(){return c}));var r=n("6ae2"),a=n("c05b"),s=n("a3f7"),o=n("54ef");
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function i(e,t,n,o,i=!1){const c=Object(s["a"])(e,"x","maxPoolWithArgmax"),u={x:c},l={filterSize:t,strides:n,pad:o,includeBatchInIndex:i},d=r["a"].runKernel(a["Ob"],u,l);return{result:d[0],indexes:d[1]}}const c=Object(o["b"])({maxPoolWithArgmax_:i})},"8bfa":function(e,t,n){"use strict";n.d(t,"a",(function(){return u}));var r=n("6ae2"),a=n("c05b"),s=n("a3f7"),o=n("54ef"),i=n("a34f");
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function c(e,t,n){const o=Object(s["a"])(e,"indices","scatterND","int32"),c=Object(s["a"])(t,"updates","scatterND");i["validateInput"](c,o,n);const u={indices:o,updates:c},l={shape:n};return r["a"].runKernel(a["zc"],u,l)}const u=Object(o["b"])({scatterND_:c})},"8d71":function(e,t,n){"use strict";n.d(t,"a",(function(){return u}));var r=n("6ae2"),a=n("c05b"),s=n("a3f7"),o=n("6ad5"),i=n("54ef");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function c(e,t){const n=Object(s["a"])(e,"x","tile","string_or_numeric");o["b"](n.rank===t.length,()=>`Error in transpose: rank of input ${n.rank} must match length of reps ${t}.`);const i={x:n},c={reps:t};return r["a"].runKernel(a["cd"],i,c)}const u=Object(i["b"])({tile_:c})},"8e05":function(e,t,n){"use strict";n.d(t,"a",(function(){return l}));var r=n("6ae2"),a=n("c05b"),s=n("a3f7"),o=n("6ad5"),i=n("deb3"),c=n("54ef");
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function u(e){let t=Object(s["a"])(e,"x","erf");o["b"]("int32"===t.dtype||"float32"===t.dtype,()=>"Input dtype must be `int32` or `float32`."),"int32"===t.dtype&&(t=Object(i["a"])(t,"float32"));const n={x:t};return r["a"].runKernel(a["ab"],n)}const l=Object(c["b"])({erf_:u})},9117:function(e,t,n){"use strict";n.d(t,"a",(function(){return u}));var r=n("6ae2"),a=n("c05b"),s=n("76c2"),o=n("a3f7"),i=n("54ef");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function c(e,t){let n=Object(o["a"])(e,"a","add"),i=Object(o["a"])(t,"b","add");[n,i]=Object(s["makeTypesMatch"])(n,i);const c={a:n,b:i};return r["a"].runKernel(a["d"],c)}const u=Object(i["b"])({add_:c})},"917a":function(e,t,n){"use strict";n.d(t,"a",(function(){return c}));var r=n("6ae2"),a=n("c05b"),s=n("a3f7"),o=n("54ef");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function i(e){const t=Object(s["a"])(e,"x","relu"),n={x:t};return r["a"].runKernel(a["oc"],n)}const c=Object(o["b"])({relu_:i})},"91a3":function(e,t,n){"use strict";n.d(t,"a",(function(){return c}));var r=n("6ae2"),a=n("c05b"),s=n("a3f7"),o=n("54ef");
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function i(e,t,n=0,o=0){const i=Object(s["a"])(e,"x","gather"),c=Object(s["a"])(t,"indices","gather","int32"),u={x:i,indices:c},l={axis:n,batchDims:o};return r["a"].runKernel(a["ob"],u,l)}const c=Object(o["b"])({gather_:i})},"927c":function(e,t,n){e.exports=n.p+"img/cat.c1323ab6.jpg"},"93b2":function(e,t,n){"use strict";n.d(t,"a",(function(){return i}));var r=n("6ae2"),a=n("a3f7"),s=n("54ef");
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function o(e){const t=Object(a["a"])(e,"x","square"),n={};return r["a"].runKernel("Square",{x:t},n)}const i=Object(s["b"])({square_:o})},"93db":function(e,t,n){"use strict";n.d(t,"a",(function(){return u}));var r=n("6ae2"),a=n("c05b"),s=n("a3f7"),o=n("6ad5"),i=n("54ef");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function c(e,t,n){o["b"]("reflect"===n||"symmetric"===n,()=>`Invalid mode. Mode must be either reflect or symmetric. Got ${n}.`);const i=Object(s["a"])(e,"x","mirrorPad");if(0===i.rank)throw new Error("mirrorPad(scalar) is not defined. Pass non-scalar to mirrorPad");o["b"](t.length===i.rank,()=>`Padding doesn't match input. Must be ${i.rank}. Got ${t.length}.`);const c="reflect"===n?1:0;for(let r=0;r<i.rank;r++)o["b"](2===t[r].length,()=>"Invalid number of paddings. Must be length of 2 each."),o["b"](t[r][0]>=0&&t[r][0]<=i.shape[r]-c&&t[r][1]>=0&&t[r][1]<=i.shape[r]-c,()=>`Padding in dimension ${r} cannot be greater than or equal to ${i.shape[r]-c} or less than 0 for input of shape `+i.shape);const u={paddings:t,mode:n},l={x:i};return r["a"].runKernel(a["Tb"],l,u)}const u=Object(i["b"])({mirrorPad_:c})},9489:function(e,t,n){"use strict";n.r(t),n.d(t,"json",(function(){return r}));
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const r=[{tfOpName:"AvgPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[],notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPoolWithArgmax",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"include_batch_in_index",name:"includeBatchInIndex",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AvgPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Conv1D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"stride",name:"stride",type:"number"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NWC"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"dilation",name:"dilation",type:"number",defaultValue:1}]},{tfOpName:"Conv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"useCudnnOnGpu",name:"useCudnnOnGpu",type:"bool"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"_FusedConv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"use_cudnn_on_gpu",name:"useCudnnOnGpu",type:"bool",defaultValue:!0},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number"}]},{tfOpName:"Conv2DBackpropInput",category:"convolution",inputs:[{start:2,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:0,name:"outputShape",type:"number[]"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]",notSupported:!0}]},{tfOpName:"DepthwiseConv2d",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"DepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"FusedDepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]}]},{tfOpName:"Conv3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"Dilation2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"rates",name:"dilations",type:"number[]"},{tfName:"padding",name:"pad",type:"string"}]}]},"960f":function(e,t,n){"use strict";n.d(t,"a",(function(){return o}));var r=n("a3f7"),a=n("6ad5"),s=n("5959");
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function o(e,t){Object(a["d"])(e);const n=Object(r["c"])(e,t);if(1!==n.length)throw new Error("tensor1d() requires values to be a flat/TypedArray");const o=null;return Object(s["a"])(e,o,n,t)}},9748:function(e,t,n){"use strict";n.d(t,"a",(function(){return p}));var r=n("6ae2"),a=n("c05b"),s=n("a3f7"),o=n("6ad5"),i=n("deb3"),c=n("b818"),u=n("54ef"),l=n("35c9");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function d(e,t,n,u,d){const p=Object(s["a"])(e,"x","avgPool","float32"),h=1;o["b"](c["h"](n,h),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${n} and dilations '${h}'`);let f=p,m=!1;3===p.rank&&(m=!0,f=Object(l["a"])(p,[1,p.shape[0],p.shape[1],p.shape[2]])),o["b"](4===f.rank,()=>`Error in avgPool: x must be rank 4 but got rank ${f.rank}.`),null!=d&&o["b"](o["v"](u),()=>`Error in avgPool: pad must be an integer when using, dimRoundingMode ${d} but got pad ${u}.`);const b={x:f},g={filterSize:t,strides:n,pad:u,dimRoundingMode:d};let y=r["a"].runKernel(a["o"],b,g);return y=Object(i["a"])(y,p.dtype),m?Object(l["a"])(y,[y.shape[1],y.shape[2],y.shape[3]]):y}const p=Object(u["b"])({avgPool_:d})},9847:function(e,t,n){"use strict";n.d(t,"a",(function(){return r}));
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const r={float32:4,float16:2,int32:4,uint16:2,uint8:1,bool:1,complex64:8}},"9e38":function(e,t,n){"use strict";n.d(t,"a",(function(){return c}));var r=n("6ae2"),a=n("c05b"),s=n("a3f7"),o=n("54ef");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function i(e){const t=Object(s["a"])(e,"x","elu"),n={x:t};return r["a"].runKernel(a["X"],n)}const c=Object(o["b"])({elu_:i})},"9e7b":function(e,t,n){"use strict";n.r(t),n.d(t,"json",(function(){return r}));
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const r=[{tfOpName:"Cast",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"SrcT",name:"sdtype",type:"dtype",notSupported:!0},{tfName:"DstT",name:"dtype",type:"dtype"}]},{tfOpName:"ExpandDims",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"MirrorPad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"mode",name:"mode",type:"string"}]},{tfOpName:"Pad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"constant_value",name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"PadV2",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"},{start:2,name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"Reshape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"Squeeze",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"axis",tfDeprecatedName:"squeeze_dims",name:"axis",type:"number[]"}]},{tfOpName:"SpaceToBatchND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"paddings",type:"number[]"}]},{tfOpName:"BatchToSpaceND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"crops",type:"number[]"}]},{tfOpName:"DepthToSpace",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"block_size",name:"blockSize",type:"number"},{tfName:"data_format",name:"dataFormat",type:"string"}]},{tfOpName:"BroadcastTo",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}],attrs:[]},{tfOpName:"BroadcastArgs",category:"transformation",inputs:[{start:0,name:"s0",type:"tensor"},{start:1,name:"s1",type:"tensor"}],attrs:[]}]},"9fe6":function(e,t,n){"use strict";n.d(t,"a",(function(){return d}));var r=n("6ae2"),a=n("c05b"),s=n("a3f7"),o=n("6ad5"),i=n("b818"),c=n("54ef"),u=n("35c9");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function l(e,t,n,c,l){const d=Object(s["a"])(e,"x","maxPool"),p=1;let h=d,f=!1;3===d.rank&&(f=!0,h=Object(u["a"])(d,[1,d.shape[0],d.shape[1],d.shape[2]])),o["b"](4===h.rank,()=>`Error in maxPool: input must be rank 4 but got rank ${h.rank}.`),o["b"](i["h"](n,p),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${n} and dilations '${p}'`),null!=l&&o["b"](o["v"](c),()=>`Error in maxPool: pad must be an integer when using, dimRoundingMode ${l} but got pad ${c}.`);const m={x:h},b={filterSize:t,strides:n,pad:c,dimRoundingMode:l},g=r["a"].runKernel(a["Kb"],m,b);return f?Object(u["a"])(g,[g.shape[1],g.shape[2],g.shape[3]]):g}const d=Object(c["b"])({maxPool_:l})},"9ffd":function(e,t,n){"use strict";n.d(t,"a",(function(){return c}));var r=n("6ae2"),a=n("c05b"),s=n("a3f7"),o=n("54ef");
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function i(e){const t=Object(s["a"])(e,"x","softplus"),n={x:t};return r["a"].runKernel(a["Ic"],n)}const c=Object(o["b"])({softplus_:i})},a009:function(e,t,n){"use strict";n.d(t,"a",(function(){return u}));var r=n("6ae2"),a=n("c05b"),s=n("76c2"),o=n("a3f7"),i=n("54ef");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function c(e,t){let n=Object(o["a"])(e,"a","sub"),i=Object(o["a"])(t,"b","sub");[n,i]=Object(s["makeTypesMatch"])(n,i);const c={a:n,b:i};return r["a"].runKernel(a["Yc"],c)}const u=Object(i["b"])({sub_:c})},a09b:function(e,t,n){"use strict";n.d(t,"a",(function(){return c}));var r=n("6ae2"),a=n("c05b"),s=n("a3f7"),o=n("54ef");
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function i(e){const t=Object(s["a"])(e,"x","zerosLike"),n={x:t};return r["a"].runKernel(a["jd"],n)}const c=Object(o["b"])({zerosLike_:i})},a34f:function(e,t,n){"use strict";n.r(t),n.d(t,"validateUpdateShape",(function(){return a})),n.d(t,"validateInput",(function(){return s})),n.d(t,"calculateShapes",(function(){return o}));var r=n("6ad5");function a(e,t,n){const r=t.rank>1?t.shape[t.rank-1]:1,a=t.rank>1?t.rank-1:1,s="Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: "+n.shape+`, indices.shape: ${t.shape}, shape: ${e}`+`, sliceDim: ${r}, and batchDim: ${a}.`;if(n.rank<a)throw new Error(s+` update.rank < ${a}. `);if(e.length<r+(n.rank-a))throw new Error(s+" Output shape length < "+(r+(n.rank-a)));if(n.rank!==a+e.length-r)throw new Error(s+" update.rank != "+(a+e.length-r));for(let o=0;o<a;++o)if(n.shape[o]!==t.shape[o])throw new Error(s+` updates.shape[${o}] (${n.shape[o]}) != indices.shape[${o}] (${t.shape[o]}).`);for(let o=0;o<n.rank-a;++o)if(n.shape[o+a]!==e[o+r])throw new Error(s+` updates.shape[${o+a}] (${n.shape[o+a]}) != shape[${o+a}] (${e[o+a]})`)}function s(e,t,n){if(t.rank<1)throw new Error(`tf.scatterND() expects the indices to be rank 1 or higher, but the rank was ${t.rank}.`);if(e.rank<1)throw new Error(`tf.scatterND() expects the updates to be rank 1 or higher, but the rank was ${e.rank}.`);if("int32"!==t.dtype)throw new Error("The dtype of 'indices' should be int32, but got dtype: "+t.dtype);if(n.length<1)throw new Error("Output rank must be greater or equal to 1, but got shape: "+n);if(0===n.length){if(0===t.size)throw new Error("Indices specified for empty output. indices shape: "+t.shape);if(0===e.size)throw new Error("Updates specified for empty output. updates shape: "+e.shape)}a(n,t,e)}function o(e,t,n){const a=t.shape.length,s=a>1?t.shape[a-1]:1,o=n.length;let i=1;for(let r=s;r<o;++r)i*=n[r];const c=s<1?1:s,u=Object(r["O"])(t.shape)/c,l=[...Object(r["j"])(n.slice(0,s)),1],d=Object(r["O"])(n);return{sliceRank:s,numUpdates:u,sliceSize:i,strides:l,outputSize:d}}},a374:function(e,t,n){"use strict";n.d(t,"a",(function(){return c}));var r=n("6ae2"),a=n("c05b"),s=n("a3f7"),o=n("54ef");
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function i(e){const t=Object(s["a"])(e,"x","acos"),n={x:t};return r["a"].runKernel(a["b"],n)}const c=Object(o["b"])({acos_:i})},a3f7:function(e,t,n){"use strict";n.d(t,"c",(function(){return c})),n.d(t,"a",(function(){return d})),n.d(t,"b",(function(){return p}));var r=n("6ae2"),a=n("b333"),s=n("34d7"),o=n("6ad5"),i=n("eb7e");
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function c(e,t){let n=e;if(Object(o["A"])(e))return"string"===t?[]:[e.length];if(!Array.isArray(e))return[];const r=[];while(Array.isArray(n)||Object(o["A"])(n)&&"string"!==t)r.push(n.length),n=n[0];return Array.isArray(e)&&Object(a["c"])().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")&&u(e,r,[]),r}function u(e,t,n){if(n=n||[],!Array.isArray(e)&&!Object(o["A"])(e))return void Object(o["b"])(0===t.length,()=>`Element arr[${n.join("][")}] is a primitive, but should be an array/TypedArray of ${t[0]} elements`);Object(o["b"])(t.length>0,()=>`Element arr[${n.join("][")}] should be a primitive, but is an array of ${e.length} elements`),Object(o["b"])(e.length===t[0],()=>`Element arr[${n.join("][")}] should have ${t[0]} elements, but has ${e.length} elements`);const r=t.slice(1);for(let a=0;a<e.length;++a)u(e[a],r,n.concat(a))}function l(e,t,n,r){if("string_or_numeric"!==e){if(null==e)throw new Error("Expected dtype cannot be null.");if("numeric"!==e&&e!==t||"numeric"===e&&"string"===t)throw new Error(`Argument '${n}' passed to '${r}' must be ${e} tensor, but got ${t} tensor`)}}function d(e,t,n,a="numeric"){if(e instanceof s["a"])return l(a,e.dtype,t,n),e;let u=Object(o["r"])(e);if("string"!==u&&["bool","int32","float32"].indexOf(a)>=0&&(u=a),l(a,u,t,n),null==e||!Object(o["A"])(e)&&!Array.isArray(e)&&"number"!==typeof e&&"boolean"!==typeof e&&"string"!==typeof e){const r=null==e?"null":e.constructor.name;throw new Error(`Argument '${t}' passed to '${n}' must be a Tensor or TensorLike, but got '${r}'`)}const d=c(e,u);Object(o["A"])(e)||Array.isArray(e)||(e=[e]);const p=!0,h="string"!==u?Object(i["toTypedArray"])(e,u):Object(o["m"])(e,[],p);return r["a"].makeTensor(h,d,u)}function p(e,t,n,r="numeric"){if(!Array.isArray(e))throw new Error(`Argument ${t} passed to ${n} must be a \`Tensor[]\` or \`TensorLike[]\``);const a=e;return a.map((e,a)=>d(e,`${t}[${a}]`,n,r))}},a49d:function(e,t,n){var r;(function(a,s){var o,i=this,c=256,u=6,l=52,d="random",p=s.pow(c,u),h=s.pow(2,l),f=2*h,m=c-1;function b(e,t,n){var r=[];t=1==t?{entropy:!0}:t||{};var o=O(x(t.entropy?[e,w(a)]:null==e?v():e,3),r),i=new g(r),l=function(){var e=i.g(u),t=p,n=0;while(e<h)e=(e+n)*c,t*=c,n=i.g(1);while(e>=f)e/=2,t/=2,n>>>=1;return(e+n)/t};return l.int32=function(){return 0|i.g(4)},l.quick=function(){return i.g(4)/4294967296},l.double=l,O(w(i.S),a),(t.pass||n||function(e,t,n,r){return r&&(r.S&&y(r,i),e.state=function(){return y(i,{})}),n?(s[d]=e,t):e})(l,o,"global"in t?t.global:this==s,t.state)}function g(e){var t,n=e.length,r=this,a=0,s=r.i=r.j=0,o=r.S=[];n||(e=[n++]);while(a<c)o[a]=a++;for(a=0;a<c;a++)o[a]=o[s=m&s+e[a%n]+(t=o[a])],o[s]=t;(r.g=function(e){var t,n=0,a=r.i,s=r.j,o=r.S;while(e--)t=o[a=m&a+1],n=n*c+o[m&(o[a]=o[s=m&s+t])+(o[s]=t)];return r.i=a,r.j=s,n})(c)}function y(e,t){return t.i=e.i,t.j=e.j,t.S=e.S.slice(),t}function x(e,t){var n,r=[],a=typeof e;if(t&&"object"==a)for(n in e)try{r.push(x(e[n],t-1))}catch(s){}return r.length?r:"string"==a?e:e+"\0"}function O(e,t){var n,r=e+"",a=0;while(a<r.length)t[m&a]=m&(n^=19*t[m&a])+r.charCodeAt(a++);return w(t)}function v(){try{var e;return o&&(e=o.randomBytes)?e=e(c):(e=new Uint8Array(c),(i.crypto||i.msCrypto).getRandomValues(e)),w(e)}catch(r){var t=i.navigator,n=t&&t.plugins;return[+new Date,i,n,i.screen,w(a)]}}function w(e){return String.fromCharCode.apply(0,e)}if(s["seed"+d]=b,O(s.random(),a),e.exports){e.exports=b;try{o=n(6)}catch(k){}}else r=function(){return b}.call(t,n,t,e),void 0===r||(e.exports=r)})([],Math)},a49e:function(e,t,n){(function(e){var r;(function(e,a,s){function o(e){var t=this,n="";t.next=function(){var e=t.x^t.x>>>2;return t.x=t.y,t.y=t.z,t.z=t.w,t.w=t.v,(t.d=t.d+362437|0)+(t.v=t.v^t.v<<4^e^e<<1)|0},t.x=0,t.y=0,t.z=0,t.w=0,t.v=0,e===(0|e)?t.x=e:n+=e;for(var r=0;r<n.length+64;r++)t.x^=0|n.charCodeAt(r),r==n.length&&(t.d=t.x<<10^t.x>>>4),t.next()}function i(e,t){return t.x=e.x,t.y=e.y,t.z=e.z,t.w=e.w,t.v=e.v,t.d=e.d,t}function c(e,t){var n=new o(e),r=t&&t.state,a=function(){return(n.next()>>>0)/4294967296};return a.double=function(){do{var e=n.next()>>>11,t=(n.next()>>>0)/4294967296,r=(e+t)/(1<<21)}while(0===r);return r},a.int32=n.next,a.quick=a,r&&("object"==typeof r&&i(r,n),a.state=function(){return i(n,{})}),a}a&&a.exports?a.exports=c:n("07d6")&&n("3c35")?(r=function(){return c}.call(t,n,t,a),void 0===r||(a.exports=r)):this.xorwow=c})(0,e,n("07d6"))}).call(this,n("62e4")(e))},a5aa:function(e,t,n){"use strict";n.d(t,"a",(function(){return u}));var r=n("6ae2"),a=n("c05b"),s=n("76c2"),o=n("a3f7"),i=n("54ef");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function c(e,t){let n=Object(o["a"])(e,"a","mul"),i=Object(o["a"])(t,"b","mul");[n,i]=Object(s["makeTypesMatch"])(n,i);const c={a:n,b:i};return r["a"].runKernel(a["Wb"],c)}const u=Object(i["b"])({mul_:c})},a780:function(e,t,n){"use strict";n.d(t,"a",(function(){return o}));var r=n("0280"),a=n("a3f7");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
async function s(e){const t=Object(a["a"])(e,"condition","whereAsync","bool"),n=await t.data(),s=Object(r["a"])(t.shape,n);return e!==t&&t.dispose(),s}const o=s},a80f:function(e,t,n){"use strict";n.r(t),n.d(t,"json",(function(){return r}));
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const r=[{tfOpName:"Equal",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NotEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Greater",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"GreaterEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Less",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LessEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalAnd",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalNot",category:"logical",inputs:[{start:0,name:"a",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalOr",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Select",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SelectV2",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}]},ae6d:function(e,t,n){"use strict";n.d(t,"a",(function(){return c}));var r=n("6ae2"),a=n("c05b"),s=n("a3f7"),o=n("54ef");
/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function i(e,t=null,n=!1){const o=Object(s["a"])(e,"x","min"),i={x:o},c={axis:t,keepDims:n};return r["a"].runKernel(a["Rb"],i,c)}const c=Object(o["b"])({min_:i})},aeab:function(e,t,n){"use strict";n.r(t),n.d(t,"json",(function(){return r}));
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const r=[{tfOpName:"Add",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddV2",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddN",category:"arithmetic",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"BiasAdd",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"Sub",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"RealDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Div",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"DivNoNan",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mul",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Maximum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Minimum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Pow",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SquaredDifference",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorMod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}]},b21c:function(e,t,n){"use strict";n.d(t,"a",(function(){return l}));var r=n("6ae2"),a=n("c05b"),s=n("76c2"),o=n("a3f7"),i=n("526f"),c=n("54ef");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function u(e,t){let n=Object(o["a"])(e,"a","lessEqual","string_or_numeric"),c=Object(o["a"])(t,"b","lessEqual","string_or_numeric");[n,c]=Object(s["makeTypesMatch"])(n,c),Object(i["a"])(n.shape,c.shape);const u={a:n,b:c};return r["a"].runKernel(a["Bb"],u)}const l=Object(c["b"])({lessEqual_:u})},b294:function(e,t,n){"use strict";n.d(t,"b",(function(){return a})),n.d(t,"a",(function(){return s}));var r=n("b333");
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function a(...e){Object(r["c"])().getBool("IS_TEST")||Object(r["c"])().getBool("PROD")||console.warn(...e)}function s(...e){Object(r["c"])().getBool("IS_TEST")||Object(r["c"])().getBool("PROD")||console.log(...e)}},b333:function(e,t,n){"use strict";n.d(t,"b",(function(){return o})),n.d(t,"c",(function(){return l})),n.d(t,"a",(function(){return d})),n.d(t,"d",(function(){return p}));var r=n("6ad5"),a=n("b294");
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const s="tfjsflags";class o{constructor(e){this.global=e,this.flags={},this.flagRegistry={},this.urlFlags={},this.getQueryParams=i,this.populateURLFlags()}setPlatform(e,t){null!=this.platform&&a["b"](`Platform ${this.platformName} has already been set. Overwriting the platform with ${t}.`),this.platformName=e,this.platform=t}registerFlag(e,t,n){if(this.flagRegistry[e]={evaluationFn:t,setHook:n},null!=this.urlFlags[e]){const t=this.urlFlags[e];a["b"](`Setting feature override from URL ${e}: ${t}.`),this.set(e,t)}}async getAsync(e){return e in this.flags||(this.flags[e]=await this.evaluateFlag(e)),this.flags[e]}get(e){if(e in this.flags)return this.flags[e];const t=this.evaluateFlag(e);if(Object(r["x"])(t))throw new Error(`Flag ${e} cannot be synchronously evaluated. Please use getAsync() instead.`);return this.flags[e]=t,this.flags[e]}getNumber(e){return this.get(e)}getBool(e){return this.get(e)}getFlags(){return this.flags}get features(){return this.flags}set(e,t){if(null==this.flagRegistry[e])throw new Error(`Cannot set flag ${e} as it has not been registered.`);this.flags[e]=t,null!=this.flagRegistry[e].setHook&&this.flagRegistry[e].setHook(t)}evaluateFlag(e){if(null==this.flagRegistry[e])throw new Error(`Cannot evaluate flag '${e}': no evaluation function found.`);return this.flagRegistry[e].evaluationFn()}setFlags(e){this.flags=Object.assign({},e)}reset(){this.flags={},this.urlFlags={},this.populateURLFlags()}populateURLFlags(){if("undefined"===typeof this.global||"undefined"===typeof this.global.location||"undefined"===typeof this.global.location.search)return;const e=this.getQueryParams(this.global.location.search);if(s in e){const t=e[s].split(",");t.forEach(e=>{const[t,n]=e.split(":");this.urlFlags[t]=u(t,n)})}}}function i(e){const t={};return e.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,(e,...n)=>(c(t,n[0],n[1]),n.join("="))),t}function c(e,t,n){e[decodeURIComponent(t)]=decodeURIComponent(n||"")}function u(e,t){if(t=t.toLowerCase(),"true"===t||"false"===t)return"true"===t;if(""+ +t===t)return+t;throw new Error(`Could not parse value flag value ${t} for flag ${e}.`)}function l(){return d}let d=null;function p(e){d=e}},b39e:function(e,t,n){"use strict";n.d(t,"a",(function(){return c}));var r=n("6ae2"),a=n("c05b"),s=n("a3f7"),o=n("54ef");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function i(e){const t=Object(s["a"])(e,"x","selu"),n={x:t};return r["a"].runKernel(a["Bc"],n)}const c=Object(o["b"])({selu_:i})},b500:function(e,t,n){"use strict";n.d(t,"a",(function(){return c}));var r=n("6ae2"),a=n("c05b"),s=n("a3f7"),o=n("54ef");
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function i(e){const t=Object(s["a"])(e,"x","reciprocal"),n={x:t};return r["a"].runKernel(a["nc"],n)}const c=Object(o["b"])({reciprocal_:i})},b61d:function(e,t,n){"use strict";n.d(t,"a",(function(){return b}));var r=n("6ad5"),a=n("0777"),s=n("649e"),o=n("24b0"),i=n("54ef"),c=n("d7b0"),u=n("35c9"),l=n("6d3c"),d=n("45bb"),p=n("5a2c"),h=n("a09b"),f=n("1ab7");
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function m(e,t){Object(r["b"])("float32"===e.dtype,()=>"The dtype for rfft() must be real value but got "+e.dtype);let n=e.shape[e.shape.length-1];const i=e.size/n;let m;if(null!=t&&t<n){const r=e.shape.map(e=>0),a=e.shape.map(e=>e);a[e.shape.length-1]=t,m=Object(l["a"])(e,r,a),n=t}else if(null!=t&&t>n){const r=e.shape.map(e=>e);r[e.shape.length-1]=t-n,m=Object(s["a"])([e,Object(p["a"])(r)],e.shape.length-1),n=t}else m=e;const b=Object(h["a"])(m),g=Object(u["a"])(Object(a["a"])(m,b),[i,n]),y=Object(f["a"])(g),x=Math.floor(n/2)+1,O=Object(c["a"])(y),v=Object(o["a"])(y),w=Object(d["a"])(O,[x,n-x],O.shape.length-1),k=Object(d["a"])(v,[x,n-x],v.shape.length-1),j=m.shape.slice();return j[m.shape.length-1]=x,Object(u["a"])(Object(a["a"])(w[0],k[0]),j)}const b=Object(i["b"])({rfft_:m})},b818:function(e,t,n){"use strict";
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function r(e,t,n,r,a="NHWC",s){const i=e[3],c=[...t,i],u=x(a);return o(e,c,n,s,r,null,null,u)}function a(e,t,n,r,a,s,i="channelsLast"){const[c,u]=d(t);let l;if("channelsLast"===i)l=[c,u,e[3],e[3]];else{if("channelsFirst"!==i)throw new Error("Unknown dataFormat "+i);l=[c,u,e[1],e[1]]}return o(e,l,n,r,a,s,!1,i)}function s(e,t,n,r,a,s,o="NDHWC"){const[c,u,l]=p(t);let d,h;if("NDHWC"===o)h="channelsLast",d=[c,u,l,e[4],e[4]];else{if("NCDHW"!==o)throw new Error("Unknown dataFormat "+o);h="channelsFirst",d=[c,u,l,e[1],e[1]]}return i(e,d,n,r,a,!1,h,s)}function o(e,t,n,r,a,s,o=!1,i="channelsLast"){let[c,u,l,p]=[-1,-1,-1,-1];if("channelsLast"===i)[c,u,l,p]=e;else{if("channelsFirst"!==i)throw new Error("Unknown dataFormat "+i);[c,p,u,l]=e}const[m,b,,g]=t,[y,x]=d(n),[O,v]=d(r),w=h(m,O),k=h(b,v),{padInfo:j,outHeight:S,outWidth:N}=f(a,u,l,y,x,w,k,s,i),C=o?g*p:g;let I;return"channelsFirst"===i?I=[c,C,S,N]:"channelsLast"===i&&(I=[c,S,N,C]),{batchSize:c,dataFormat:i,inHeight:u,inWidth:l,inChannels:p,outHeight:S,outWidth:N,outChannels:C,padInfo:j,strideHeight:y,strideWidth:x,filterHeight:m,filterWidth:b,effectiveFilterHeight:w,effectiveFilterWidth:k,dilationHeight:O,dilationWidth:v,inShape:e,outShape:I,filterShape:t}}function i(e,t,n,r,a,s=!1,o="channelsLast",i){let[c,u,l,d,f]=[-1,-1,-1,-1,-1];if("channelsLast"===o)[c,u,l,d,f]=e;else{if("channelsFirst"!==o)throw new Error("Unknown dataFormat "+o);[c,f,u,l,d]=e}const[b,g,y,,x]=t,[O,v,w]=p(n),[k,j,S]=p(r),N=h(b,k),C=h(g,j),I=h(y,S),{padInfo:T,outDepth:$,outHeight:E,outWidth:A}=m(a,u,l,d,O,v,w,N,C,I,i),R=s?x*f:x;let _;return"channelsFirst"===o?_=[c,R,$,E,A]:"channelsLast"===o&&(_=[c,$,E,A,R]),{batchSize:c,dataFormat:o,inDepth:u,inHeight:l,inWidth:d,inChannels:f,outDepth:$,outHeight:E,outWidth:A,outChannels:R,padInfo:T,strideDepth:O,strideHeight:v,strideWidth:w,filterDepth:b,filterHeight:g,filterWidth:y,effectiveFilterDepth:N,effectiveFilterHeight:C,effectiveFilterWidth:I,dilationDepth:k,dilationHeight:j,dilationWidth:S,inShape:e,outShape:_,filterShape:t}}function c(e,t,n,r,a){null==r&&(r=l(e,t,n));const s=e[0],o=e[1],i=b((s-t+2*r)/n+1,a),c=b((o-t+2*r)/n+1,a);return[i,c]}function u(e,t,n,r,a,s){null==a&&(a=l(e,t,r));const o=e[0],i=e[1],c=e[2],u=b((o-t+2*a)/r+1,s),d=b((i-t+2*a)/r+1,s),p=b((c-t+2*a)/r+1,s);return[u,d,p,n]}function l(e,t,n,r=1){const a=h(t,r);return Math.floor((e[0]*(n-1)-n+a)/2)}function d(e){return"number"===typeof e?[e,e,e]:2===e.length?[e[0],e[1],1]:e}function p(e){return"number"===typeof e?[e,e,e]:e}function h(e,t){return t<=1?e:e+(e-1)*(t-1)}function f(e,t,n,r,a,s,o,i,u){let l,d,p;if("number"===typeof e){const a=0===e?"VALID":"NUMBER";l={top:e,bottom:e,left:e,right:e,type:a};const o=c([t,n],s,r,e,i);d=o[0],p=o[1]}else if("same"===e){d=Math.ceil(t/r),p=Math.ceil(n/a);const e=Math.max(0,(d-1)*r+s-t),i=Math.max(0,(p-1)*a+o-n),c=Math.floor(e/2),u=e-c,h=Math.floor(i/2),f=i-h;l={top:c,bottom:u,left:h,right:f,type:"SAME"}}else if("valid"===e)l={top:0,bottom:0,left:0,right:0,type:"VALID"},d=Math.ceil((t-s+1)/r),p=Math.ceil((n-o+1)/a);else{if("object"!==typeof e)throw Error("Unknown padding parameter: "+e);{const c="channelsLast"===u?e[1][0]:e[2][0],h="channelsLast"===u?e[1][1]:e[2][1],f="channelsLast"===u?e[2][0]:e[3][0],m="channelsLast"===u?e[2][1]:e[3][1],g=0===c&&0===h&&0===f&&0===m?"VALID":"EXPLICIT";l={top:c,bottom:h,left:f,right:m,type:g},d=b((t-s+c+h)/r+1,i),p=b((n-o+f+m)/a+1,i)}}return{padInfo:l,outHeight:d,outWidth:p}}function m(e,t,n,r,a,s,o,i,c,l,d){let p,h,f,m;if("number"===typeof e){const s=0===e?"VALID":"NUMBER";p={top:e,bottom:e,left:e,right:e,front:e,back:e,type:s};const o=u([t,n,r,1],i,1,a,e,d);h=o[0],f=o[1],m=o[2]}else if("same"===e){h=Math.ceil(t/a),f=Math.ceil(n/s),m=Math.ceil(r/o);const e=(h-1)*a+i-t,u=(f-1)*s+c-n,d=(m-1)*o+l-r,b=Math.floor(e/2),g=e-b,y=Math.floor(u/2),x=u-y,O=Math.floor(d/2),v=d-O;p={top:y,bottom:x,left:O,right:v,front:b,back:g,type:"SAME"}}else{if("valid"!==e)throw Error("Unknown padding parameter: "+e);p={top:0,bottom:0,left:0,right:0,front:0,back:0,type:"VALID"},h=Math.ceil((t-i+1)/a),f=Math.ceil((n-c+1)/s),m=Math.ceil((r-l+1)/o)}return{padInfo:p,outDepth:h,outHeight:f,outWidth:m}}function b(e,t){if(!t)return Math.trunc(e);switch(t){case"round":return Math.round(e);case"ceil":return Math.ceil(e);case"floor":return Math.floor(e);default:throw new Error("Unknown roundingMode "+t)}}function g(e){const[t,n,r]=d(e);return 1===t&&1===n&&1===r}function y(e,t){return g(e)||g(t)}function x(e){if("NHWC"===e)return"channelsLast";if("NCHW"===e)return"channelsFirst";throw new Error("Unknown dataFormat "+e)}n.d(t,"d",(function(){return r})),n.d(t,"e",(function(){return a})),n.d(t,"f",(function(){return s})),n.d(t,"a",(function(){return o})),n.d(t,"b",(function(){return i})),n.d(t,"c",(function(){return l})),n.d(t,"i",(function(){return g})),n.d(t,"h",(function(){return y})),n.d(t,"g",(function(){return x}))},b838:function(e,t,n){(function(e){var r;(function(e,a,s){function o(e){var t=this,n="";t.x=0,t.y=0,t.z=0,t.w=0,t.next=function(){var e=t.x^t.x<<11;return t.x=t.y,t.y=t.z,t.z=t.w,t.w^=t.w>>>19^e^e>>>8},e===(0|e)?t.x=e:n+=e;for(var r=0;r<n.length+64;r++)t.x^=0|n.charCodeAt(r),t.next()}function i(e,t){return t.x=e.x,t.y=e.y,t.z=e.z,t.w=e.w,t}function c(e,t){var n=new o(e),r=t&&t.state,a=function(){return(n.next()>>>0)/4294967296};return a.double=function(){do{var e=n.next()>>>11,t=(n.next()>>>0)/4294967296,r=(e+t)/(1<<21)}while(0===r);return r},a.int32=n.next,a.quick=a,r&&("object"==typeof r&&i(r,n),a.state=function(){return i(n,{})}),a}a&&a.exports?a.exports=c:n("07d6")&&n("3c35")?(r=function(){return c}.call(t,n,t,a),void 0===r||(a.exports=r)):this.xor128=c})(0,e,n("07d6"))}).call(this,n("62e4")(e))},b9b9:function(e,t,n){"use strict";n.d(t,"a",(function(){return l}));var r=n("6ae2"),a=n("c05b"),s=n("76c2"),o=n("a3f7"),i=n("526f"),c=n("54ef");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function u(e,t){let n=Object(o["a"])(e,"a","equal","string_or_numeric"),c=Object(o["a"])(t,"b","equal","string_or_numeric");[n,c]=Object(s["makeTypesMatch"])(n,c),Object(i["a"])(n.shape,c.shape);const u={a:n,b:c};return r["a"].runKernel(a["Z"],u)}const l=Object(c["b"])({equal_:u})},ba40:function(e,t,n){"use strict";n.d(t,"a",(function(){return c}));var r=n("6ae2"),a=n("c05b"),s=n("a3f7"),o=n("54ef");
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function i(e,t){const n=Object(s["a"])(t,"indices","gatherND","int32"),o=Object(s["a"])(e,"x","gatherND","string_or_numeric"),i={params:o,indices:n};return r["a"].runKernel(a["nb"],i)}const c=Object(o["b"])({gatherND_:i})},ba53:function(e,t,n){"use strict";n.d(t,"a",(function(){return d}));var r=n("6ae2"),a=n("c05b"),s=n("a3f7"),o=n("6ad5"),i=n("deb3"),c=n("54ef"),u=n("35c9");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function l(e,t,n,c,l,d="NDHWC"){const p=Object(s["a"])(e,"x","avgPool3d","float32");let h=p,f=!1;4===p.rank&&(f=!0,h=Object(u["a"])(p,[1,p.shape[0],p.shape[1],p.shape[2],p.shape[3]])),o["b"](5===h.rank,()=>`Error in avgPool3d: x must be rank 5 but got rank ${h.rank}.`),o["b"]("NDHWC"===d,()=>"Error in avgPool3d: Only NDHWC is currently supported, but got dataFormat of "+d),null!=l&&o["b"](o["v"](c),()=>`Error in avgPool3d: pad must be an integer when using, dimRoundingMode ${l} but got pad ${c}.`);const m={x:h},b={filterSize:t,strides:n,pad:c,dimRoundingMode:l,dataFormat:d};let g=r["a"].runKernel(a["p"],m,b);return g=Object(i["a"])(g,h.dtype),f?Object(u["a"])(g,[g.shape[1],g.shape[2],g.shape[3],g.shape[4]]):g}const d=Object(c["b"])({avgPool3d_:l})},bb2d:function(e,t,n){"use strict";n.d(t,"a",(function(){return l}));var r=n("6ae2"),a=n("c05b"),s=n("76c2"),o=n("a3f7"),i=n("526f"),c=n("54ef");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function u(e,t){let n=Object(o["a"])(e,"a","greaterEqual","string_or_numeric"),c=Object(o["a"])(t,"b","greaterEqual","string_or_numeric");[n,c]=Object(s["makeTypesMatch"])(n,c),Object(i["a"])(n.shape,c.shape);const u={a:n,b:c};return r["a"].runKernel(a["qb"],u)}const l=Object(c["b"])({greaterEqual_:u})},bc62:function(e,t,n){"use strict";n.d(t,"a",(function(){return u}));var r=n("6ae2"),a=n("c05b");function s(e,t,n,r){if("int32"!==e.dtype)throw new Error(`tf.sparseToDense() expects the indices to be int32 type, but the dtype was ${e.dtype}.`);if(e.rank>2)throw new Error(`sparseIndices should be a scalar, vector, or matrix, but got shape ${e.shape}.`);const a=e.rank>0?e.shape[0]:1,s=e.rank>1?e.shape[1]:1;if(n.length!==s)throw new Error(`outputShape has incorrect number of elements:, ${n.length}, should be: ${s}.`);const o=t.size;if(0!==t.rank&&(1!==t.rank||o!==a))throw new Error(`sparseValues has incorrect shape ${t.shape}, should be [] or [${a}]`);if(t.dtype!==r.dtype)throw new Error("sparseValues.dtype must match defaultValues.dtype")}var o=n("a3f7"),i=n("54ef");
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function c(e,t,n,i=0){const c=Object(o["a"])(e,"sparseIndices","sparseToDense","int32"),u=Object(o["a"])(t,"sparseValues","sparseToDense"),l=Object(o["a"])(i,"defaultValue","sparseToDense",u.dtype);s(c,u,n,l);const d={sparseIndices:c,sparseValues:u,defaultValue:l},p={outputShape:n};return r["a"].runKernel(a["Oc"],d,p)}const u=Object(i["b"])({sparseToDense_:c})},c021:function(e,t,n){"use strict";n.d(t,"a",(function(){return c}));var r=n("6ae2"),a=n("c05b"),s=n("a3f7"),o=n("54ef");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function i(e,t=null,n=!1){const o=Object(s["a"])(e,"x","max"),i={x:o},c={reductionIndices:t,keepDims:n};return r["a"].runKernel(a["Jb"],i,c)}const c=Object(o["b"])({max_:i})},c04e4:function(e,t,n){"use strict";n.d(t,"g",(function(){return i})),n.d(t,"f",(function(){return c})),n.d(t,"c",(function(){return u})),n.d(t,"b",(function(){return l})),n.d(t,"e",(function(){return d})),n.d(t,"h",(function(){return p})),n.d(t,"m",(function(){return h})),n.d(t,"n",(function(){return f})),n.d(t,"t",(function(){return m})),n.d(t,"d",(function(){return b})),n.d(t,"l",(function(){return g})),n.d(t,"u",(function(){return y})),n.d(t,"r",(function(){return x})),n.d(t,"o",(function(){return O})),n.d(t,"k",(function(){return v})),n.d(t,"q",(function(){return w})),n.d(t,"i",(function(){return k})),n.d(t,"j",(function(){return j})),n.d(t,"p",(function(){return S})),n.d(t,"a",(function(){return N})),n.d(t,"s",(function(){return C}));var r=n("6ae2"),a=n("b333"),s=n("34d7"),o=n("76c2");
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function i(){Object(a["c"])().set("PROD",!0)}function c(){Object(a["c"])().set("DEBUG",!0)}function u(){Object(a["c"])().set("DEPRECATION_WARNINGS_ENABLED",!1),console.warn("TensorFlow.js deprecation warnings have been disabled.")}function l(e){Object(a["c"])().getBool("DEPRECATION_WARNINGS_ENABLED")&&console.warn(e+" You can disable deprecation warnings with tf.disableDeprecationWarnings().")}function d(){r["a"].disposeVariables()}function p(){return r["a"]}function h(){return r["a"].memory()}function f(e){return r["a"].profile(e)}function m(e,t){return r["a"].tidy(e,t)}function b(e){const t=Object(o["getTensorsInContainer"])(e);t.forEach(e=>e.dispose())}function g(e){return r["a"].keep(e)}function y(e){return r["a"].time(e)}function x(e){return r["a"].setBackend(e)}function O(){return r["a"].ready()}function v(){return r["a"].backendName}function w(e){r["a"].removeBackend(e)}function k(e){return r["a"].findBackend(e)}function j(e){return r["a"].findBackendFactory(e)}function S(e,t,n=1){return r["a"].registerBackend(e,t,n)}function N(){return r["a"].backend}function C(e,t){Object(a["c"])().setPlatform(e,t)}Object(s["d"])(l)},c05b:function(e,t,n){"use strict";n.d(t,"a",(function(){return r})),n.d(t,"b",(function(){return a})),n.d(t,"c",(function(){return s})),n.d(t,"d",(function(){return o})),n.d(t,"e",(function(){return i})),n.d(t,"f",(function(){return c})),n.d(t,"g",(function(){return u})),n.d(t,"h",(function(){return l})),n.d(t,"i",(function(){return d})),n.d(t,"j",(function(){return p})),n.d(t,"k",(function(){return h})),n.d(t,"l",(function(){return f})),n.d(t,"n",(function(){return m})),n.d(t,"m",(function(){return b})),n.d(t,"o",(function(){return g})),n.d(t,"r",(function(){return y})),n.d(t,"p",(function(){return x})),n.d(t,"q",(function(){return O})),n.d(t,"s",(function(){return v})),n.d(t,"t",(function(){return w})),n.d(t,"u",(function(){return k})),n.d(t,"w",(function(){return j})),n.d(t,"v",(function(){return S})),n.d(t,"x",(function(){return N})),n.d(t,"y",(function(){return C})),n.d(t,"z",(function(){return I})),n.d(t,"A",(function(){return T})),n.d(t,"B",(function(){return $})),n.d(t,"C",(function(){return E})),n.d(t,"D",(function(){return A})),n.d(t,"E",(function(){return R})),n.d(t,"F",(function(){return _})),n.d(t,"G",(function(){return F})),n.d(t,"H",(function(){return D})),n.d(t,"I",(function(){return M})),n.d(t,"J",(function(){return L})),n.d(t,"K",(function(){return P})),n.d(t,"M",(function(){return B})),n.d(t,"L",(function(){return V})),n.d(t,"N",(function(){return z})),n.d(t,"O",(function(){return W})),n.d(t,"P",(function(){return U})),n.d(t,"Q",(function(){return G})),n.d(t,"R",(function(){return H})),n.d(t,"S",(function(){return q})),n.d(t,"T",(function(){return K})),n.d(t,"V",(function(){return X})),n.d(t,"U",(function(){return Y})),n.d(t,"mc",(function(){return Q})),n.d(t,"W",(function(){return Z})),n.d(t,"X",(function(){return J})),n.d(t,"Y",(function(){return ee})),n.d(t,"ab",(function(){return te})),n.d(t,"Z",(function(){return ne})),n.d(t,"bb",(function(){return re})),n.d(t,"cb",(function(){return ae})),n.d(t,"db",(function(){return se})),n.d(t,"eb",(function(){return oe})),n.d(t,"fb",(function(){return ie})),n.d(t,"gb",(function(){return ce})),n.d(t,"hb",(function(){return ue})),n.d(t,"ib",(function(){return le})),n.d(t,"kb",(function(){return de})),n.d(t,"ob",(function(){return pe})),n.d(t,"nb",(function(){return he})),n.d(t,"pb",(function(){return fe})),n.d(t,"qb",(function(){return me})),n.d(t,"sb",(function(){return be})),n.d(t,"rb",(function(){return ge})),n.d(t,"tb",(function(){return ye})),n.d(t,"ub",(function(){return xe})),n.d(t,"vb",(function(){return Oe})),n.d(t,"wb",(function(){return ve})),n.d(t,"zb",(function(){return we})),n.d(t,"Ab",(function(){return ke})),n.d(t,"Bb",(function(){return je})),n.d(t,"Cb",(function(){return Se})),n.d(t,"Db",(function(){return Ne})),n.d(t,"Eb",(function(){return Ce})),n.d(t,"Gb",(function(){return Ie})),n.d(t,"Hb",(function(){return Te})),n.d(t,"Ib",(function(){return $e})),n.d(t,"Fb",(function(){return Ee})),n.d(t,"xb",(function(){return Ae})),n.d(t,"yb",(function(){return Re})),n.d(t,"Jb",(function(){return _e})),n.d(t,"Pb",(function(){return Fe})),n.d(t,"Kb",(function(){return De})),n.d(t,"Nb",(function(){return Me})),n.d(t,"Lb",(function(){return Le})),n.d(t,"Mb",(function(){return Pe})),n.d(t,"Ob",(function(){return Be})),n.d(t,"Qb",(function(){return Ve})),n.d(t,"Rb",(function(){return ze})),n.d(t,"Sb",(function(){return We})),n.d(t,"Tb",(function(){return Ue})),n.d(t,"Ub",(function(){return Ge})),n.d(t,"Vb",(function(){return He})),n.d(t,"Wb",(function(){return qe})),n.d(t,"Xb",(function(){return Ke})),n.d(t,"bc",(function(){return Xe})),n.d(t,"Yb",(function(){return Ye})),n.d(t,"Zb",(function(){return Qe})),n.d(t,"ac",(function(){return Ze})),n.d(t,"dc",(function(){return Je})),n.d(t,"cc",(function(){return et})),n.d(t,"ec",(function(){return tt})),n.d(t,"fc",(function(){return nt})),n.d(t,"gc",(function(){return rt})),n.d(t,"hc",(function(){return at})),n.d(t,"ic",(function(){return st})),n.d(t,"jc",(function(){return ot})),n.d(t,"kc",(function(){return it})),n.d(t,"lc",(function(){return ct})),n.d(t,"nc",(function(){return ut})),n.d(t,"oc",(function(){return lt})),n.d(t,"qc",(function(){return dt})),n.d(t,"tc",(function(){return pt})),n.d(t,"uc",(function(){return ht})),n.d(t,"rc",(function(){return ft})),n.d(t,"sc",(function(){return mt})),n.d(t,"pc",(function(){return bt})),n.d(t,"vc",(function(){return gt})),n.d(t,"xc",(function(){return yt})),n.d(t,"yc",(function(){return xt})),n.d(t,"zc",(function(){return Ot})),n.d(t,"Ac",(function(){return vt})),n.d(t,"Bc",(function(){return wt})),n.d(t,"Gc",(function(){return kt})),n.d(t,"Ec",(function(){return jt})),n.d(t,"Fc",(function(){return St})),n.d(t,"Dc",(function(){return Nt})),n.d(t,"Cc",(function(){return Ct})),n.d(t,"Ic",(function(){return It})),n.d(t,"Qc",(function(){return Tt})),n.d(t,"Zc",(function(){return $t})),n.d(t,"Jc",(function(){return Et})),n.d(t,"Pc",(function(){return At})),n.d(t,"Hc",(function(){return Rt})),n.d(t,"Kc",(function(){return _t})),n.d(t,"Lc",(function(){return Ft})),n.d(t,"Mc",(function(){return Dt})),n.d(t,"Nc",(function(){return Mt})),n.d(t,"Oc",(function(){return Lt})),n.d(t,"Sc",(function(){return Pt})),n.d(t,"Rc",(function(){return Bt})),n.d(t,"Uc",(function(){return Vt})),n.d(t,"Vc",(function(){return zt})),n.d(t,"Wc",(function(){return Wt})),n.d(t,"Xc",(function(){return Ut})),n.d(t,"Yc",(function(){return Gt})),n.d(t,"ad",(function(){return Ht})),n.d(t,"bd",(function(){return qt})),n.d(t,"cd",(function(){return Kt})),n.d(t,"dd",(function(){return Xt})),n.d(t,"ed",(function(){return Yt})),n.d(t,"fd",(function(){return Qt})),n.d(t,"gd",(function(){return Zt})),n.d(t,"hd",(function(){return Jt})),n.d(t,"id",(function(){return en})),n.d(t,"jd",(function(){return tn})),n.d(t,"Tc",(function(){return nn})),n.d(t,"jb",(function(){return rn})),n.d(t,"wc",(function(){return an})),n.d(t,"kd",(function(){return sn})),n.d(t,"lb",(function(){return on})),n.d(t,"mb",(function(){return cn}));const r="Abs",a="Acos",s="Acosh",o="Add",i="AddN",c="All",u="Any",l="ArgMax",d="ArgMin",p="Asin",h="Asinh",f="Atan",m="Atanh",b="Atan2",g="AvgPool",y="AvgPoolGrad",x="AvgPool3D",O="AvgPool3DGrad",v="BatchMatMul",w="BatchToSpaceND",k="Bincount",j="BroadcastTo",S="BroadcastArgs",N="Cast",C="Ceil",I="ClipByValue",T="Complex",$="ComplexAbs",E="Concat",A="Conv2D",R="Conv2DBackpropFilter",_="Conv2DBackpropInput",F="Conv3D",D="Conv3DBackpropFilterV2",M="Conv3DBackpropInputV2",L="Cos",P="Cosh",B="Cumsum",V="CropAndResize",z="DenseBincount",W="DepthToSpace",U="DepthwiseConv2dNative",G="DepthwiseConv2dNativeBackpropFilter",H="DepthwiseConv2dNativeBackpropInput",q="Diag",K="Dilation2D",X="Dilation2DBackpropInput",Y="Dilation2DBackpropFilter",Q="RealDiv",Z="Einsum",J="Elu",ee="EluGrad",te="Erf",ne="Equal",re="Exp",ae="ExpandDims",se="Expm1",oe="FFT",ie="Fill",ce="FlipLeftRight",ue="Floor",le="FloorDiv",de="FusedBatchNorm",pe="GatherV2",he="GatherNd",fe="Greater",me="GreaterEqual",be="Identity",ge="IFFT",ye="Imag",xe="IsFinite",Oe="IsInf",ve="IsNan",we="LeakyRelu",ke="Less",je="LessEqual",Se="LinSpace",Ne="Log",Ce="Log1p",Ie="LogicalAnd",Te="LogicalNot",$e="LogicalOr",Ee="LogSoftmax",Ae="LRN",Re="LRNGrad",_e="Max",Fe="Maximum",De="MaxPool",Me="MaxPoolGrad",Le="MaxPool3D",Pe="MaxPool3DGrad",Be="MaxPoolWithArgmax",Ve="Mean",ze="Min",We="Minimum",Ue="MirrorPad",Ge="Mod",He="Multinomial",qe="Multiply",Ke="Neg",Xe="NotEqual",Ye="NonMaxSuppressionV3",Qe="NonMaxSuppressionV4",Ze="NonMaxSuppressionV5",Je="OnesLike",et="OneHot",tt="Pack",nt="PadV2",rt="Pool",at="Pow",st="Prelu",ot="Prod",it="Range",ct="Real",ut="Reciprocal",lt="Relu",dt="Reshape",pt="ResizeNearestNeighbor",ht="ResizeNearestNeighborGrad",ft="ResizeBilinear",mt="ResizeBilinearGrad",bt="Relu6",gt="Reverse",yt="Round",xt="Rsqrt",Ot="ScatterNd",vt="Select",wt="Selu",kt="Slice",jt="Sin",St="Sinh",Nt="Sign",Ct="Sigmoid",It="Softplus",Tt="Sqrt",$t="Sum",Et="SpaceToBatchND",At="SplitV",Rt="Softmax",_t="SparseFillEmptyRows",Ft="SparseReshape",Dt="SparseSegmentMean",Mt="SparseSegmentSum",Lt="SparseToDense",Pt="SquaredDifference",Bt="Square",Vt="StridedSlice",zt="StringNGrams",Wt="StringSplit",Ut="StringToHashBucketFast",Gt="Sub",Ht="Tan",qt="Tanh",Kt="Tile",Xt="TopK",Yt="Transform",Qt="Transpose",Zt="Unique",Jt="Unpack",en="UnsortedSegmentSum",tn="ZerosLike",nn="Step",rn="FromPixels",an="RotateWithOffset",sn="_FusedMatMul",on="FusedConv2D",cn="FusedDepthwiseConv2D"},c08f:function(e,t,n){"use strict";n.d(t,"a",(function(){return u}));var r=n("6ae2"),a=n("c05b"),s=n("a3f7"),o=n("6ad5"),i=n("54ef");
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function c(e,t,n){const i=Object(s["a"])(e,"x","clipByValue");o["b"](t<=n,()=>`Error in clip: min (${t}) must be less than or equal to max (${n}).`);const c={x:i},u={clipValueMin:t,clipValueMax:n};return r["a"].runKernel(a["z"],c,u)}const u=Object(i["b"])({clipByValue_:c})},c170:function(e,t,n){"use strict";n.d(t,"a",(function(){return l}));var r=n("6ae2"),a=n("c05b"),s=n("a3f7"),o=n("6ad5"),i=n("54ef"),c=n("35c9");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function u(e,t,n,i,u=[1,1],l="NHWC"){const d=Object(s["a"])(e,"x","dilation2d"),p=Object(s["a"])(t,"filter","dilation2d");o["b"](3===d.rank||4===d.rank,()=>"Error in dilation2d: input must be rank 3 or 4, but got rank "+d.rank+"."),o["b"](3===p.rank,()=>"Error in dilation2d: filter must be rank 3, but got rank "+p.rank+"."),o["b"]("NHWC"===l,()=>"Error in dilation2d: Only NHWC is currently supported, but got dataFormat of "+l);let h=d,f=!1;3===d.rank&&(h=Object(c["a"])(d,[1,d.shape[0],d.shape[1],d.shape[2]]),f=!0);const m={x:h,filter:p},b={strides:n,pad:i,dilations:u},g=r["a"].runKernel(a["T"],m,b);return f?Object(c["a"])(g,[g.shape[1],g.shape[2],g.shape[3]]):g}const l=Object(i["b"])({dilation2d_:u})},c1a2:function(e,t,n){"use strict";n.d(t,"a",(function(){return c}));var r=n("6ae2"),a=n("c05b"),s=n("a3f7"),o=n("54ef");
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function i(e){const t=Object(s["a"])(e,"x","cosh"),n={x:t};return r["a"].runKernel(a["K"],n)}const c=Object(o["b"])({cosh_:i})},c22a:function(e,t,n){"use strict";n.d(t,"a",(function(){return i}));var r=n("6ae2"),a=n("6ad5"),s=n("0777"),o=n("5a2c");
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function i(e,t="float32"){if("complex64"===t){const t=i(e,"float32"),n=Object(o["a"])(e,"float32");return Object(s["a"])(t,n)}const n=Object(a["D"])(Object(a["O"])(e),t);return r["a"].makeTensor(n,e,t)}},c77c:function(e,t,n){"use strict";n.d(t,"a",(function(){return l}));var r=n("6ae2"),a=n("c05b"),s=n("76c2"),o=n("a3f7"),i=n("508f"),c=n("54ef");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function u(e,t){let n=Object(o["a"])(e,"a","div"),c=Object(o["a"])(t,"b","div");if([n,c]=Object(s["makeTypesMatch"])(n,c),"int32"===n.dtype&&"int32"===c.dtype)return Object(i["a"])(n,c);const u={a:n,b:c},l={};return r["a"].runKernel(a["mc"],u,l)}const l=Object(c["b"])({div_:u})},c8ad:function(e,t,n){"use strict";n.r(t),n.d(t,"json",(function(){return r}));
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const r=[{tfOpName:"Abs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan2",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Ceil",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ClipByValue",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"clipValueMin",type:"number"},{start:2,name:"clipValueMax",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Complex",category:"basic_math",inputs:[{start:0,name:"real",type:"tensor"},{start:1,name:"imag",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ComplexAbs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Elu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Exp",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Floor",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Imag",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Neg",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Real",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Prelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"alpha",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu6",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Selu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sigmoid",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Rsqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Square",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sign",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Round",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Expm1",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log1p",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Reciprocal",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Softplus",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Erf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Prod",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axes",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LeakyRelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"alpha",name:"alpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsNan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}]},c912:function(e,t,n){"use strict";n.d(t,"a",(function(){return u}));var r=n("6ae2"),a=n("c05b"),s=n("a3f7"),o=n("6ad5"),i=n("54ef");
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function c(e,t){const n=Object(s["a"])(e,"x","transpose");if(null==t&&(t=n.shape.map((e,t)=>t).reverse()),o["b"](n.rank===t.length,()=>`Error in transpose: rank of input ${n.rank} must match length of perm ${t}.`),t.forEach(e=>{o["b"](e>=0&&e<n.rank,()=>"All entries in 'perm' must be between 0 and "+(n.rank-1)+" but got "+t)}),n.rank<=1)return n.clone();const i={x:n},c={perm:t};return r["a"].runKernel(a["fd"],i,c)}const u=Object(i["b"])({transpose_:c})},c9f1:function(e,t,n){"use strict";n.d(t,"a",(function(){return u}));var r=n("6ae2"),a=n("c05b"),s=n("76c2"),o=n("a3f7"),i=n("54ef");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function c(e,t){let n=Object(o["a"])(e,"base","pow"),i=Object(o["a"])(t,"exp","pow");[n,i]=Object(s["makeTypesMatch"])(n,i);const c={a:n,b:i};return r["a"].runKernel(a["hc"],c)}const u=Object(i["b"])({pow_:c})},cae0:function(e,t,n){(function(e){var r;(function(e,a,s){function o(e){var t=this;function n(e,t){var n,r=[];if(t===(0|t))r[0]=t;else for(t=""+t,n=0;n<t.length;++n)r[7&n]=r[7&n]<<15^t.charCodeAt(n)+r[n+1&7]<<13;while(r.length<8)r.push(0);for(n=0;n<8&&0===r[n];++n);for(8==n?r[7]=-1:r[n],e.x=r,e.i=0,n=256;n>0;--n)e.next()}t.next=function(){var e,n,r=t.x,a=t.i;return e=r[a],e^=e>>>7,n=e^e<<24,e=r[a+1&7],n^=e^e>>>10,e=r[a+3&7],n^=e^e>>>3,e=r[a+4&7],n^=e^e<<7,e=r[a+7&7],e^=e<<13,n^=e^e<<9,r[a]=n,t.i=a+1&7,n},n(t,e)}function i(e,t){return t.x=e.x.slice(),t.i=e.i,t}function c(e,t){null==e&&(e=+new Date);var n=new o(e),r=t&&t.state,a=function(){return(n.next()>>>0)/4294967296};return a.double=function(){do{var e=n.next()>>>11,t=(n.next()>>>0)/4294967296,r=(e+t)/(1<<21)}while(0===r);return r},a.int32=n.next,a.quick=a,r&&(r.x&&i(r,n),a.state=function(){return i(n,{})}),a}a&&a.exports?a.exports=c:n("07d6")&&n("3c35")?(r=function(){return c}.call(t,n,t,a),void 0===r||(a.exports=r)):this.xorshift7=c})(0,e,n("07d6"))}).call(this,n("62e4")(e))},cd1f:function(e,t,n){"use strict";n.d(t,"a",(function(){return i}));var r=n("a3f7"),a=n("73d3"),s=n("54ef");function o(e,t,n,s,o,i){const c=Object(r["a"])(e,"x","conv2dTranspose"),u=Object(r["a"])(t,"filter","conv2dTranspose");return Object(a["a"])(n,c,u,s,o,"NHWC",i)}const i=Object(s["b"])({conv2dTranspose_:o})},cef0:function(e,t,n){"use strict";n.d(t,"a",(function(){return l}));var r=n("6ae2"),a=n("c05b"),s=n("76c2"),o=n("a3f7"),i=n("526f"),c=n("54ef");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function u(e,t){let n=Object(o["a"])(e,"a","greater","string_or_numeric"),c=Object(o["a"])(t,"b","greater","string_or_numeric");[n,c]=Object(s["makeTypesMatch"])(n,c),Object(i["a"])(n.shape,c.shape);const u={a:n,b:c};return r["a"].runKernel(a["pb"],u)}const l=Object(c["b"])({greater_:u})},d08e:function(e,t,n){"use strict";n.d(t,"a",(function(){return c}));var r=n("6ae2"),a=n("c05b"),s=n("a3f7"),o=n("54ef");
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function i(e,t){const n=Object(s["a"])(e,"x","reverse"),o={x:n},i={dims:t};return r["a"].runKernel(a["vc"],o,i)}const c=Object(o["b"])({reverse_:i})},d1a8:function(e,t,n){"use strict";n.d(t,"a",(function(){return c}));var r=n("6ae2"),a=n("c05b"),s=n("a3f7"),o=n("54ef");
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function i(e){const t=Object(s["a"])(e,"x","atanh"),n={x:t};return r["a"].runKernel(a["n"],n)}const c=Object(o["b"])({atanh_:i})},d1f4:function(e,t,n){"use strict";n.d(t,"a",(function(){return c}));var r=n("a3f7"),a=n("6ad5"),s=n("54ef"),o=n("35c9");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function i(e,t){const n=Object(r["a"])(e,"x","squeeze");return Object(o["a"])(n,Object(a["Q"])(n.shape,t).newShape)}const c=Object(s["b"])({squeeze_:i})},d303:function(e,t,n){"use strict";n.d(t,"a",(function(){return a}));
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const r={};function a(e){return r[e]}},d30a:function(e,t,n){"use strict";n.d(t,"a",(function(){return c}));var r=n("6ae2"),a=n("c05b"),s=n("a3f7"),o=n("54ef");
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function i(e){const t=Object(s["a"])(e,"x","tan"),n={x:t};return r["a"].runKernel(a["ad"],n)}const c=Object(o["b"])({tan_:i})},d369:function(e,t,n){"use strict";n.d(t,"a",(function(){return c}));var r=n("6ae2"),a=n("c05b"),s=n("a3f7"),o=n("54ef");
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function i(e){const t=Object(s["a"])(e,"x","floor"),n={x:t};return r["a"].runKernel(a["hb"],n)}const c=Object(o["b"])({floor_:i})},d4de:function(e,t,n){"use strict";n.d(t,"a",(function(){return l}));var r=n("6ae2"),a=n("c05b"),s=n("76c2"),o=n("a3f7"),i=n("526f"),c=n("54ef");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function u(e,t){let n=Object(o["a"])(e,"a","notEqual","string_or_numeric"),c=Object(o["a"])(t,"b","notEqual","string_or_numeric");[n,c]=Object(s["makeTypesMatch"])(n,c),Object(i["a"])(n.shape,c.shape);const u={a:n,b:c};return r["a"].runKernel(a["bc"],u)}const l=Object(c["b"])({notEqual_:u})},d4e4:function(e,t,n){"use strict";n.d(t,"a",(function(){return a})),n.d(t,"b",(function(){return s})),n.d(t,"c",(function(){return o}));var r=n("6125");n("d565");
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class a{constructor(e,t,n,a,s){this.mean=e,this.stdDev=t,this.dtype=n,this.nextVal=NaN,this.truncated=a,this.truncated&&(this.upper=this.mean+2*this.stdDev,this.lower=this.mean-2*this.stdDev);const o=s||Math.random();this.random=r["alea"](o.toString())}nextValue(){if(!isNaN(this.nextVal)){const e=this.nextVal;return this.nextVal=NaN,e}let e,t,n=!1;while(!n){let r,a,s;do{r=2*this.random()-1,a=2*this.random()-1,s=r*r+a*a}while(s>=1||0===s);const o=Math.sqrt(-2*Math.log(s)/s);e=this.mean+this.stdDev*r*o,t=this.mean+this.stdDev*a*o,this.truncated&&!this.isValidTruncated(e)||(n=!0)}return this.truncated&&!this.isValidTruncated(t)||(this.nextVal=this.convertValue(t)),this.convertValue(e)}convertValue(e){return null==this.dtype||"float32"===this.dtype?e:Math.round(e)}isValidTruncated(e){return e<=this.upper&&e>=this.lower}}class s{constructor(e,t,n,s){this.alpha=e,this.beta=1/t,this.dtype=n;const o=s||Math.random();this.randu=r["alea"](o.toString()),this.randn=new a(0,1,n,!1,this.randu()),this.d=e<1?e+2/3:e-1/3,this.c=1/Math.sqrt(9*this.d)}nextValue(){let e,t,n,r,a,s;while(1){do{r=this.randn.nextValue(),s=1+this.c*r}while(s<=0);if(s*=s*s,e=r*r,t=1-.331*e*e,n=.5*e+this.d*(1-s+Math.log(s)),a=this.randu(),a<t||Math.log(a)<n)break}return s=1/this.beta*this.d*s,this.alpha<1&&(s*=Math.pow(this.randu(),1/this.alpha)),this.convertValue(s)}convertValue(e){return"float32"===this.dtype?e:Math.round(e)}}class o{constructor(e=0,t=1,n,a){if(this.canReturnFloat=()=>null==this.dtype||"float32"===this.dtype,this.min=e,this.range=t-e,this.dtype=n,null==a&&(a=Math.random()),"number"===typeof a&&(a=a.toString()),!this.canReturnFloat()&&this.range<=1)throw new Error(`The difference between ${e} - ${t} <= 1 and dtype is not float`);this.random=r["alea"](a)}convertValue(e){return this.canReturnFloat()?e:Math.round(e)}nextValue(){return this.convertValue(this.min+this.range*this.random())}}},d54d:function(e,t,n){"use strict";n.d(t,"a",(function(){return u}));var r=n("6ae2"),a=n("c05b"),s=n("a3f7"),o=n("6ad5"),i=n("54ef");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function c(e,t=0){const n=Object(s["b"])(e,"tensors","stack","string_or_numeric");o["b"](n.length>=1,()=>"Pass at least one tensor to tf.stack"),n.length>0&&o["b"](t<=n[0].rank,()=>"Axis must be <= rank of the tensor");const i=n,c={axis:t};return r["a"].runKernel(a["ec"],i,c)}const u=Object(i["b"])({stack_:c})},d556:function(e,t,n){"use strict";n.r(t),n.d(t,"json",(function(){return r}));
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const r=[{tfOpName:"TopKV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"k",type:"number"}],attrs:[{tfName:"sorted",name:"sorted",type:"bool"}]},{tfOpName:"Unique",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"UniqueV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]}]},d565:function(e,t,n){"use strict";n.r(t),n.d(t,"TEST_EPSILON_FLOAT16",(function(){return c})),n.d(t,"expectArraysClose",(function(){return u})),n.d(t,"testEpsilon",(function(){return l})),n.d(t,"expectPromiseToFail",(function(){return p})),n.d(t,"expectArraysEqual",(function(){return h})),n.d(t,"expectNumbersClose",(function(){return f})),n.d(t,"expectValuesInRange",(function(){return b})),n.d(t,"expectArrayBuffersEqual",(function(){return g})),n.d(t,"encodeStrings",(function(){return y}));var r=n("6ae2"),a=n("a3f7"),s=n("6ad5"),o=n("eb7e");
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const i=.001,c=.1;function u(e,t,n){return null==n&&(n=l()),d(e,t,(e,t)=>m(e,t,n))}function l(){return 32===r["a"].backend.floatPrecision()?i:c}function d(e,t,n){let r=!0;if((Object(s["A"])(e)||Object(s["A"])(t))&&(r=!1),Object(s["A"])(e)&&Object(s["A"])(t)&&(r=!0),r){const n=e.constructor.name,r=t.constructor.name;if(n!==r)throw new Error(`Arrays are of different type. Actual: ${n}. Expected: `+r)}if(Array.isArray(e)&&Array.isArray(t)){const n=Object(a["c"])(e),r=Object(a["c"])(t);if(!Object(s["a"])(n,r))throw new Error(`Arrays have different shapes. Actual: [${n}]. Expected: [${r}]`)}const o=Object(s["A"])(e)?e:Object(s["m"])(e),i=Object(s["A"])(t)?t:Object(s["m"])(t);if(o.length!==i.length)throw new Error(`Arrays have different lengths actual: ${o.length} vs expected: ${i.length}.\nActual:   ${o}.\nExpected: ${i}.`);for(let a=0;a<i.length;++a){const e=o[a],t=i[a];if(!n(e,t))throw new Error(`Arrays differ: actual[${a}] = ${e}, expected[${a}] = ${t}.\nActual:   ${o}.\nExpected: ${i}.`)}}function p(e,t){e().then(()=>t.fail(),()=>t())}function h(e,t){const n="string"===typeof t||"number"===typeof t||"boolean"===typeof t?[t]:t;return Object(s["z"])(e)||Object(s["z"])(e[0])||Object(s["z"])(t)||Object(s["z"])(t[0])?d(e,n,(e,t)=>e==t):d(e,t,(e,t)=>m(e,t,0))}function f(e,t,n){if(null==n&&(n=l()),!m(e,t,n))throw new Error(`Numbers differ: actual === ${e}, expected === ${t}`)}function m(e,t,n){return!isFinite(e)&&!isFinite(t)||!(isNaN(e)||isNaN(t)||Math.abs(e-t)>n)}function b(e,t,n){for(let r=0;r<e.length;r++)if(e[r]<t||e[r]>n)throw new Error(`Value out of range:${e[r]} low: ${t}, high: ${n}`)}function g(e,t){expect(new Float32Array(e)).toEqual(new Float32Array(t))}function y(e){for(let t=0;t<e.length;t++){const n=e[t];Array.isArray(n)?y(n):e[t]=Object(o["encodeString"])(n)}return e}},d7b0:function(e,t,n){"use strict";n.d(t,"a",(function(){return c}));var r=n("6ae2"),a=n("c05b"),s=n("a3f7"),o=n("54ef");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function i(e){const t=Object(s["a"])(e,"input","real"),n={input:t};return r["a"].runKernel(a["lc"],n)}const c=Object(o["b"])({real_:i})},da5a:function(e,t){e.exports=r;var n=null;try{n=new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0,97,115,109,1,0,0,0,1,13,2,96,0,1,127,96,4,127,127,127,127,1,127,3,7,6,0,1,1,1,1,1,6,6,1,127,1,65,0,11,7,50,6,3,109,117,108,0,1,5,100,105,118,95,115,0,2,5,100,105,118,95,117,0,3,5,114,101,109,95,115,0,4,5,114,101,109,95,117,0,5,8,103,101,116,95,104,105,103,104,0,0,10,191,1,6,4,0,35,0,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,126,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,127,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,128,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,129,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,130,34,4,66,32,135,167,36,0,32,4,167,11])),{}).exports}catch(I){}function r(e,t,n){this.low=0|e,this.high=0|t,this.unsigned=!!n}function a(e){return!0===(e&&e["__isLong__"])}r.prototype.__isLong__,Object.defineProperty(r.prototype,"__isLong__",{value:!0}),r.isLong=a;var s={},o={};function i(e,t){var n,r,a;return t?(e>>>=0,(a=0<=e&&e<256)&&(r=o[e],r)?r:(n=u(e,(0|e)<0?-1:0,!0),a&&(o[e]=n),n)):(e|=0,(a=-128<=e&&e<128)&&(r=s[e],r)?r:(n=u(e,e<0?-1:0,!1),a&&(s[e]=n),n))}function c(e,t){if(isNaN(e))return t?O:x;if(t){if(e<0)return O;if(e>=b)return S}else{if(e<=-g)return N;if(e+1>=g)return j}return e<0?c(-e,t).neg():u(e%m|0,e/m|0,t)}function u(e,t,n){return new r(e,t,n)}r.fromInt=i,r.fromNumber=c,r.fromBits=u;var l=Math.pow;function d(e,t,n){if(0===e.length)throw Error("empty string");if("NaN"===e||"Infinity"===e||"+Infinity"===e||"-Infinity"===e)return x;if("number"===typeof t?(n=t,t=!1):t=!!t,n=n||10,n<2||36<n)throw RangeError("radix");var r;if((r=e.indexOf("-"))>0)throw Error("interior hyphen");if(0===r)return d(e.substring(1),t,n).neg();for(var a=c(l(n,8)),s=x,o=0;o<e.length;o+=8){var i=Math.min(8,e.length-o),u=parseInt(e.substring(o,o+i),n);if(i<8){var p=c(l(n,i));s=s.mul(p).add(c(u))}else s=s.mul(a),s=s.add(c(u))}return s.unsigned=t,s}function p(e,t){return"number"===typeof e?c(e,t):"string"===typeof e?d(e,t):u(e.low,e.high,"boolean"===typeof t?t:e.unsigned)}r.fromString=d,r.fromValue=p;var h=65536,f=1<<24,m=h*h,b=m*m,g=b/2,y=i(f),x=i(0);r.ZERO=x;var O=i(0,!0);r.UZERO=O;var v=i(1);r.ONE=v;var w=i(1,!0);r.UONE=w;var k=i(-1);r.NEG_ONE=k;var j=u(-1,2147483647,!1);r.MAX_VALUE=j;var S=u(-1,-1,!0);r.MAX_UNSIGNED_VALUE=S;var N=u(0,-2147483648,!1);r.MIN_VALUE=N;var C=r.prototype;C.toInt=function(){return this.unsigned?this.low>>>0:this.low},C.toNumber=function(){return this.unsigned?(this.high>>>0)*m+(this.low>>>0):this.high*m+(this.low>>>0)},C.toString=function(e){if(e=e||10,e<2||36<e)throw RangeError("radix");if(this.isZero())return"0";if(this.isNegative()){if(this.eq(N)){var t=c(e),n=this.div(t),r=n.mul(t).sub(this);return n.toString(e)+r.toInt().toString(e)}return"-"+this.neg().toString(e)}var a=c(l(e,6),this.unsigned),s=this,o="";while(1){var i=s.div(a),u=s.sub(i.mul(a)).toInt()>>>0,d=u.toString(e);if(s=i,s.isZero())return d+o;while(d.length<6)d="0"+d;o=""+d+o}},C.getHighBits=function(){return this.high},C.getHighBitsUnsigned=function(){return this.high>>>0},C.getLowBits=function(){return this.low},C.getLowBitsUnsigned=function(){return this.low>>>0},C.getNumBitsAbs=function(){if(this.isNegative())return this.eq(N)?64:this.neg().getNumBitsAbs();for(var e=0!=this.high?this.high:this.low,t=31;t>0;t--)if(0!=(e&1<<t))break;return 0!=this.high?t+33:t+1},C.isZero=function(){return 0===this.high&&0===this.low},C.eqz=C.isZero,C.isNegative=function(){return!this.unsigned&&this.high<0},C.isPositive=function(){return this.unsigned||this.high>=0},C.isOdd=function(){return 1===(1&this.low)},C.isEven=function(){return 0===(1&this.low)},C.equals=function(e){return a(e)||(e=p(e)),(this.unsigned===e.unsigned||this.high>>>31!==1||e.high>>>31!==1)&&(this.high===e.high&&this.low===e.low)},C.eq=C.equals,C.notEquals=function(e){return!this.eq(e)},C.neq=C.notEquals,C.ne=C.notEquals,C.lessThan=function(e){return this.comp(e)<0},C.lt=C.lessThan,C.lessThanOrEqual=function(e){return this.comp(e)<=0},C.lte=C.lessThanOrEqual,C.le=C.lessThanOrEqual,C.greaterThan=function(e){return this.comp(e)>0},C.gt=C.greaterThan,C.greaterThanOrEqual=function(e){return this.comp(e)>=0},C.gte=C.greaterThanOrEqual,C.ge=C.greaterThanOrEqual,C.compare=function(e){if(a(e)||(e=p(e)),this.eq(e))return 0;var t=this.isNegative(),n=e.isNegative();return t&&!n?-1:!t&&n?1:this.unsigned?e.high>>>0>this.high>>>0||e.high===this.high&&e.low>>>0>this.low>>>0?-1:1:this.sub(e).isNegative()?-1:1},C.comp=C.compare,C.negate=function(){return!this.unsigned&&this.eq(N)?N:this.not().add(v)},C.neg=C.negate,C.add=function(e){a(e)||(e=p(e));var t=this.high>>>16,n=65535&this.high,r=this.low>>>16,s=65535&this.low,o=e.high>>>16,i=65535&e.high,c=e.low>>>16,l=65535&e.low,d=0,h=0,f=0,m=0;return m+=s+l,f+=m>>>16,m&=65535,f+=r+c,h+=f>>>16,f&=65535,h+=n+i,d+=h>>>16,h&=65535,d+=t+o,d&=65535,u(f<<16|m,d<<16|h,this.unsigned)},C.subtract=function(e){return a(e)||(e=p(e)),this.add(e.neg())},C.sub=C.subtract,C.multiply=function(e){if(this.isZero())return x;if(a(e)||(e=p(e)),n){var t=n.mul(this.low,this.high,e.low,e.high);return u(t,n.get_high(),this.unsigned)}if(e.isZero())return x;if(this.eq(N))return e.isOdd()?N:x;if(e.eq(N))return this.isOdd()?N:x;if(this.isNegative())return e.isNegative()?this.neg().mul(e.neg()):this.neg().mul(e).neg();if(e.isNegative())return this.mul(e.neg()).neg();if(this.lt(y)&&e.lt(y))return c(this.toNumber()*e.toNumber(),this.unsigned);var r=this.high>>>16,s=65535&this.high,o=this.low>>>16,i=65535&this.low,l=e.high>>>16,d=65535&e.high,h=e.low>>>16,f=65535&e.low,m=0,b=0,g=0,O=0;return O+=i*f,g+=O>>>16,O&=65535,g+=o*f,b+=g>>>16,g&=65535,g+=i*h,b+=g>>>16,g&=65535,b+=s*f,m+=b>>>16,b&=65535,b+=o*h,m+=b>>>16,b&=65535,b+=i*d,m+=b>>>16,b&=65535,m+=r*f+s*h+o*d+i*l,m&=65535,u(g<<16|O,m<<16|b,this.unsigned)},C.mul=C.multiply,C.divide=function(e){if(a(e)||(e=p(e)),e.isZero())throw Error("division by zero");if(n){if(!this.unsigned&&-2147483648===this.high&&-1===e.low&&-1===e.high)return this;var t=(this.unsigned?n.div_u:n.div_s)(this.low,this.high,e.low,e.high);return u(t,n.get_high(),this.unsigned)}if(this.isZero())return this.unsigned?O:x;var r,s,o;if(this.unsigned){if(e.unsigned||(e=e.toUnsigned()),e.gt(this))return O;if(e.gt(this.shru(1)))return w;o=O}else{if(this.eq(N)){if(e.eq(v)||e.eq(k))return N;if(e.eq(N))return v;var i=this.shr(1);return r=i.div(e).shl(1),r.eq(x)?e.isNegative()?v:k:(s=this.sub(e.mul(r)),o=r.add(s.div(e)),o)}if(e.eq(N))return this.unsigned?O:x;if(this.isNegative())return e.isNegative()?this.neg().div(e.neg()):this.neg().div(e).neg();if(e.isNegative())return this.div(e.neg()).neg();o=x}s=this;while(s.gte(e)){r=Math.max(1,Math.floor(s.toNumber()/e.toNumber()));var d=Math.ceil(Math.log(r)/Math.LN2),h=d<=48?1:l(2,d-48),f=c(r),m=f.mul(e);while(m.isNegative()||m.gt(s))r-=h,f=c(r,this.unsigned),m=f.mul(e);f.isZero()&&(f=v),o=o.add(f),s=s.sub(m)}return o},C.div=C.divide,C.modulo=function(e){if(a(e)||(e=p(e)),n){var t=(this.unsigned?n.rem_u:n.rem_s)(this.low,this.high,e.low,e.high);return u(t,n.get_high(),this.unsigned)}return this.sub(this.div(e).mul(e))},C.mod=C.modulo,C.rem=C.modulo,C.not=function(){return u(~this.low,~this.high,this.unsigned)},C.and=function(e){return a(e)||(e=p(e)),u(this.low&e.low,this.high&e.high,this.unsigned)},C.or=function(e){return a(e)||(e=p(e)),u(this.low|e.low,this.high|e.high,this.unsigned)},C.xor=function(e){return a(e)||(e=p(e)),u(this.low^e.low,this.high^e.high,this.unsigned)},C.shiftLeft=function(e){return a(e)&&(e=e.toInt()),0===(e&=63)?this:e<32?u(this.low<<e,this.high<<e|this.low>>>32-e,this.unsigned):u(0,this.low<<e-32,this.unsigned)},C.shl=C.shiftLeft,C.shiftRight=function(e){return a(e)&&(e=e.toInt()),0===(e&=63)?this:e<32?u(this.low>>>e|this.high<<32-e,this.high>>e,this.unsigned):u(this.high>>e-32,this.high>=0?0:-1,this.unsigned)},C.shr=C.shiftRight,C.shiftRightUnsigned=function(e){if(a(e)&&(e=e.toInt()),e&=63,0===e)return this;var t=this.high;if(e<32){var n=this.low;return u(n>>>e|t<<32-e,t>>>e,this.unsigned)}return u(32===e?t:t>>>e-32,0,this.unsigned)},C.shru=C.shiftRightUnsigned,C.shr_u=C.shiftRightUnsigned,C.toSigned=function(){return this.unsigned?u(this.low,this.high,!1):this},C.toUnsigned=function(){return this.unsigned?this:u(this.low,this.high,!0)},C.toBytes=function(e){return e?this.toBytesLE():this.toBytesBE()},C.toBytesLE=function(){var e=this.high,t=this.low;return[255&t,t>>>8&255,t>>>16&255,t>>>24,255&e,e>>>8&255,e>>>16&255,e>>>24]},C.toBytesBE=function(){var e=this.high,t=this.low;return[e>>>24,e>>>16&255,e>>>8&255,255&e,t>>>24,t>>>16&255,t>>>8&255,255&t]},r.fromBytes=function(e,t,n){return n?r.fromBytesLE(e,t):r.fromBytesBE(e,t)},r.fromBytesLE=function(e,t){return new r(e[0]|e[1]<<8|e[2]<<16|e[3]<<24,e[4]|e[5]<<8|e[6]<<16|e[7]<<24,t)},r.fromBytesBE=function(e,t){return new r(e[4]<<24|e[5]<<16|e[6]<<8|e[7],e[0]<<24|e[1]<<16|e[2]<<8|e[3],t)}},dae8:function(e,t,n){"use strict";n.d(t,"a",(function(){return u}));var r=n("6ae2"),a=n("c05b"),s=n("a3f7"),o=n("6ad5"),i=n("54ef");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function c(e,t=0){const n=Object(s["a"])(e,"x","expandDims","string_or_numeric");o["b"](t<=n.rank,()=>"Axis must be <= rank of the tensor");const i={input:n},c={dim:t};return r["a"].runKernel(a["cb"],i,c)}const u=Object(i["b"])({expandDims_:c})},db49:function(e,t,n){"use strict";n.d(t,"a",(function(){return c}));var r=n("6ae2"),a=n("c05b"),s=n("a3f7"),o=n("54ef");
/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function i(e,t=0){const n=Object(s["a"])(e,"x","argMin"),o={x:n},i={axis:t};return r["a"].runKernel(a["i"],o,i)}const c=Object(o["b"])({argMin_:i})},dbf3:function(e,t,n){"use strict";n.r(t),n.d(t,"json",(function(){return r}));
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const r=[{tfOpName:"ConcatV2",category:"slice_join",inputs:[{start:0,end:-1,name:"tensors",type:"tensors"},{start:-1,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"Concat",category:"slice_join",inputs:[{start:1,end:0,name:"tensors",type:"tensors"},{start:0,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"GatherV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"axis",type:"number",defaultValue:0}],attrs:[{tfName:"batch_dims",name:"batchDims",type:"number",defaultValue:0}]},{tfOpName:"Gather",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",notSupported:!0}]},{tfOpName:"Reverse",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"dims",type:"bool[]"}]},{tfOpName:"ReverseV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}]},{tfOpName:"Slice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"size",type:"number[]"}]},{tfOpName:"StridedSlice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"end",type:"number[]"},{start:3,name:"strides",type:"number[]"}],attrs:[{tfName:"begin_mask",name:"beginMask",type:"number",defaultValue:0},{tfName:"end_mask",name:"endMask",type:"number",defaultValue:0},{tfName:"new_axis_mask",name:"newAxisMask",type:"number",defaultValue:0},{tfName:"ellipsis_mask",name:"ellipsisMask",type:"number",defaultValue:0},{tfName:"shrink_axis_mask",name:"shrinkAxisMask",type:"number",defaultValue:0}]},{tfOpName:"Pack",category:"slice_join",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0}]},{tfOpName:"Unpack",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0},{tfName:"num",name:"num",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Tile",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"reps",type:"number[]"}]},{tfOpName:"Split",category:"slice_join",inputs:[{start:0,name:"axis",type:"number",defaultValue:0},{start:1,name:"x",type:"tensor"}],attrs:[{tfName:"num_split",name:"numOrSizeSplits",type:"number",defaultValue:1}]},{tfOpName:"SplitV",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"numOrSizeSplits",type:"number[]"},{start:2,name:"axis",type:"number",defaultValue:0}]},{tfOpName:"ScatterNd",category:"slice_join",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"shape",type:"number[]"}]},{tfOpName:"GatherNd",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}]},{tfOpName:"SparseToDense",category:"slice_join",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!1,notSupported:!0}]}]},dc59:function(e,t,n){"use strict";n.d(t,"a",(function(){return c}));var r=n("6ae2"),a=n("c05b"),s=n("a3f7"),o=n("54ef");
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function i(e){const t=Object(s["a"])(e,"x","asinh"),n={x:t};return r["a"].runKernel(a["k"],n)}const c=Object(o["b"])({asinh_:i})},dd7e:function(e,t,n){"use strict";n.d(t,"a",(function(){return d}));var r=n("6ae2"),a=n("c05b"),s=n("a3f7"),o=n("6ad5"),i=n("b818"),c=n("54ef"),u=n("35c9");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function l(e,t,n,c,l="NHWC",d=[1,1],p){const h=Object(s["a"])(e,"x","conv2d"),f=Object(s["a"])(t,"filter","conv2d");let m=h,b=!1;3===h.rank&&(b=!0,m=Object(u["a"])(h,[1,h.shape[0],h.shape[1],h.shape[2]])),o["b"](4===m.rank,()=>`Error in conv2d: input must be rank 4, but got rank ${m.rank}.`),o["b"](4===f.rank,()=>"Error in conv2d: filter must be rank 4, but got rank "+f.rank+"."),null!=p&&o["b"](o["v"](c),()=>`Error in conv2d: pad must be an integer when using, dimRoundingMode ${p} but got pad ${c}.`);const g="NHWC"===l?m.shape[3]:m.shape[1];o["b"](g===f.shape[2],()=>`Error in conv2d: depth of input (${g}) must match input depth for filter ${f.shape[2]}.`),o["b"](i["h"](n,d),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${n} and dilations '${d}'`);const y={x:m,filter:f},x={strides:n,pad:c,dataFormat:l,dilations:d,dimRoundingMode:p},O=r["a"].runKernel(a["D"],y,x);return b?Object(u["a"])(O,[O.shape[1],O.shape[2],O.shape[3]]):O}const d=Object(c["b"])({conv2d_:l})},de1a:function(e,t,n){"use strict";n.d(t,"a",(function(){return c}));var r=n("6ae2"),a=n("c05b"),s=n("a3f7"),o=n("54ef");
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function i(e,t,n,o,i=0,c=0,u=0,l=0,d=0){const p=Object(s["a"])(e,"x","stridedSlice","string_or_numeric"),h={x:p},f={begin:t,end:n,strides:o,beginMask:i,endMask:c,ellipsisMask:u,newAxisMask:l,shrinkAxisMask:d};return r["a"].runKernel(a["Uc"],h,f)}const c=Object(o["b"])({stridedSlice_:i})},deb3:function(e,t,n){"use strict";n.d(t,"a",(function(){return u}));var r=n("6ae2"),a=n("c05b"),s=n("a3f7"),o=n("6ad5"),i=n("54ef");
/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function c(e,t){const n=Object(s["a"])(e,"x","cast");if(!o["B"](t))throw new Error("Failed to cast to unknown dtype "+t);if("string"===t&&"string"!==n.dtype||"string"!==t&&"string"===n.dtype)throw new Error("Only strings can be casted to strings");const i={x:n},c={dtype:t};return r["a"].runKernel(a["x"],i,c)}const u=Object(i["b"])({cast_:c})},df7c:function(e,t,n){(function(e){function n(e,t){for(var n=0,r=e.length-1;r>=0;r--){var a=e[r];"."===a?e.splice(r,1):".."===a?(e.splice(r,1),n++):n&&(e.splice(r,1),n--)}if(t)for(;n--;n)e.unshift("..");return e}function r(e){"string"!==typeof e&&(e+="");var t,n=0,r=-1,a=!0;for(t=e.length-1;t>=0;--t)if(47===e.charCodeAt(t)){if(!a){n=t+1;break}}else-1===r&&(a=!1,r=t+1);return-1===r?"":e.slice(n,r)}function a(e,t){if(e.filter)return e.filter(t);for(var n=[],r=0;r<e.length;r++)t(e[r],r,e)&&n.push(e[r]);return n}t.resolve=function(){for(var t="",r=!1,s=arguments.length-1;s>=-1&&!r;s--){var o=s>=0?arguments[s]:e.cwd();if("string"!==typeof o)throw new TypeError("Arguments to path.resolve must be strings");o&&(t=o+"/"+t,r="/"===o.charAt(0))}return t=n(a(t.split("/"),(function(e){return!!e})),!r).join("/"),(r?"/":"")+t||"."},t.normalize=function(e){var r=t.isAbsolute(e),o="/"===s(e,-1);return e=n(a(e.split("/"),(function(e){return!!e})),!r).join("/"),e||r||(e="."),e&&o&&(e+="/"),(r?"/":"")+e},t.isAbsolute=function(e){return"/"===e.charAt(0)},t.join=function(){var e=Array.prototype.slice.call(arguments,0);return t.normalize(a(e,(function(e,t){if("string"!==typeof e)throw new TypeError("Arguments to path.join must be strings");return e})).join("/"))},t.relative=function(e,n){function r(e){for(var t=0;t<e.length;t++)if(""!==e[t])break;for(var n=e.length-1;n>=0;n--)if(""!==e[n])break;return t>n?[]:e.slice(t,n-t+1)}e=t.resolve(e).substr(1),n=t.resolve(n).substr(1);for(var a=r(e.split("/")),s=r(n.split("/")),o=Math.min(a.length,s.length),i=o,c=0;c<o;c++)if(a[c]!==s[c]){i=c;break}var u=[];for(c=i;c<a.length;c++)u.push("..");return u=u.concat(s.slice(i)),u.join("/")},t.sep="/",t.delimiter=":",t.dirname=function(e){if("string"!==typeof e&&(e+=""),0===e.length)return".";for(var t=e.charCodeAt(0),n=47===t,r=-1,a=!0,s=e.length-1;s>=1;--s)if(t=e.charCodeAt(s),47===t){if(!a){r=s;break}}else a=!1;return-1===r?n?"/":".":n&&1===r?"/":e.slice(0,r)},t.basename=function(e,t){var n=r(e);return t&&n.substr(-1*t.length)===t&&(n=n.substr(0,n.length-t.length)),n},t.extname=function(e){"string"!==typeof e&&(e+="");for(var t=-1,n=0,r=-1,a=!0,s=0,o=e.length-1;o>=0;--o){var i=e.charCodeAt(o);if(47!==i)-1===r&&(a=!1,r=o+1),46===i?-1===t?t=o:1!==s&&(s=1):-1!==t&&(s=-1);else if(!a){n=o+1;break}}return-1===t||-1===r||0===s||1===s&&t===r-1&&t===n+1?"":e.slice(t,r)};var s="b"==="ab".substr(-1)?function(e,t,n){return e.substr(t,n)}:function(e,t,n){return t<0&&(t=e.length+t),e.substr(t,n)}}).call(this,n("4362"))},df81:function(e,t,n){"use strict";n.d(t,"a",(function(){return c}));var r=n("6ae2"),a=n("c05b"),s=n("a3f7"),o=n("54ef");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function i(e,t=null,n=!1){const o=Object(s["a"])(e,"x","all","bool"),i={x:o},c={axis:t,keepDims:n};return r["a"].runKernel(a["f"],i,c)}const c=Object(o["b"])({all_:i})},e053:function(e,t,n){"use strict";n.d(t,"a",(function(){return u}));var r=n("6ae2"),a=n("c05b"),s=n("a3f7"),o=n("deb3"),i=n("54ef");
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function c(e,t=null,n=!1){let i=Object(s["a"])(e,"x","sum");"bool"===i.dtype&&(i=Object(o["a"])(i,"int32"));const c={x:i},u={axis:t,keepDims:n};return r["a"].runKernel(a["Zc"],c,u)}const u=Object(i["b"])({sum_:c})},e101:function(e,t,n){"use strict";n.d(t,"a",(function(){return l}));var r=n("6ae2"),a=n("c05b"),s=n("a3f7"),o=n("6ad5"),i=n("54ef"),c=n("35c9");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function u(e,t=5,n=1,i=1,u=.5){const l=Object(s["a"])(e,"x","localResponseNormalization");o["b"](4===l.rank||3===l.rank,()=>`Error in localResponseNormalization: x must be rank 3 or 4 but got\n               rank ${l.rank}.`),o["b"](o["v"](t),()=>`Error in localResponseNormalization: depthRadius must be an integer but got depthRadius ${t}.`);let d=l,p=!1;3===l.rank&&(p=!0,d=Object(c["a"])(l,[1,l.shape[0],l.shape[1],l.shape[2]]));const h={x:d},f={depthRadius:t,bias:n,alpha:i,beta:u},m=r["a"].runKernel(a["xb"],h,f);return p?Object(c["a"])(m,[m.shape[1],m.shape[2],m.shape[3]]):m}const l=Object(i["b"])({localResponseNormalization_:u})},e1fd:function(e,t,n){"use strict";n.d(t,"a",(function(){return l}));var r=n("6ae2"),a=n("c05b"),s=n("76c2"),o=n("a3f7"),i=n("526f"),c=n("54ef");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function u(e,t){let n=Object(o["a"])(e,"a","less","string_or_numeric"),c=Object(o["a"])(t,"b","less","string_or_numeric");[n,c]=Object(s["makeTypesMatch"])(n,c),Object(i["a"])(n.shape,c.shape);const u={a:n,b:c};return r["a"].runKernel(a["Ab"],u)}const l=Object(c["b"])({less_:u})},e22c:function(e,t,n){"use strict";n.d(t,"a",(function(){return c}));var r=n("6ae2"),a=n("c05b"),s=n("a3f7"),o=n("54ef");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function i(e,t,n=1,o=0){if(t<2)throw new Error("Error in oneHot: depth must be >=2, but it is "+t);const i=Object(s["a"])(e,"indices","oneHot","int32"),c={indices:i},u={depth:t,onValue:n,offValue:o};return r["a"].runKernel(a["cc"],c,u)}const c=Object(o["b"])({oneHot_:i})},e333:function(e,t,n){"use strict";n.d(t,"a",(function(){return u}));var r=n("6ae2"),a=n("c05b"),s=n("a3f7"),o=n("526f"),i=n("54ef");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function c(e,t){const n=Object(s["a"])(e,"a","logicalAnd","bool"),i=Object(s["a"])(t,"b","logicalAnd","bool");Object(o["a"])(n.shape,i.shape);const c={a:n,b:i};return r["a"].runKernel(a["Gb"],c)}const u=Object(i["b"])({logicalAnd_:c})},e89f:function(e,t,n){"use strict";n.d(t,"a",(function(){return c}));var r=n("6ae2"),a=n("c05b"),s=n("a3f7"),o=n("54ef");
/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function i(e,t=0){const n=Object(s["a"])(e,"x","argMax"),o={x:n},i={axis:t};return r["a"].runKernel(a["h"],o,i)}const c=Object(o["b"])({argMax_:i})},eb7e:function(e,t,n){"use strict";n.r(t),n.d(t,"shuffle",(function(){return a["M"]})),n.d(t,"shuffleCombo",(function(){return a["N"]})),n.d(t,"clamp",(function(){return a["i"]})),n.d(t,"nearestLargerEven",(function(){return a["H"]})),n.d(t,"swap",(function(){return a["S"]})),n.d(t,"sum",(function(){return a["R"]})),n.d(t,"randUniform",(function(){return a["J"]})),n.d(t,"distSquared",(function(){return a["l"]})),n.d(t,"assert",(function(){return a["b"]})),n.d(t,"assertShapesMatch",(function(){return a["e"]})),n.d(t,"assertNonNull",(function(){return a["d"]})),n.d(t,"flatten",(function(){return a["m"]})),n.d(t,"sizeFromShape",(function(){return a["O"]})),n.d(t,"isScalarShape",(function(){return a["y"]})),n.d(t,"arraysEqual",(function(){return a["a"]})),n.d(t,"isInt",(function(){return a["v"]})),n.d(t,"tanh",(function(){return a["T"]})),n.d(t,"sizeToSquarishShape",(function(){return a["P"]})),n.d(t,"createShuffledIndices",(function(){return a["k"]})),n.d(t,"rightPad",(function(){return a["L"]})),n.d(t,"repeatedTry",(function(){return a["K"]})),n.d(t,"inferFromImplicitShape",(function(){return a["s"]})),n.d(t,"parseAxisParam",(function(){return a["I"]})),n.d(t,"squeezeShape",(function(){return a["Q"]})),n.d(t,"getTypedArrayFromDType",(function(){return a["o"]})),n.d(t,"getArrayFromDType",(function(){return a["n"]})),n.d(t,"checkConversionForErrors",(function(){return a["h"]})),n.d(t,"isValidDtype",(function(){return a["B"]})),n.d(t,"hasEncodingLoss",(function(){return a["p"]})),n.d(t,"isTypedArray",(function(){return a["A"]})),n.d(t,"bytesPerElement",(function(){return a["g"]})),n.d(t,"bytesFromStringArray",(function(){return a["f"]})),n.d(t,"isString",(function(){return a["z"]})),n.d(t,"isBoolean",(function(){return a["t"]})),n.d(t,"isNumber",(function(){return a["w"]})),n.d(t,"inferDtype",(function(){return a["r"]})),n.d(t,"isFunction",(function(){return a["u"]})),n.d(t,"nearestDivisor",(function(){return a["G"]})),n.d(t,"computeStrides",(function(){return a["j"]})),n.d(t,"toNestedArray",(function(){return a["U"]})),n.d(t,"makeOnesTypedArray",(function(){return a["D"]})),n.d(t,"makeZerosTypedArray",(function(){return a["F"]})),n.d(t,"makeZerosNestedTypedArray",(function(){return a["E"]})),n.d(t,"assertNonNegativeIntegerDimensions",(function(){return a["c"]})),n.d(t,"locToIndex",(function(){return a["C"]})),n.d(t,"indexToLoc",(function(){return a["q"]})),n.d(t,"isPromise",(function(){return a["x"]})),n.d(t,"hexToLong",(function(){return c})),n.d(t,"fingerPrint64",(function(){return k})),n.d(t,"createScalarValue",(function(){return j})),n.d(t,"toTypedArray",(function(){return N})),n.d(t,"now",(function(){return C})),n.d(t,"fetch",(function(){return I})),n.d(t,"encodeString",(function(){return T})),n.d(t,"decodeString",(function(){return $}));var r=n("b333"),a=n("6ad5"),s=n("da5a"),o=n.n(s);
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const i=o.a||s;function c(e){return i.fromString(e,!0,16)}const u=c("c3a5c85c97cb3127"),l=c("b492b66fbe98f273"),d=c("9ae16a3b2f90404f");function p(e){return e.xor(e.shru(47))}function h(e,t,n){const r=e.slice(t,t+n);return i.fromBytes(Array.from(r),!0,!0)}function f(e,t){return h(e,t,8)}function m(e,t){return h(e,t,4)}function b(e,t){return 0===t?e:e.shru(t).or(e.shl(64-t))}function g(e,t,n=c("9ddfea08eb382d69")){let r=e.xor(t).mul(n);r=r.xor(r.shru(47));let a=t.xor(r).mul(n);return a=a.xor(a.shru(47)),a=a.mul(n),a}function y(e,t,n,r,a,s){a=a.add(e),s=b(s.add(a).add(r),21);const o=a;return a=a.add(t),a=a.add(n),s=s.add(b(a,44)),[a.add(r),s.add(o)]}function x(e,t,n,r){return y(f(e,t),f(e,t+8),f(e,t+16),f(e,t+24),n,r)}function O(e,t=e.length){if(t>=8){const n=d.add(2*t),r=f(e,0).add(d),a=f(e,t-8),s=b(a,37).mul(n).add(r),o=b(r,25).add(a).mul(n);return g(s,o,n)}if(t>=4){const n=d.add(2*t),r=m(e,0);return g(r.shl(3).add(t),m(e,t-4),n)}if(t>0){const n=e[0],r=e[t>>1],a=e[t-1],s=n+(r<<8),o=t+(a<<2);return p(d.mul(s).xor(u.mul(o))).mul(d)}return d}function v(e,t=e.length){const n=d.add(2*t),r=f(e,0).mul(l),a=f(e,8),s=f(e,t-8).mul(n),o=f(e,t-16).mul(d);return g(b(r.add(a),43).add(b(s,30)).add(o),r.add(b(a.add(d),18)).add(s),n)}function w(e,t=e.length){const n=d.add(2*t),r=f(e,0).mul(d),a=f(e,8),s=f(e,t-8).mul(n),o=f(e,t-16).mul(d),i=b(r.add(a),43).add(b(s,30)).add(o),c=g(i,r.add(b(a.add(d),18)).add(s),n),u=f(e,16).mul(n),l=f(e,24),p=i.add(f(e,t-32)).mul(n),h=c.add(f(e,t-24)).mul(n);return g(b(u.add(l),43).add(b(p,30)).add(h),u.add(b(l.add(r),18)).add(p),n)}function k(e,t=e.length){const n=i.fromNumber(81,!0);if(t<=32)return t<=16?O(e,t):v(e,t);if(t<=64)return w(e,t);let r=n,a=n.mul(l).add(113),s=p(a.mul(d).add(113)).mul(d),o=[i.UZERO,i.UZERO],c=[i.UZERO,i.UZERO];r=r.mul(d).add(f(e,0));let h=0;const m=64*(t-1>>6),y=m+(t-1&63)-63;do{r=b(r.add(a).add(o[0]).add(f(e,h+8)),37).mul(l),a=b(a.add(o[1]).add(f(e,h+48)),42).mul(l),r=r.xor(c[1]),a=a.add(o[0]).add(f(e,h+40)),s=b(s.add(c[0]),33).mul(l),o=x(e,h,o[1].mul(l),r.add(c[0])),c=x(e,h+32,s.add(c[1]),a.add(f(e,h+16))),[s,r]=[r,s],h+=64}while(h!==m);const k=l.add(s.and(255).shl(1));return h=y,c[0]=c[0].add(t-1&63),o[0]=o[0].add(c[0]),c[0]=c[0].add(o[0]),r=b(r.add(a).add(o[0]).add(f(e,h+8)),37).mul(k),a=b(a.add(o[1]).add(f(e,h+48)),42).mul(k),r=r.xor(c[1].mul(9)),a=a.add(o[0].mul(9).add(f(e,h+40))),s=b(s.add(c[0]),33).mul(k),o=x(e,h,o[1].mul(k),r.add(c[0])),c=x(e,h+32,s.add(c[1]),a.add(f(e,h+16))),[s,r]=[r,s],g(g(o[0],c[0],k).add(p(a).mul(u)).add(s),g(o[1],c[1],k).add(r),k)}
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function j(e,t){return"string"===t?T(e):N([e],t)}function S(e,t){return e instanceof Float32Array&&"float32"===t||e instanceof Int32Array&&"int32"===t||e instanceof Uint8Array&&"bool"===t}function N(e,t){if("string"===t)throw new Error("Cannot convert a string[] to a TypedArray");if(Array.isArray(e)&&(e=a["m"](e)),Object(r["c"])().getBool("DEBUG")&&a["h"](e,t),S(e,t))return e;if(null==t||"float32"===t||"complex64"===t)return new Float32Array(e);if("int32"===t)return new Int32Array(e);if("bool"===t){const t=new Uint8Array(e.length);for(let n=0;n<t.length;++n)0!==Math.round(e[n])&&(t[n]=1);return t}throw new Error("Unknown data type "+t)}function C(){return Object(r["c"])().platform.now()}function I(e,t){return Object(r["c"])().platform.fetch(e,t)}function T(e,t="utf-8"){return t=t||"utf-8",Object(r["c"])().platform.encode(e,t)}function $(e,t="utf-8"){return t=t||"utf-8",Object(r["c"])().platform.decode(e,t)}},ef00:function(e,t,n){"use strict";n.d(t,"a",(function(){return c}));var r=n("6ae2"),a=n("c05b"),s=n("a3f7"),o=n("54ef");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function i(e){const t=Object(s["a"])(e,"x","logicalNot","bool"),n={x:t};return r["a"].runKernel(a["Hb"],n)}const c=Object(o["b"])({logicalNot_:i})},eff7:function(e,t,n){"use strict";n.d(t,"a",(function(){return c}));var r=n("6ae2"),a=n("c05b"),s=n("a3f7"),o=n("54ef");
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function i(e){const t=Object(s["a"])(e,"x","cos"),n={x:t};return r["a"].runKernel(a["J"],n)}const c=Object(o["b"])({cos_:i})},f011:function(e,t,n){"use strict";n.r(t),n.d(t,"json",(function(){return r}));
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const r=[{tfOpName:"NonMaxSuppressionV2",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV3",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV4",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"T_threshold",name:"threshold",type:"dtype",notSupported:!0},{tfName:"pad_to_max_output_size",name:"padToMaxOutputSize",type:"bool"}]},{tfOpName:"NonMaxSuppressionV5",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"},{start:5,name:"softNmsSigma",type:"number"}]},{tfOpName:"Where",category:"dynamic",inputs:[{start:0,name:"condition",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ListDiff",category:"dynamic",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}]},f0a9:function(e,t,n){"use strict";n.d(t,"a",(function(){return c}));var r=n("6ae2"),a=n("c05b"),s=n("a3f7"),o=n("54ef");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function i(e){const t=Object(s["a"])(e,"x","clone","string_or_numeric"),n={x:t};return r["a"].runKernel(a["sb"],n)}const c=Object(o["b"])({clone_:i})},f0e5:function(e,t,n){"use strict";n.d(t,"a",(function(){return d}));var r=n("6ae2"),a=n("c05b"),s=n("76c2"),o=n("a3f7"),i=n("526f"),c=n("deb3"),u=n("54ef");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function l(e,t){let n=Object(o["a"])(e,"a","minimum"),u=Object(o["a"])(t,"b","minimum");[n,u]=Object(s["makeTypesMatch"])(n,u),"bool"===n.dtype&&(n=Object(c["a"])(n,"int32"),u=Object(c["a"])(u,"int32")),Object(i["a"])(n.shape,u.shape);const l={a:n,b:u};return r["a"].runKernel(a["Sb"],l)}const d=Object(u["b"])({minimum_:l})},f183:function(e,t,n){"use strict";n.d(t,"a",(function(){return u}));var r=n("6ae2"),a=n("c05b"),s=n("a3f7"),o=n("526f"),i=n("54ef");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function c(e,t){const n=Object(s["a"])(e,"a","logicalOr","bool"),i=Object(s["a"])(t,"b","logicalOr","bool");Object(o["a"])(n.shape,i.shape);const c={a:n,b:i};return r["a"].runKernel(a["Ib"],c)}const u=Object(i["b"])({logicalOr_:c})},f3ae:function(e,t,n){"use strict";n.d(t,"a",(function(){return u}));var r=n("6ae2"),a=n("c05b"),s=n("a3f7"),o=n("deb3"),i=n("54ef");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function c(e,t=null,n=!1){let i=Object(s["a"])(e,"x","prod");"bool"===i.dtype&&(i=Object(o["a"])(i,"int32"));const c={x:i},u={axis:t,keepDims:n};return r["a"].runKernel(a["jc"],c,u)}const u=Object(i["b"])({prod_:c})},f490:function(e,t,n){"use strict";(function(e,r){
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
let a;function s(){if(null==a){let t;if("undefined"!==typeof window)t=window;else if("undefined"!==typeof e)t=e;else if("undefined"!==typeof r)t=r;else{if("undefined"===typeof self)throw new Error("Could not find a global object");t=self}a=t}return a}function o(){const e=s();return null==e._tfGlobals&&(e._tfGlobals=new Map),e._tfGlobals}function i(e,t){const n=o();if(n.has(e))return n.get(e);{const r=t();return n.set(e,r),n.get(e)}}n.d(t,"b",(function(){return s})),n.d(t,"a",(function(){return i}))}).call(this,n("c8ba"),n("4362"))},f74c:function(e,t,n){"use strict";n.d(t,"a",(function(){return i}));var r=n("34d7"),a=n("a3f7"),s=n("6ad5");
/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
async function o(e,t){const n=Object(a["a"])(e,"x","setdiff1d"),o=Object(a["a"])(t,"y","setdiff1d");s["b"](n.dtype===o.dtype,()=>`x and y should have the same dtype, but got x (${n.dtype}) and y (${o.dtype}).`),s["b"](1===n.rank,()=>`x should be 1D tensor, but got x (${n.shape}).`),s["b"](1===o.rank,()=>`y should be 1D tensor, but got y (${o.shape}).`);const i=await n.data(),c=await o.data(),u=new Set(c);let l=0;for(let r=0;r<i.length;r++)u.has(i[r])||l++;const d=new r["b"]([l],n.dtype),p=new r["b"]([l],"int32");for(let r=0,a=0;r<i.length;r++)u.has(i[r])||(d.values[a]=i[r],p.values[a]=r,a++);return[d.toTensor(),p.toTensor()]}const i=o},f8bb:function(e,t,n){"use strict";(function(e){n.d(t,"a",(function(){return N})),n.d(t,"i",(function(){return T})),n.d(t,"c",(function(){return $})),n.d(t,"f",(function(){return E})),n.d(t,"e",(function(){return _})),n.d(t,"d",(function(){return F})),n.d(t,"k",(function(){return M})),n.d(t,"g",(function(){return L})),n.d(t,"h",(function(){return P})),n.d(t,"j",(function(){return B})),n.d(t,"b",(function(){return V}));var r=n("fa11"),a=n("46cc"),s=n("d303"),o=n("526c"),i=n("aeab"),c=n("c8ad"),u=n("5874"),l=n("9489"),d=n("04b8"),p=n("f011"),h=n("d556"),f=n("3d50"),m=n("6e83"),b=n("29d8"),g=n("a80f"),y=n("673d"),x=n("3bfc"),O=n("31bb"),v=n("dbf3"),w=n("5f44"),k=n("113e"),j=n("1906"),S=n("9e7b");
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class N{static get Instance(){return this._instance||(this._instance=new this)}constructor(){const e=[i,c,u,l,d,p,h,f,m,b,g,y,x,O,v,w,k,j,S],t=[].concat(...e.map(e=>e.json));this.opMappers=t.reduce((e,t)=>(e[t.tfOpName]=t,e),{})}transformGraph(e,t={}){const n=e.node,r=[],a=[],s=[],i=n.reduce((e,t)=>(e[t.name]=this.mapNode(t),t.op.startsWith("Placeholder")?r.push(e[t.name]):"Const"===t.op?a.push(e[t.name]):null!=t.input&&0!==t.input.length||s.push(e[t.name]),e),{});let c=[];const u=[];let l={},d={};null!=t&&(l=this.mapSignatureEntries(t.inputs),d=this.mapSignatureEntries(t.outputs));const p=Object.keys(i);p.forEach(e=>{const t=i[e];t.inputNames.forEach((e,n)=>{const[r,,a]=Object(o["b"])(e),s=i[r];if(null!=s.outputs){const e=s.outputs.indexOf(a);if(-1!==e){const a=`${r}:${e}`;t.inputNames[n]=a}}t.inputs.push(s),s.children.push(t)})}),0===Object.keys(d).length?p.forEach(e=>{const t=i[e];0===t.children.length&&u.push(t)}):Object.keys(d).forEach(e=>{const[t]=Object(o["b"])(e),n=i[t];null!=n&&(n.signatureKey=d[e],u.push(n))}),Object.keys(l).length>0?Object.keys(l).forEach(e=>{const[t]=Object(o["b"])(e),n=i[t];n&&(n.signatureKey=l[e],c.push(n))}):c=r;let h={};null!=e.library&&null!=e.library.function&&(h=e.library.function.reduce((e,t)=>(e[t.signature.name]=this.mapFunction(t),e),{}));const f={nodes:i,inputs:c,outputs:u,weights:a,placeholders:r,signature:t,functions:h};return s.length>0&&(f.initNodes=s),f}mapSignatureEntries(e){return Object.keys(e||{}).reduce((t,n)=>(t[e[n].name]=n,t),{})}mapNode(e){const t=Object(s["a"])(e.op)||this.opMappers[e.op]||{};null==e.attr&&(e.attr={});const n={name:e.name,op:e.op,category:t.category,inputNames:(e.input||[]).map(e=>e.startsWith("^")?e.substr(1):e),inputs:[],children:[],inputParams:{},attrParams:{},rawAttrs:e.attr,outputs:t.outputs};return null!=t.inputs&&(n.inputParams=t.inputs.reduce((e,t)=>(e[t.name]={type:t.type,inputIndexStart:t.start,inputIndexEnd:t.end},e),{})),null!=t.attrs&&(n.attrParams=t.attrs.reduce((t,n)=>{const r=n.type;let a=void 0;switch(n.type){case"string":a=T(e.attr,n.tfName,n.defaultValue),void 0===a&&n.tfDeprecatedName&&(a=T(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"string[]":a=P(e.attr,n.tfName,n.defaultValue),void 0===a&&n.tfDeprecatedName&&(a=P(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"number":a=E(e.attr,n.tfName,n.defaultValue||0),void 0===a&&n.tfDeprecatedName&&(a=E(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"number[]":a=L(e.attr,n.tfName,n.defaultValue),void 0===a&&n.tfDeprecatedName&&(a=L(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"bool":a=$(e.attr,n.tfName,n.defaultValue),void 0===a&&n.tfDeprecatedName&&(a=$(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"bool[]":a=V(e.attr,n.tfName,n.defaultValue),void 0===a&&n.tfDeprecatedName&&(a=V(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"shape":a=M(e.attr,n.tfName,n.defaultValue),void 0===a&&n.tfDeprecatedName&&(a=M(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"shape[]":a=B(e.attr,n.tfName,n.defaultValue),void 0===a&&n.tfDeprecatedName&&(a=B(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"dtype":a=_(e.attr,n.tfName,n.defaultValue),void 0===a&&n.tfDeprecatedName&&(a=_(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"dtype[]":a=F(e.attr,n.tfName,n.defaultValue),void 0===a&&n.tfDeprecatedName&&(a=F(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"func":a=R(e.attr,n.tfName,n.defaultValue),void 0===a&&n.tfDeprecatedName&&(a=R(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"tensor":case"tensors":break;default:throw new Error(`Unsupported param type: ${n.type} for op: ${e.op}`)}return t[n.name]={value:a,type:r},t},{})),n}mapFunction(e){const t=e.nodeDef,n=[],r=[];let a={};null!=t&&(a=t.reduce((e,t)=>(e[t.name]=this.mapNode(t),"Const"===t.op&&r.push(e[t.name]),e),{}));const s=[],i=[];e.signature.inputArg.forEach(e=>{const[t]=Object(o["b"])(e.name),n={name:t,op:"Placeholder",inputs:[],inputNames:[],category:"graph",inputParams:{},attrParams:{dtype:{value:A(e.type),type:"dtype"}},children:[]};n.signatureKey=e.name,s.push(n),a[t]=n});const c=Object.keys(a);c.forEach(e=>{const t=a[e];t.inputNames.forEach((e,n)=>{const[r,,s]=Object(o["b"])(e),i=a[r];if(null!=i.outputs){const e=i.outputs.indexOf(s);if(-1!==e){const a=`${r}:${e}`;t.inputNames[n]=a}}t.inputs.push(i),i.children.push(t)})});const u=e.ret;e.signature.outputArg.forEach(e=>{const[t,n]=Object(o["b"])(u[e.name]),r=a[t];null!=r&&(r.defaultOutput=n,i.push(r))});const l=this.mapArgsToSignature(e);return{nodes:a,inputs:s,outputs:i,weights:r,placeholders:n,signature:l}}mapArgsToSignature(e){return{methodName:e.signature.name,inputs:e.signature.inputArg.reduce((e,t)=>(e[t.name]=this.mapArgToTensorInfo(t),e),{}),outputs:e.signature.outputArg.reduce((t,n)=>(t[n.name]=this.mapArgToTensorInfo(n,e.ret),t),{})}}mapArgToTensorInfo(e,t){let n=e.name;return null!=t&&(n=t[n]),{name:n,dtype:e.type}}}function C(t){const n=Object(r["env"])().global;if("undefined"!==typeof n.atob)return n.atob(t);if("undefined"!==typeof e)return new e(t,"base64").toString();throw new Error("Unable to decode base64 in this environment. Missing built-in atob() or Buffer()")}function I(e,t){const n=Array.isArray(e)?String.fromCharCode.apply(null,e):C(e);return t?n:n.toLowerCase()}function T(e,t,n,r=!1){const a=e[t];return null!=a?I(a.s,r):n}function $(e,t,n){const r=e[t];return r?r.b:n}function E(e,t,n){const r=e[t]||{},a=null!=r["i"]?r["i"]:null!=r["f"]?r["f"]:n;return"number"===typeof a?a:parseInt(a,10)}function A(e){switch("string"===typeof e&&(e=a["a"][e]),e){case a["a"].DT_FLOAT:return"float32";case a["a"].DT_INT32:case a["a"].DT_INT64:case a["a"].DT_INT8:case a["a"].DT_UINT8:return"int32";case a["a"].DT_BOOL:return"bool";case a["a"].DT_DOUBLE:return"float32";case a["a"].DT_STRING:return"string";default:return null}}function R(e,t,n){const r=e[t];return r&&r.func?r.func.name:n}function _(e,t,n){const r=e[t];return r&&r.type?A(r.type):n}function F(e,t,n){const r=e[t];return r&&r.list&&r.list.type?r.list.type.map(e=>A(e)):n}function D(e){if(!e.unknownRank)return null!=e.dim?e.dim.map(e=>"number"===typeof e.size?e.size:parseInt(e.size,10)):[]}function M(e,t,n){const r=e[t];return r&&r.shape?D(r.shape):n}function L(e,t,n){const r=e[t];return r?((r.list.f&&r.list.f.length?r.list.f:r.list.i)||[]).map(e=>"number"===typeof e?e:parseInt(e,10)):n}function P(e,t,n,r=!1){const a=e[t];return a&&a.list&&a.list.s?a.list.s.map(e=>I(e,r)):n}function B(e,t,n){const r=e[t];return r&&r.list&&r.list.shape?r.list.shape.map(e=>D(e)):n}function V(e,t,n){const r=e[t];return r&&r.list&&r.list.b?r.list.b:n}}).call(this,n("b639").Buffer)},fa11:function(e,t,n){"use strict";n.r(t),n.d(t,"AdadeltaOptimizer",(function(){return _t})),n.d(t,"AdagradOptimizer",(function(){return Dt})),n.d(t,"AdamOptimizer",(function(){return Pt})),n.d(t,"AdamaxOptimizer",(function(){return zt})),n.d(t,"MomentumOptimizer",(function(){return Ut})),n.d(t,"Optimizer",(function(){return Rt})),n.d(t,"RMSPropOptimizer",(function(){return Gt})),n.d(t,"SGDOptimizer",(function(){return Wt})),n.d(t,"Tensor",(function(){return oe["a"]})),n.d(t,"TensorBuffer",(function(){return oe["b"]})),n.d(t,"Variable",(function(){return oe["c"]})),n.d(t,"Rank",(function(){return Ht["a"]})),n.d(t,"sumOutType",(function(){return Ht["b"]})),n.d(t,"upcastType",(function(){return Ht["c"]})),n.d(t,"abs",(function(){return qt["b"]})),n.d(t,"acos",(function(){return qt["c"]})),n.d(t,"acosh",(function(){return qt["d"]})),n.d(t,"add",(function(){return qt["e"]})),n.d(t,"addN",(function(){return qt["f"]})),n.d(t,"all",(function(){return qt["g"]})),n.d(t,"any",(function(){return qt["h"]})),n.d(t,"argMax",(function(){return qt["i"]})),n.d(t,"argMin",(function(){return qt["j"]})),n.d(t,"asin",(function(){return qt["k"]})),n.d(t,"asinh",(function(){return qt["l"]})),n.d(t,"atan",(function(){return qt["m"]})),n.d(t,"atan2",(function(){return qt["n"]})),n.d(t,"atanh",(function(){return qt["o"]})),n.d(t,"avgPool",(function(){return qt["p"]})),n.d(t,"avgPool3d",(function(){return qt["q"]})),n.d(t,"basicLSTMCell",(function(){return qt["r"]})),n.d(t,"batchToSpaceND",(function(){return qt["w"]})),n.d(t,"batchNorm",(function(){return qt["s"]})),n.d(t,"batchNorm2d",(function(){return qt["t"]})),n.d(t,"batchNorm3d",(function(){return qt["u"]})),n.d(t,"batchNorm4d",(function(){return qt["v"]})),n.d(t,"bincount",(function(){return qt["x"]})),n.d(t,"broadcastArgs",(function(){return qt["z"]})),n.d(t,"broadcastTo",(function(){return qt["A"]})),n.d(t,"buffer",(function(){return qt["B"]})),n.d(t,"cast",(function(){return qt["C"]})),n.d(t,"ceil",(function(){return qt["D"]})),n.d(t,"clipByValue",(function(){return qt["E"]})),n.d(t,"clone",(function(){return qt["F"]})),n.d(t,"complex",(function(){return qt["G"]})),n.d(t,"concat",(function(){return qt["H"]})),n.d(t,"concat1d",(function(){return qt["I"]})),n.d(t,"concat2d",(function(){return qt["J"]})),n.d(t,"concat3d",(function(){return qt["K"]})),n.d(t,"concat4d",(function(){return qt["L"]})),n.d(t,"conv1d",(function(){return qt["M"]})),n.d(t,"conv2d",(function(){return qt["N"]})),n.d(t,"conv2dTranspose",(function(){return qt["O"]})),n.d(t,"conv3d",(function(){return qt["P"]})),n.d(t,"conv3dTranspose",(function(){return qt["Q"]})),n.d(t,"cos",(function(){return qt["R"]})),n.d(t,"cosh",(function(){return qt["S"]})),n.d(t,"cumsum",(function(){return qt["U"]})),n.d(t,"denseBincount",(function(){return qt["V"]})),n.d(t,"depthToSpace",(function(){return qt["W"]})),n.d(t,"depthwiseConv2d",(function(){return qt["X"]})),n.d(t,"diag",(function(){return qt["Y"]})),n.d(t,"dilation2d",(function(){return qt["Z"]})),n.d(t,"div",(function(){return qt["ab"]})),n.d(t,"divNoNan",(function(){return qt["bb"]})),n.d(t,"dot",(function(){return qt["cb"]})),n.d(t,"einsum",(function(){return qt["eb"]})),n.d(t,"elu",(function(){return qt["fb"]})),n.d(t,"equal",(function(){return qt["hb"]})),n.d(t,"erf",(function(){return qt["ib"]})),n.d(t,"exp",(function(){return qt["jb"]})),n.d(t,"expandDims",(function(){return qt["kb"]})),n.d(t,"expm1",(function(){return qt["lb"]})),n.d(t,"eye",(function(){return qt["mb"]})),n.d(t,"fill",(function(){return qt["ob"]})),n.d(t,"floor",(function(){return qt["pb"]})),n.d(t,"floorDiv",(function(){return qt["qb"]})),n.d(t,"gather",(function(){return qt["sb"]})),n.d(t,"greater",(function(){return qt["ub"]})),n.d(t,"greaterEqual",(function(){return qt["vb"]})),n.d(t,"imag",(function(){return qt["xb"]})),n.d(t,"isFinite",(function(){return qt["Bb"]})),n.d(t,"isInf",(function(){return qt["Cb"]})),n.d(t,"isNaN",(function(){return qt["Db"]})),n.d(t,"leakyRelu",(function(){return qt["Eb"]})),n.d(t,"less",(function(){return qt["Fb"]})),n.d(t,"lessEqual",(function(){return qt["Gb"]})),n.d(t,"linspace",(function(){return qt["Ib"]})),n.d(t,"localResponseNormalization",(function(){return qt["Jb"]})),n.d(t,"log",(function(){return qt["Kb"]})),n.d(t,"log1p",(function(){return qt["Lb"]})),n.d(t,"logSigmoid",(function(){return qt["Mb"]})),n.d(t,"logSoftmax",(function(){return qt["Nb"]})),n.d(t,"logSumExp",(function(){return qt["Ob"]})),n.d(t,"logicalAnd",(function(){return qt["Pb"]})),n.d(t,"logicalNot",(function(){return qt["Qb"]})),n.d(t,"logicalOr",(function(){return qt["Rb"]})),n.d(t,"logicalXor",(function(){return qt["Sb"]})),n.d(t,"matMul",(function(){return qt["Ub"]})),n.d(t,"max",(function(){return qt["Vb"]})),n.d(t,"maxPool",(function(){return qt["Wb"]})),n.d(t,"maxPool3d",(function(){return qt["Xb"]})),n.d(t,"maxPoolWithArgmax",(function(){return qt["Yb"]})),n.d(t,"maximum",(function(){return qt["Zb"]})),n.d(t,"mean",(function(){return qt["ac"]})),n.d(t,"meshgrid",(function(){return qt["bc"]})),n.d(t,"min",(function(){return qt["cc"]})),n.d(t,"minimum",(function(){return qt["dc"]})),n.d(t,"mirrorPad",(function(){return qt["ec"]})),n.d(t,"mod",(function(){return qt["fc"]})),n.d(t,"moments",(function(){return qt["gc"]})),n.d(t,"mul",(function(){return qt["ic"]})),n.d(t,"multiRNNCell",(function(){return qt["jc"]})),n.d(t,"multinomial",(function(){return qt["kc"]})),n.d(t,"neg",(function(){return qt["lc"]})),n.d(t,"notEqual",(function(){return qt["nc"]})),n.d(t,"oneHot",(function(){return qt["oc"]})),n.d(t,"ones",(function(){return qt["pc"]})),n.d(t,"onesLike",(function(){return qt["qc"]})),n.d(t,"outerProduct",(function(){return qt["sc"]})),n.d(t,"pad",(function(){return qt["tc"]})),n.d(t,"pad1d",(function(){return qt["uc"]})),n.d(t,"pad2d",(function(){return qt["vc"]})),n.d(t,"pad3d",(function(){return qt["wc"]})),n.d(t,"pad4d",(function(){return qt["xc"]})),n.d(t,"pool",(function(){return qt["yc"]})),n.d(t,"pow",(function(){return qt["zc"]})),n.d(t,"prelu",(function(){return qt["Ac"]})),n.d(t,"print",(function(){return qt["Bc"]})),n.d(t,"prod",(function(){return qt["Cc"]})),n.d(t,"rand",(function(){return qt["Dc"]})),n.d(t,"randomGamma",(function(){return qt["Ec"]})),n.d(t,"randomNormal",(function(){return qt["Fc"]})),n.d(t,"randomUniform",(function(){return qt["Gc"]})),n.d(t,"range",(function(){return qt["Hc"]})),n.d(t,"real",(function(){return qt["Ic"]})),n.d(t,"reciprocal",(function(){return qt["Jc"]})),n.d(t,"relu",(function(){return qt["Kc"]})),n.d(t,"relu6",(function(){return qt["Lc"]})),n.d(t,"reshape",(function(){return qt["Mc"]})),n.d(t,"reverse",(function(){return qt["Nc"]})),n.d(t,"reverse1d",(function(){return qt["Oc"]})),n.d(t,"reverse2d",(function(){return qt["Pc"]})),n.d(t,"reverse3d",(function(){return qt["Qc"]})),n.d(t,"reverse4d",(function(){return qt["Rc"]})),n.d(t,"round",(function(){return qt["Tc"]})),n.d(t,"rsqrt",(function(){return qt["Uc"]})),n.d(t,"scalar",(function(){return qt["Vc"]})),n.d(t,"selu",(function(){return qt["Xc"]})),n.d(t,"separableConv2d",(function(){return qt["Yc"]})),n.d(t,"setdiff1dAsync",(function(){return qt["Zc"]})),n.d(t,"sigmoid",(function(){return qt["ad"]})),n.d(t,"sign",(function(){return qt["bd"]})),n.d(t,"sin",(function(){return qt["dd"]})),n.d(t,"sinh",(function(){return qt["ed"]})),n.d(t,"slice",(function(){return qt["fd"]})),n.d(t,"slice1d",(function(){return qt["gd"]})),n.d(t,"slice2d",(function(){return qt["hd"]})),n.d(t,"slice3d",(function(){return qt["id"]})),n.d(t,"slice4d",(function(){return qt["jd"]})),n.d(t,"softmax",(function(){return qt["kd"]})),n.d(t,"softplus",(function(){return qt["ld"]})),n.d(t,"spaceToBatchND",(function(){return qt["md"]})),n.d(t,"fft",(function(){return qt["nb"]})),n.d(t,"ifft",(function(){return qt["wb"]})),n.d(t,"irfft",(function(){return qt["Ab"]})),n.d(t,"rfft",(function(){return qt["Sc"]})),n.d(t,"split",(function(){return qt["qd"]})),n.d(t,"sqrt",(function(){return qt["rd"]})),n.d(t,"square",(function(){return qt["sd"]})),n.d(t,"squaredDifference",(function(){return qt["td"]})),n.d(t,"squeeze",(function(){return qt["ud"]})),n.d(t,"stack",(function(){return qt["vd"]})),n.d(t,"step",(function(){return qt["wd"]})),n.d(t,"stridedSlice",(function(){return qt["xd"]})),n.d(t,"sub",(function(){return qt["zd"]})),n.d(t,"sum",(function(){return qt["Ad"]})),n.d(t,"tan",(function(){return qt["Bd"]})),n.d(t,"tanh",(function(){return qt["Cd"]})),n.d(t,"tensor",(function(){return qt["Dd"]})),n.d(t,"tensor1d",(function(){return qt["Ed"]})),n.d(t,"tensor2d",(function(){return qt["Fd"]})),n.d(t,"tensor3d",(function(){return qt["Gd"]})),n.d(t,"tensor4d",(function(){return qt["Hd"]})),n.d(t,"tensor5d",(function(){return qt["Id"]})),n.d(t,"tensor6d",(function(){return qt["Jd"]})),n.d(t,"tile",(function(){return qt["Kd"]})),n.d(t,"topk",(function(){return qt["Ld"]})),n.d(t,"truncatedNormal",(function(){return qt["Nd"]})),n.d(t,"unique",(function(){return qt["Od"]})),n.d(t,"unsortedSegmentSum",(function(){return qt["Pd"]})),n.d(t,"unstack",(function(){return qt["Qd"]})),n.d(t,"variable",(function(){return qt["Rd"]})),n.d(t,"where",(function(){return qt["Sd"]})),n.d(t,"whereAsync",(function(){return qt["Td"]})),n.d(t,"zeros",(function(){return qt["Ud"]})),n.d(t,"zerosLike",(function(){return qt["Vd"]})),n.d(t,"booleanMaskAsync",(function(){return qt["y"]})),n.d(t,"transpose",(function(){return qt["Md"]})),n.d(t,"norm",(function(){return qt["mc"]})),n.d(t,"movingAverage",(function(){return qt["hc"]})),n.d(t,"scatterND",(function(){return qt["Wc"]})),n.d(t,"sparseToDense",(function(){return qt["od"]})),n.d(t,"gatherND",(function(){return qt["tb"]})),n.d(t,"dropout",(function(){return qt["db"]})),n.d(t,"enclosingPowerOfTwo",(function(){return qt["gb"]})),n.d(t,"cosineWindow",(function(){return qt["T"]})),n.d(t,"inTopKAsync",(function(){return qt["zb"]})),n.d(t,"op",(function(){return qt["rc"]})),n.d(t,"OP_SCOPE_SUFFIX",(function(){return qt["a"]})),n.d(t,"image",(function(){return qt["yb"]})),n.d(t,"linalg",(function(){return qt["Hb"]})),n.d(t,"losses",(function(){return qt["Tb"]})),n.d(t,"spectral",(function(){return qt["pd"]})),n.d(t,"fused",(function(){return qt["rb"]})),n.d(t,"signal",(function(){return qt["cd"]})),n.d(t,"sparse",(function(){return qt["nd"]})),n.d(t,"string",(function(){return qt["yd"]})),n.d(t,"Reduction",(function(){return Kt["a"]})),n.d(t,"train",(function(){return Yt})),n.d(t,"enableProdMode",(function(){return jt["g"]})),n.d(t,"enableDebugMode",(function(){return jt["f"]})),n.d(t,"disableDeprecationWarnings",(function(){return jt["c"]})),n.d(t,"deprecationWarn",(function(){return jt["b"]})),n.d(t,"disposeVariables",(function(){return jt["e"]})),n.d(t,"engine",(function(){return jt["h"]})),n.d(t,"memory",(function(){return jt["m"]})),n.d(t,"profile",(function(){return jt["n"]})),n.d(t,"tidy",(function(){return jt["t"]})),n.d(t,"dispose",(function(){return jt["d"]})),n.d(t,"keep",(function(){return jt["l"]})),n.d(t,"time",(function(){return jt["u"]})),n.d(t,"setBackend",(function(){return jt["r"]})),n.d(t,"ready",(function(){return jt["o"]})),n.d(t,"getBackend",(function(){return jt["k"]})),n.d(t,"removeBackend",(function(){return jt["q"]})),n.d(t,"findBackend",(function(){return jt["i"]})),n.d(t,"findBackendFactory",(function(){return jt["j"]})),n.d(t,"registerBackend",(function(){return jt["p"]})),n.d(t,"backend",(function(){return jt["a"]})),n.d(t,"setPlatform",(function(){return jt["s"]})),n.d(t,"getKernel",(function(){return ze["c"]})),n.d(t,"getGradient",(function(){return ze["b"]})),n.d(t,"getKernelsForBackend",(function(){return ze["d"]})),n.d(t,"registerKernel",(function(){return ze["f"]})),n.d(t,"registerGradient",(function(){return ze["e"]})),n.d(t,"unregisterKernel",(function(){return ze["h"]})),n.d(t,"unregisterGradient",(function(){return ze["g"]})),n.d(t,"copyRegisteredKernels",(function(){return ze["a"]})),n.d(t,"customGrad",(function(){return Et["a"]})),n.d(t,"grad",(function(){return Et["b"]})),n.d(t,"grads",(function(){return Et["c"]})),n.d(t,"valueAndGrad",(function(){return Et["d"]})),n.d(t,"valueAndGrads",(function(){return Et["e"]})),n.d(t,"variableGrads",(function(){return Et["f"]})),n.d(t,"Environment",(function(){return h["b"]})),n.d(t,"env",(function(){return h["c"]})),n.d(t,"ENV",(function(){return h["a"]})),n.d(t,"version_core",(function(){return kt})),n.d(t,"nextFrame",(function(){return Zt})),n.d(t,"browser",(function(){return s})),n.d(t,"io",(function(){return r})),n.d(t,"math",(function(){return a})),n.d(t,"serialization",(function(){return c})),n.d(t,"test_util",(function(){return vt})),n.d(t,"util",(function(){return wt})),n.d(t,"backend_util",(function(){return l})),n.d(t,"tensor_util",(function(){return Ot})),n.d(t,"slice_util",(function(){return i})),n.d(t,"gather_util",(function(){return o})),n.d(t,"scatter_util",(function(){return et})),n.d(t,"device_util",(function(){return qn})),n.d(t,"kernel_impls",(function(){return d})),n.d(t,"KernelBackend",(function(){return Yn["b"]})),n.d(t,"DataStorage",(function(){return Yn["a"]})),n.d(t,"Abs",(function(){return Ve["a"]})),n.d(t,"Acos",(function(){return Ve["b"]})),n.d(t,"Acosh",(function(){return Ve["c"]})),n.d(t,"Add",(function(){return Ve["d"]})),n.d(t,"AddN",(function(){return Ve["e"]})),n.d(t,"All",(function(){return Ve["f"]})),n.d(t,"Any",(function(){return Ve["g"]})),n.d(t,"ArgMax",(function(){return Ve["h"]})),n.d(t,"ArgMin",(function(){return Ve["i"]})),n.d(t,"Asin",(function(){return Ve["j"]})),n.d(t,"Asinh",(function(){return Ve["k"]})),n.d(t,"Atan",(function(){return Ve["l"]})),n.d(t,"Atanh",(function(){return Ve["n"]})),n.d(t,"Atan2",(function(){return Ve["m"]})),n.d(t,"AvgPool",(function(){return Ve["o"]})),n.d(t,"AvgPoolGrad",(function(){return Ve["r"]})),n.d(t,"AvgPool3D",(function(){return Ve["p"]})),n.d(t,"AvgPool3DGrad",(function(){return Ve["q"]})),n.d(t,"BatchMatMul",(function(){return Ve["s"]})),n.d(t,"BatchToSpaceND",(function(){return Ve["t"]})),n.d(t,"Bincount",(function(){return Ve["u"]})),n.d(t,"BroadcastTo",(function(){return Ve["w"]})),n.d(t,"BroadcastArgs",(function(){return Ve["v"]})),n.d(t,"Cast",(function(){return Ve["x"]})),n.d(t,"Ceil",(function(){return Ve["y"]})),n.d(t,"ClipByValue",(function(){return Ve["z"]})),n.d(t,"Complex",(function(){return Ve["A"]})),n.d(t,"ComplexAbs",(function(){return Ve["B"]})),n.d(t,"Concat",(function(){return Ve["C"]})),n.d(t,"Conv2D",(function(){return Ve["D"]})),n.d(t,"Conv2DBackpropFilter",(function(){return Ve["E"]})),n.d(t,"Conv2DBackpropInput",(function(){return Ve["F"]})),n.d(t,"Conv3D",(function(){return Ve["G"]})),n.d(t,"Conv3DBackpropFilterV2",(function(){return Ve["H"]})),n.d(t,"Conv3DBackpropInputV2",(function(){return Ve["I"]})),n.d(t,"Cos",(function(){return Ve["J"]})),n.d(t,"Cosh",(function(){return Ve["K"]})),n.d(t,"Cumsum",(function(){return Ve["M"]})),n.d(t,"CropAndResize",(function(){return Ve["L"]})),n.d(t,"DenseBincount",(function(){return Ve["N"]})),n.d(t,"DepthToSpace",(function(){return Ve["O"]})),n.d(t,"DepthwiseConv2dNative",(function(){return Ve["P"]})),n.d(t,"DepthwiseConv2dNativeBackpropFilter",(function(){return Ve["Q"]})),n.d(t,"DepthwiseConv2dNativeBackpropInput",(function(){return Ve["R"]})),n.d(t,"Diag",(function(){return Ve["S"]})),n.d(t,"Dilation2D",(function(){return Ve["T"]})),n.d(t,"Dilation2DBackpropInput",(function(){return Ve["V"]})),n.d(t,"Dilation2DBackpropFilter",(function(){return Ve["U"]})),n.d(t,"RealDiv",(function(){return Ve["mc"]})),n.d(t,"Einsum",(function(){return Ve["W"]})),n.d(t,"Elu",(function(){return Ve["X"]})),n.d(t,"EluGrad",(function(){return Ve["Y"]})),n.d(t,"Erf",(function(){return Ve["ab"]})),n.d(t,"Equal",(function(){return Ve["Z"]})),n.d(t,"Exp",(function(){return Ve["bb"]})),n.d(t,"ExpandDims",(function(){return Ve["cb"]})),n.d(t,"Expm1",(function(){return Ve["db"]})),n.d(t,"FFT",(function(){return Ve["eb"]})),n.d(t,"Fill",(function(){return Ve["fb"]})),n.d(t,"FlipLeftRight",(function(){return Ve["gb"]})),n.d(t,"Floor",(function(){return Ve["hb"]})),n.d(t,"FloorDiv",(function(){return Ve["ib"]})),n.d(t,"FusedBatchNorm",(function(){return Ve["kb"]})),n.d(t,"GatherV2",(function(){return Ve["ob"]})),n.d(t,"GatherNd",(function(){return Ve["nb"]})),n.d(t,"Greater",(function(){return Ve["pb"]})),n.d(t,"GreaterEqual",(function(){return Ve["qb"]})),n.d(t,"Identity",(function(){return Ve["sb"]})),n.d(t,"IFFT",(function(){return Ve["rb"]})),n.d(t,"Imag",(function(){return Ve["tb"]})),n.d(t,"IsFinite",(function(){return Ve["ub"]})),n.d(t,"IsInf",(function(){return Ve["vb"]})),n.d(t,"IsNan",(function(){return Ve["wb"]})),n.d(t,"LeakyRelu",(function(){return Ve["zb"]})),n.d(t,"Less",(function(){return Ve["Ab"]})),n.d(t,"LessEqual",(function(){return Ve["Bb"]})),n.d(t,"LinSpace",(function(){return Ve["Cb"]})),n.d(t,"Log",(function(){return Ve["Db"]})),n.d(t,"Log1p",(function(){return Ve["Eb"]})),n.d(t,"LogicalAnd",(function(){return Ve["Gb"]})),n.d(t,"LogicalNot",(function(){return Ve["Hb"]})),n.d(t,"LogicalOr",(function(){return Ve["Ib"]})),n.d(t,"LogSoftmax",(function(){return Ve["Fb"]})),n.d(t,"LRN",(function(){return Ve["xb"]})),n.d(t,"LRNGrad",(function(){return Ve["yb"]})),n.d(t,"Max",(function(){return Ve["Jb"]})),n.d(t,"Maximum",(function(){return Ve["Pb"]})),n.d(t,"MaxPool",(function(){return Ve["Kb"]})),n.d(t,"MaxPoolGrad",(function(){return Ve["Nb"]})),n.d(t,"MaxPool3D",(function(){return Ve["Lb"]})),n.d(t,"MaxPool3DGrad",(function(){return Ve["Mb"]})),n.d(t,"MaxPoolWithArgmax",(function(){return Ve["Ob"]})),n.d(t,"Mean",(function(){return Ve["Qb"]})),n.d(t,"Min",(function(){return Ve["Rb"]})),n.d(t,"Minimum",(function(){return Ve["Sb"]})),n.d(t,"MirrorPad",(function(){return Ve["Tb"]})),n.d(t,"Mod",(function(){return Ve["Ub"]})),n.d(t,"Multinomial",(function(){return Ve["Vb"]})),n.d(t,"Multiply",(function(){return Ve["Wb"]})),n.d(t,"Neg",(function(){return Ve["Xb"]})),n.d(t,"NotEqual",(function(){return Ve["bc"]})),n.d(t,"NonMaxSuppressionV3",(function(){return Ve["Yb"]})),n.d(t,"NonMaxSuppressionV4",(function(){return Ve["Zb"]})),n.d(t,"NonMaxSuppressionV5",(function(){return Ve["ac"]})),n.d(t,"OnesLike",(function(){return Ve["dc"]})),n.d(t,"OneHot",(function(){return Ve["cc"]})),n.d(t,"Pack",(function(){return Ve["ec"]})),n.d(t,"PadV2",(function(){return Ve["fc"]})),n.d(t,"Pool",(function(){return Ve["gc"]})),n.d(t,"Pow",(function(){return Ve["hc"]})),n.d(t,"Prelu",(function(){return Ve["ic"]})),n.d(t,"Prod",(function(){return Ve["jc"]})),n.d(t,"Range",(function(){return Ve["kc"]})),n.d(t,"Real",(function(){return Ve["lc"]})),n.d(t,"Reciprocal",(function(){return Ve["nc"]})),n.d(t,"Relu",(function(){return Ve["oc"]})),n.d(t,"Reshape",(function(){return Ve["qc"]})),n.d(t,"ResizeNearestNeighbor",(function(){return Ve["tc"]})),n.d(t,"ResizeNearestNeighborGrad",(function(){return Ve["uc"]})),n.d(t,"ResizeBilinear",(function(){return Ve["rc"]})),n.d(t,"ResizeBilinearGrad",(function(){return Ve["sc"]})),n.d(t,"Relu6",(function(){return Ve["pc"]})),n.d(t,"Reverse",(function(){return Ve["vc"]})),n.d(t,"Round",(function(){return Ve["xc"]})),n.d(t,"Rsqrt",(function(){return Ve["yc"]})),n.d(t,"ScatterNd",(function(){return Ve["zc"]})),n.d(t,"Select",(function(){return Ve["Ac"]})),n.d(t,"Selu",(function(){return Ve["Bc"]})),n.d(t,"Slice",(function(){return Ve["Gc"]})),n.d(t,"Sin",(function(){return Ve["Ec"]})),n.d(t,"Sinh",(function(){return Ve["Fc"]})),n.d(t,"Sign",(function(){return Ve["Dc"]})),n.d(t,"Sigmoid",(function(){return Ve["Cc"]})),n.d(t,"Softplus",(function(){return Ve["Ic"]})),n.d(t,"Sqrt",(function(){return Ve["Qc"]})),n.d(t,"Sum",(function(){return Ve["Zc"]})),n.d(t,"SpaceToBatchND",(function(){return Ve["Jc"]})),n.d(t,"SplitV",(function(){return Ve["Pc"]})),n.d(t,"Softmax",(function(){return Ve["Hc"]})),n.d(t,"SparseFillEmptyRows",(function(){return Ve["Kc"]})),n.d(t,"SparseReshape",(function(){return Ve["Lc"]})),n.d(t,"SparseSegmentMean",(function(){return Ve["Mc"]})),n.d(t,"SparseSegmentSum",(function(){return Ve["Nc"]})),n.d(t,"SparseToDense",(function(){return Ve["Oc"]})),n.d(t,"SquaredDifference",(function(){return Ve["Sc"]})),n.d(t,"Square",(function(){return Ve["Rc"]})),n.d(t,"StridedSlice",(function(){return Ve["Uc"]})),n.d(t,"StringNGrams",(function(){return Ve["Vc"]})),n.d(t,"StringSplit",(function(){return Ve["Wc"]})),n.d(t,"StringToHashBucketFast",(function(){return Ve["Xc"]})),n.d(t,"Sub",(function(){return Ve["Yc"]})),n.d(t,"Tan",(function(){return Ve["ad"]})),n.d(t,"Tanh",(function(){return Ve["bd"]})),n.d(t,"Tile",(function(){return Ve["cd"]})),n.d(t,"TopK",(function(){return Ve["dd"]})),n.d(t,"Transform",(function(){return Ve["ed"]})),n.d(t,"Transpose",(function(){return Ve["fd"]})),n.d(t,"Unique",(function(){return Ve["gd"]})),n.d(t,"Unpack",(function(){return Ve["hd"]})),n.d(t,"UnsortedSegmentSum",(function(){return Ve["id"]})),n.d(t,"ZerosLike",(function(){return Ve["jd"]})),n.d(t,"Step",(function(){return Ve["Tc"]})),n.d(t,"FromPixels",(function(){return Ve["jb"]})),n.d(t,"RotateWithOffset",(function(){return Ve["wc"]})),n.d(t,"_FusedMatMul",(function(){return Ve["kd"]})),n.d(t,"FusedConv2D",(function(){return Ve["lb"]})),n.d(t,"FusedDepthwiseConv2D",(function(){return Ve["mb"]}));var r={};n.r(r),n.d(r,"copyModel",(function(){return J})),n.d(r,"listModels",(function(){return Q})),n.d(r,"moveModel",(function(){return ee})),n.d(r,"removeModel",(function(){return Z})),n.d(r,"browserFiles",(function(){return be})),n.d(r,"browserHTTPRequest",(function(){return Te})),n.d(r,"concatenateArrayBuffers",(function(){return f["d"]})),n.d(r,"decodeWeights",(function(){return f["e"]})),n.d(r,"encodeWeights",(function(){return f["f"]})),n.d(r,"fromMemory",(function(){return Ae})),n.d(r,"getLoadHandlers",(function(){return x})),n.d(r,"getModelArtifactsForJSON",(function(){return f["g"]})),n.d(r,"getModelArtifactsInfoForJSON",(function(){return f["h"]})),n.d(r,"getSaveHandlers",(function(){return y})),n.d(r,"http",(function(){return Ie})),n.d(r,"isHTTPScheme",(function(){return Ne})),n.d(r,"loadWeights",(function(){return Oe})),n.d(r,"registerLoadRouter",(function(){return g})),n.d(r,"registerSaveRouter",(function(){return b})),n.d(r,"weightsLoaderFactory",(function(){return ve})),n.d(r,"withSaveHandler",(function(){return Re}));var a={};n.r(a),n.d(a,"confusionMatrix",(function(){return Be}));var s={};n.r(s),n.d(s,"fromPixelsAsync",(function(){return Ye})),n.d(s,"toPixels",(function(){return Qe})),n.d(s,"fromPixels",(function(){return Ze}));var o={};n.r(o),n.d(o,"prepareAndValidate",(function(){return Je}));var i={};n.r(i),n.d(i,"assertParamsValid",(function(){return tt})),n.d(i,"maskToAxes",(function(){return nt})),n.d(i,"computeOutShape",(function(){return rt})),n.d(i,"stridesWithElidedDims",(function(){return at})),n.d(i,"getNormalizedAxes",(function(){return it})),n.d(i,"startIndicesWithElidedDims",(function(){return ct})),n.d(i,"stopIndicesWithElidedDims",(function(){return ut})),n.d(i,"stridesForAxis",(function(){return lt})),n.d(i,"startForAxis",(function(){return dt})),n.d(i,"stopForAxis",(function(){return pt})),n.d(i,"isSliceContinous",(function(){return ht})),n.d(i,"computeFlatOffset",(function(){return ft})),n.d(i,"parseSliceParams",(function(){return mt})),n.d(i,"sliceInfo",(function(){return bt}));var c={};n.r(c),n.d(c,"Serializable",(function(){return gt})),n.d(c,"SerializationMap",(function(){return yt})),n.d(c,"registerClass",(function(){return xt}));var u={};n.r(u),n.d(u,"segOpComputeOptimalWindowSize",(function(){return zn})),n.d(u,"computeOutShape",(function(){return Wn})),n.d(u,"collectGatherOpShapeInfo",(function(){return Un}));var l={};n.r(l),n.d(l,"axesAreInnerMostDims",(function(){return Jt["b"]})),n.d(l,"combineLocations",(function(){return Jt["c"]})),n.d(l,"computeOutAndReduceShapes",(function(){return Jt["d"]})),n.d(l,"expandShapeToKeepDim",(function(){return Jt["e"]})),n.d(l,"assertAxesAreInnerMostDims",(function(){return Jt["a"]})),n.d(l,"getAxesPermutation",(function(){return Jt["f"]})),n.d(l,"getUndoAxesPermutation",(function(){return Jt["h"]})),n.d(l,"getInnerMostAxes",(function(){return Jt["g"]})),n.d(l,"getBroadcastDims",(function(){return en["b"]})),n.d(l,"getReductionAxes",(function(){return en["c"]})),n.d(l,"assertAndGetBroadcastShape",(function(){return en["a"]})),n.d(l,"assertParamsConsistent",(function(){return tn})),n.d(l,"computeOutShape",(function(){return nn})),n.d(l,"computeDilation2DInfo",(function(){return rn["d"]})),n.d(l,"computePool2DInfo",(function(){return rn["e"]})),n.d(l,"computePool3DInfo",(function(){return rn["f"]})),n.d(l,"computeConv2DInfo",(function(){return rn["a"]})),n.d(l,"computeConv3DInfo",(function(){return rn["b"]})),n.d(l,"computeDefaultPad",(function(){return rn["c"]})),n.d(l,"tupleValuesAreOne",(function(){return rn["i"]})),n.d(l,"eitherStridesOrDilationsAreOne",(function(){return rn["h"]})),n.d(l,"convertConv2DDataFormat",(function(){return rn["g"]})),n.d(l,"getFusedDyActivation",(function(){return an["c"]})),n.d(l,"getFusedBiasGradient",(function(){return an["b"]})),n.d(l,"applyActivation",(function(){return an["a"]})),n.d(l,"shouldFuse",(function(){return an["d"]})),n.d(l,"PARALLELIZE_THRESHOLD",(function(){return sn})),n.d(l,"computeOptimalWindowSize",(function(){return on})),n.d(l,"slice_util",(function(){return i})),n.d(l,"upcastType",(function(){return Ht["c"]})),n.d(l,"getImageCenter",(function(){return cn})),n.d(l,"getReshaped",(function(){return un})),n.d(l,"getPermuted",(function(){return ln})),n.d(l,"getReshapedPermuted",(function(){return dn})),n.d(l,"getSliceBeginCoords",(function(){return pn})),n.d(l,"getSliceSize",(function(){return hn})),n.d(l,"prepareAndValidate",(function(){return Je})),n.d(l,"validateUpdateShape",(function(){return et["validateUpdateShape"]})),n.d(l,"validateInput",(function(){return et["validateInput"]})),n.d(l,"calculateShapes",(function(){return et["calculateShapes"]})),n.d(l,"SELU_SCALEALPHA",(function(){return fn})),n.d(l,"SELU_SCALE",(function(){return mn})),n.d(l,"ERF_P",(function(){return bn})),n.d(l,"ERF_A1",(function(){return gn})),n.d(l,"ERF_A2",(function(){return yn})),n.d(l,"ERF_A3",(function(){return xn})),n.d(l,"ERF_A4",(function(){return On})),n.d(l,"ERF_A5",(function(){return vn})),n.d(l,"warn",(function(){return wn["b"]})),n.d(l,"log",(function(){return wn["a"]})),n.d(l,"mergeRealAndImagArrays",(function(){return kn})),n.d(l,"splitRealAndImagArrays",(function(){return jn})),n.d(l,"complexWithEvenIndex",(function(){return Sn})),n.d(l,"complexWithOddIndex",(function(){return Nn})),n.d(l,"getComplexWithIndex",(function(){return Cn})),n.d(l,"assignToTypedArray",(function(){return In})),n.d(l,"exponents",(function(){return Tn})),n.d(l,"exponent",(function(){return $n})),n.d(l,"decodeEinsumEquation",(function(){return Fn})),n.d(l,"getEinsumPermutation",(function(){return Dn})),n.d(l,"checkEinsumDimSizes",(function(){return Mn})),n.d(l,"getEinsumComputePath",(function(){return Ln})),n.d(l,"isIdentityPermutation",(function(){return Pn})),n.d(l,"prepareSplitSize",(function(){return Vn})),n.d(l,"segment_util",(function(){return u})),n.d(l,"fromUint8ToStringArray",(function(){return Gn})),n.d(l,"fromStringArrayToUint8",(function(){return Hn}));var d={};n.r(d),n.d(d,"nonMaxSuppressionV3Impl",(function(){return Kn["a"]})),n.d(d,"nonMaxSuppressionV4Impl",(function(){return Kn["b"]})),n.d(d,"nonMaxSuppressionV5Impl",(function(){return Kn["c"]})),n.d(d,"whereImpl",(function(){return Xn["a"]}));var p=n("6ae2"),h=(n("29a8"),n("b333")),f=n("350f");
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class m{constructor(){this.saveRouters=[],this.loadRouters=[]}static getInstance(){return null==m.instance&&(m.instance=new m),m.instance}static registerSaveRouter(e){m.getInstance().saveRouters.push(e)}static registerLoadRouter(e){m.getInstance().loadRouters.push(e)}static getSaveHandlers(e){return m.getHandlers(e,"save")}static getLoadHandlers(e,t){return m.getHandlers(e,"load",t)}static getHandlers(e,t,n){const r=[],a="load"===t?m.getInstance().loadRouters:m.getInstance().saveRouters;return a.forEach(t=>{const a=t(e,n);null!==a&&r.push(a)}),r}}const b=e=>m.registerSaveRouter(e),g=e=>m.registerLoadRouter(e),y=e=>m.getSaveHandlers(e),x=(e,t)=>m.getLoadHandlers(e,t)
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */,O="tensorflowjs",v=1,w="models_store",k="model_info_store";function j(){if(!Object(h["c"])().getBool("IS_BROWSER"))throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");const e="undefined"===typeof window?self:window,t=e.indexedDB||e.mozIndexedDB||e.webkitIndexedDB||e.msIndexedDB||e.shimIndexedDB;if(null==t)throw new Error("The current browser does not appear to support IndexedDB.");return t}function S(e){const t=e.result;t.createObjectStore(w,{keyPath:"modelPath"}),t.createObjectStore(k,{keyPath:"modelPath"})}class N{constructor(e){if(this.indexedDB=j(),null==e||!e)throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");this.modelPath=e}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");return this.databaseAction(this.modelPath,e)}async load(){return this.databaseAction(this.modelPath)}databaseAction(e,t){return new Promise((e,n)=>{const r=this.indexedDB.open(O,v);r.onupgradeneeded=()=>S(r),r.onsuccess=()=>{const a=r.result;if(null==t){const t=a.transaction(w,"readonly"),r=t.objectStore(w),s=r.get(this.modelPath);s.onsuccess=()=>{if(null==s.result)return a.close(),n(new Error(`Cannot find model with path '${this.modelPath}' in IndexedDB.`));e(s.result.modelArtifacts)},s.onerror=e=>(a.close(),n(s.error)),t.oncomplete=()=>a.close()}else{const r=Object(f["h"])(t),s=a.transaction(k,"readwrite");let o=s.objectStore(k);const i=o.put({modelPath:this.modelPath,modelArtifactsInfo:r});let c;i.onsuccess=()=>{c=a.transaction(w,"readwrite");const i=c.objectStore(w),u=i.put({modelPath:this.modelPath,modelArtifacts:t,modelArtifactsInfo:r});u.onsuccess=()=>e({modelArtifactsInfo:r}),u.onerror=e=>{o=s.objectStore(k);const t=o.delete(this.modelPath);t.onsuccess=()=>(a.close(),n(u.error)),t.onerror=e=>(a.close(),n(u.error))}},i.onerror=e=>(a.close(),n(i.error)),s.oncomplete=()=>{null==c?a.close():c.oncomplete=()=>a.close()}}},r.onerror=e=>n(r.error)})}}N.URL_SCHEME="indexeddb://";const C=e=>Object(h["c"])().getBool("IS_BROWSER")&&!Array.isArray(e)&&e.startsWith(N.URL_SCHEME)?I(e.slice(N.URL_SCHEME.length)):null;function I(e){return new N(e)}function T(e){return e.startsWith(N.URL_SCHEME)?e.slice(N.URL_SCHEME.length):e}m.registerSaveRouter(C),m.registerLoadRouter(C);class ${constructor(){this.indexedDB=j()}async listModels(){return new Promise((e,t)=>{const n=this.indexedDB.open(O,v);n.onupgradeneeded=()=>S(n),n.onsuccess=()=>{const r=n.result,a=r.transaction(k,"readonly"),s=a.objectStore(k),o=s.getAll();o.onsuccess=()=>{const t={};for(const e of o.result)t[e.modelPath]=e.modelArtifactsInfo;e(t)},o.onerror=e=>(r.close(),t(o.error)),a.oncomplete=()=>r.close()},n.onerror=e=>t(n.error)})}async removeModel(e){return e=T(e),new Promise((t,n)=>{const r=this.indexedDB.open(O,v);r.onupgradeneeded=()=>S(r),r.onsuccess=()=>{const a=r.result,s=a.transaction(k,"readwrite"),o=s.objectStore(k),i=o.get(e);let c;i.onsuccess=()=>{if(null==i.result)return a.close(),n(new Error(`Cannot find model with path '${e}' in IndexedDB.`));{const r=o.delete(e),s=()=>{c=a.transaction(w,"readwrite");const r=c.objectStore(w),s=r.delete(e);s.onsuccess=()=>t(i.result.modelArtifactsInfo),s.onerror=e=>n(i.error)};r.onsuccess=s,r.onerror=e=>(s(),a.close(),n(i.error))}},i.onerror=e=>(a.close(),n(i.error)),s.oncomplete=()=>{null==c?a.close():c.oncomplete=()=>a.close()}},r.onerror=e=>n(r.error)})}}var E=n("6ad5");
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const A="/",R="tensorflowjs_models",_="info",F="model_topology",D="weight_specs",M="weight_data",L="model_metadata";function P(e){return{info:[R,e,_].join(A),topology:[R,e,F].join(A),weightSpecs:[R,e,D].join(A),weightData:[R,e,M].join(A),modelMetadata:[R,e,L].join(A)}}function B(e){for(const t of Object.values(e))window.localStorage.removeItem(t)}function V(e){const t=e.split(A);if(t.length<3)throw new Error("Invalid key format: "+e);return t.slice(1,t.length-1).join(A)}function z(e){return e.startsWith(W.URL_SCHEME)?e.slice(W.URL_SCHEME.length):e}class W{constructor(e){if(!Object(h["c"])().getBool("IS_BROWSER")||"undefined"===typeof window||"undefined"===typeof window.localStorage)throw new Error("The current environment does not support local storage.");if(this.LS=window.localStorage,null==e||!e)throw new Error("For local storage, modelPath must not be null, undefined or empty.");this.modelPath=e,this.keys=P(this.modelPath)}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");{const n=JSON.stringify(e.modelTopology),r=JSON.stringify(e.weightSpecs),a=Object(f["h"])(e);try{this.LS.setItem(this.keys.info,JSON.stringify(a)),this.LS.setItem(this.keys.topology,n),this.LS.setItem(this.keys.weightSpecs,r),this.LS.setItem(this.keys.weightData,Object(f["a"])(e.weightData));const t={format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy,signature:null!=e.signature?e.signature:void 0,userDefinedMetadata:null!=e.userDefinedMetadata?e.userDefinedMetadata:void 0,modelInitializer:null!=e.modelInitializer?e.modelInitializer:void 0,trainingConfig:null!=e.trainingConfig?e.trainingConfig:void 0};return this.LS.setItem(this.keys.modelMetadata,JSON.stringify(t)),{modelArtifactsInfo:a}}catch(t){throw B(this.keys),new Error(`Failed to save model '${this.modelPath}' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes=${a.modelTopologyBytes}, weightSpecsBytes=${a.weightSpecsBytes}, weightDataBytes=${a.weightDataBytes}.`)}}}async load(){const e=JSON.parse(this.LS.getItem(this.keys.info));if(null==e)throw new Error(`In local storage, there is no model with name '${this.modelPath}'`);if("JSON"!==e.modelTopologyType)throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");const t={},n=JSON.parse(this.LS.getItem(this.keys.topology));if(null==n)throw new Error(`In local storage, the topology of model '${this.modelPath}' is missing.`);t.modelTopology=n;const r=JSON.parse(this.LS.getItem(this.keys.weightSpecs));if(null==r)throw new Error(`In local storage, the weight specs of model '${this.modelPath}' are missing.`);t.weightSpecs=r;const a=this.LS.getItem(this.keys.modelMetadata);if(null!=a){const e=JSON.parse(a);t.format=e.format,t.generatedBy=e.generatedBy,t.convertedBy=e.convertedBy,null!=e.signature&&(t.signature=e.signature),null!=e.userDefinedMetadata&&(t.userDefinedMetadata=e.userDefinedMetadata),null!=e.modelInitializer&&(t.modelInitializer=e.modelInitializer),null!=e.trainingConfig&&(t.trainingConfig=e.trainingConfig)}const s=this.LS.getItem(this.keys.weightData);if(null==s)throw new Error(`In local storage, the binary weight values of model '${this.modelPath}' are missing.`);return t.weightData=Object(f["b"])(s),t}}W.URL_SCHEME="localstorage://";const U=e=>Object(h["c"])().getBool("IS_BROWSER")&&!Array.isArray(e)&&e.startsWith(W.URL_SCHEME)?G(e.slice(W.URL_SCHEME.length)):null;function G(e){return new W(e)}m.registerSaveRouter(U),m.registerLoadRouter(U);class H{constructor(){Object(E["b"])(Object(h["c"])().getBool("IS_BROWSER"),()=>"Current environment is not a web browser"),Object(E["b"])("undefined"===typeof window||"undefined"!==typeof window.localStorage,()=>"Current browser does not appear to support localStorage"),this.LS=window.localStorage}async listModels(){const e={},t=R+A,n=A+_;for(let r=0;r<this.LS.length;++r){const a=this.LS.key(r);if(a.startsWith(t)&&a.endsWith(n)){const t=V(a);e[t]=JSON.parse(this.LS.getItem(a))}}return e}async removeModel(e){e=z(e);const t=P(e);if(null==this.LS.getItem(t.info))throw new Error(`Cannot find model at path '${e}'`);const n=JSON.parse(this.LS.getItem(t.info));return B(t),n}}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const q="://";class K{constructor(){this.managers={}}static getInstance(){return null==K.instance&&(K.instance=new K),K.instance}static registerManager(e,t){Object(E["b"])(null!=e,()=>"scheme must not be undefined or null."),e.endsWith(q)&&(e=e.slice(0,e.indexOf(q))),Object(E["b"])(e.length>0,()=>"scheme must not be an empty string.");const n=K.getInstance();Object(E["b"])(null==n.managers[e],()=>`A model store manager is already registered for scheme '${e}'.`),n.managers[e]=t}static getManager(e){const t=this.getInstance().managers[e];if(null==t)throw new Error(`Cannot find model manager for scheme '${e}'`);return t}static getSchemes(){return Object.keys(this.getInstance().managers)}}function X(e){if(-1===e.indexOf(q))throw new Error("The url string provided does not contain a scheme. Supported schemes are: "+K.getSchemes().join(","));return{scheme:e.split(q)[0],path:e.split(q)[1]}}async function Y(e,t,n=!1){Object(E["b"])(e!==t,()=>`Old path and new path are the same: '${e}'`);const r=m.getLoadHandlers(e);Object(E["b"])(r.length>0,()=>`Copying failed because no load handler is found for source URL ${e}.`),Object(E["b"])(r.length<2,()=>`Copying failed because more than one (${r.length}) load handlers for source URL ${e}.`);const a=r[0],s=m.getSaveHandlers(t);Object(E["b"])(s.length>0,()=>`Copying failed because no save handler is found for destination URL ${t}.`),Object(E["b"])(s.length<2,()=>`Copying failed because more than one (${r.length}) save handlers for destination URL ${t}.`);const o=s[0],i=X(e).scheme,c=X(e).path,u=i===X(e).scheme,l=await a.load();n&&u&&await K.getManager(i).removeModel(c);const d=await o.save(l);return n&&!u&&await K.getManager(i).removeModel(c),d.modelArtifactsInfo}async function Q(){const e=K.getSchemes(),t={};for(const n of e){const e=await K.getManager(n).listModels();for(const r in e){const a=n+q+r;t[a]=e[r]}}return t}async function Z(e){const t=X(e),n=K.getManager(t.scheme);return n.removeModel(t.path)}async function J(e,t){const n=!1;return Y(e,t,n)}async function ee(e,t){const n=!0;return Y(e,t,n)}
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class te{fetch(e,t){return fetch(e,t)}now(){return performance.now()}encode(e,t){if("utf-8"!==t&&"utf8"!==t)throw new Error("Browser's encoder only supports utf-8, but got "+t);return null==this.textEncoder&&(this.textEncoder=new TextEncoder),this.textEncoder.encode(e)}decode(e,t){return new TextDecoder(t).decode(e)}}if(Object(h["c"])().get("IS_BROWSER")){Object(h["c"])().setPlatform("browser",new te);try{K.registerManager(W.URL_SCHEME,new H)}catch(Qn){}try{K.registerManager(N.URL_SCHEME,new $)}catch(Qn){}}n("4b05");var ne=n("043e"),re=n("deb3"),ae=n("f0a9"),se=n("7568"),oe=n("34d7");
/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
Object(p["b"])();const ie={buffer:ne["a"],cast:re["a"],clone:ae["a"],print:se["a"]};Object(oe["e"])(ie);
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const ce="model",ue=".json",le=".weights.bin";function de(e){return new Promise(e=>setTimeout(e)).then(e)}class pe{constructor(e){if(!Object(h["c"])().getBool("IS_BROWSER"))throw new Error("browserDownloads() cannot proceed because the current environment is not a browser.");e.startsWith(pe.URL_SCHEME)&&(e=e.slice(pe.URL_SCHEME.length)),null!=e&&0!==e.length||(e=ce),this.modelJsonFileName=e+ue,this.weightDataFileName=e+le}async save(e){if("undefined"===typeof document)throw new Error("Browser downloads are not supported in this environment since `document` is not present");const t=window.URL.createObjectURL(new Blob([e.weightData],{type:"application/octet-stream"}));if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserDownloads.save() does not support saving model topology in binary formats yet.");{const n=[{paths:["./"+this.weightDataFileName],weights:e.weightSpecs}],r=Object(f["i"])(e,n),a=window.URL.createObjectURL(new Blob([JSON.stringify(r)],{type:"application/json"})),s=null==this.modelJsonAnchor?document.createElement("a"):this.modelJsonAnchor;if(s.download=this.modelJsonFileName,s.href=a,await de(()=>s.dispatchEvent(new MouseEvent("click"))),null!=e.weightData){const e=null==this.weightDataAnchor?document.createElement("a"):this.weightDataAnchor;e.download=this.weightDataFileName,e.href=t,await de(()=>e.dispatchEvent(new MouseEvent("click")))}return{modelArtifactsInfo:Object(f["h"])(e)}}}}pe.URL_SCHEME="downloads://";class he{constructor(e){if(null==e||e.length<1)throw new Error("When calling browserFiles, at least 1 file is required, but received "+e);this.jsonFile=e[0],this.weightsFiles=e.slice(1)}async load(){return new Promise((e,t)=>{const n=new FileReader;n.onload=n=>{const r=JSON.parse(n.target.result),a=r.modelTopology;if(null==a)return void t(new Error("modelTopology field is missing from file "+this.jsonFile.name));const s=r.weightsManifest;if(null==s)return void t(new Error("weightManifest field is missing from file "+this.jsonFile.name));if(0===this.weightsFiles.length)return void e({modelTopology:a});const o=Object(f["g"])(r,e=>this.loadWeights(e));e(o)},n.onerror=e=>t(`Failed to read model topology and weights manifest JSON from file '${this.jsonFile.name}'. BrowserFiles supports loading Keras-style tf.Model artifacts only.`),n.readAsText(this.jsonFile)})}loadWeights(e){const t=[],n=[];for(const s of e)t.push(...s.weights),n.push(...s.paths);const r=this.checkManifestAndWeightFiles(e),a=n.map(e=>this.loadWeightsFile(e,r[e]));return Promise.all(a).then(e=>[t,Object(f["d"])(e)])}loadWeightsFile(e,t){return new Promise((n,r)=>{const a=new FileReader;a.onload=e=>{const t=e.target.result;n(t)},a.onerror=t=>r(`Failed to weights data from file of path '${e}'.`),a.readAsArrayBuffer(t)})}checkManifestAndWeightFiles(e){const t=[],n=this.weightsFiles.map(e=>Object(f["c"])(e.name)),r={};for(const a of e)a.paths.forEach(e=>{const a=Object(f["c"])(e);if(-1!==t.indexOf(a))throw new Error(`Duplicate file basename found in weights manifest: '${a}'`);if(t.push(a),-1===n.indexOf(a))throw new Error(`Weight file with basename '${a}' is not provided.`);r[e]=this.weightsFiles[n.indexOf(a)]});if(t.length!==this.weightsFiles.length)throw new Error(`Mismatch in the number of files in weights manifest (${t.length}) and the number of weight files provided (${this.weightsFiles.length}).`);return r}}const fe=e=>Object(h["c"])().getBool("IS_BROWSER")&&!Array.isArray(e)&&e.startsWith(pe.URL_SCHEME)?me(e.slice(pe.URL_SCHEME.length)):null;function me(e="model"){return new pe(e)}function be(e){return new he(e)}
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ge(e,t,n,r){o(e),n=null==n?0:n,r=null==r?1:r,i(n,r);let a=0;const s=s=>(s.then(s=>{const o=n+ ++a/e.length*(r-n);return t(o),s}),s);function o(e){Object(E["b"])(null!=e&&Array.isArray(e)&&e.length>0,()=>"promises must be a none empty array")}function i(e,t){Object(E["b"])(e>=0&&e<=1,()=>"Progress fraction must be in range [0, 1], but got startFraction "+e),Object(E["b"])(t>=0&&t<=1,()=>"Progress fraction must be in range [0, 1], but got endFraction "+t),Object(E["b"])(t>=e,()=>`startFraction must be no more than endFraction, but got startFraction ${e} and endFraction `+t)}return Promise.all(e.map(s))}m.registerSaveRouter(fe);var ye=n("9847");
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function xe(e,t){null==t&&(t={});const n=null==t.fetchFunc?Object(h["c"])().platform.fetch:t.fetchFunc,r=e.map(e=>n(e,t.requestInit,{isBinary:!0})),a=0,s=.5,o=null==t.onProgress?await Promise.all(r):await ge(r,t.onProgress,a,s),i=o.map(e=>e.arrayBuffer()),c=.5,u=1,l=null==t.onProgress?await Promise.all(i):await ge(i,t.onProgress,c,u);return l}async function Oe(e,t="",n,r){const a=e=>xe(e,{requestInit:r}),s=ve(a);return s(e,t,n)}function ve(e){return async(t,n="",r)=>{const a=t.map(()=>!1),s={},o=null!=r?r.map(()=>!1):[],i=[];if(t.forEach((e,t)=>{let n=0;e.weights.forEach(e=>{const c="quantization"in e?e.quantization.dtype:e.dtype,u=ye["a"][c]*E["O"](e.shape),l=()=>{a[t]=!0,null==s[t]&&(s[t]=[]),s[t].push({manifestEntry:e,groupOffset:n,sizeBytes:u})};null!=r?r.forEach((t,n)=>{t===e.name&&(l(),o[n]=!0)}):l(),i.push(e.name),n+=u})}),!o.every(e=>e)){const e=r.filter((e,t)=>!o[t]);throw new Error("Could not find weights in manifest with names: "+e.join(", ")+". \nManifest JSON has weights with names: "+i.join(", ")+".")}const c=a.reduce((e,t,n)=>(t&&e.push(n),e),[]),u=[];c.forEach(e=>{t[e].paths.forEach(e=>{const t=n+(n.endsWith("/")?"":"/")+e;u.push(t)})});const l=await e(u),d={};let p=0;return c.forEach(e=>{const n=t[e].paths.length;let r=0;for(let t=0;t<n;t++)r+=l[p+t].byteLength;const a=new ArrayBuffer(r),o=new Uint8Array(a);let i=0;for(let t=0;t<n;t++){const e=new Uint8Array(l[p+t]);o.set(e,i),i+=e.byteLength}const c=s[e];c.forEach(e=>{const t=a.slice(e.groupOffset,e.groupOffset+e.sizeBytes),n=Object(f["e"])(t,[e.manifestEntry]);for(const r in n)d[r]=n[r]}),p+=n}),d}}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const we="application/octet-stream",ke="application/json";class je{constructor(e,t){if(this.DEFAULT_METHOD="POST",null==t&&(t={}),this.weightPathPrefix=t.weightPathPrefix,this.onProgress=t.onProgress,this.weightUrlConverter=t.weightUrlConverter,null!=t.fetchFunc?(Object(E["b"])("function"===typeof t.fetchFunc,()=>"Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)"),this.fetch=t.fetchFunc):this.fetch=Object(h["c"])().platform.fetch,Object(E["b"])(null!=e&&e.length>0,()=>"URL path for http must not be null, undefined or empty."),Array.isArray(e)&&Object(E["b"])(2===e.length,()=>`URL paths for http must have a length of 2, (actual length is ${e.length}).`),this.path=e,null!=t.requestInit&&null!=t.requestInit.body)throw new Error("requestInit is expected to have no pre-existing body, but has one.");this.requestInit=t.requestInit||{}}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");const t=Object.assign({method:this.DEFAULT_METHOD},this.requestInit);t.body=new FormData;const n=[{paths:["./model.weights.bin"],weights:e.weightSpecs}],r=Object(f["i"])(e,n);t.body.append("model.json",new Blob([JSON.stringify(r)],{type:ke}),"model.json"),null!=e.weightData&&t.body.append("model.weights.bin",new Blob([e.weightData],{type:we}),"model.weights.bin");const a=await this.fetch(this.path,t);if(a.ok)return{modelArtifactsInfo:Object(f["h"])(e),responses:[a]};throw new Error("BrowserHTTPRequest.save() failed due to HTTP response status "+a.status+".")}async load(){const e=await this.fetch(this.path,this.requestInit);if(!e.ok)throw new Error(`Request to ${this.path} failed with status code `+e.status+". Please verify this URL points to the model JSON of the model to load.");let t;try{t=await e.json()}catch(a){let e=`Failed to parse model JSON of response from ${this.path}.`;throw this.path.endsWith(".pb")?e+=" Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository.":e+=" Please make sure the server is serving valid JSON for this request.",new Error(e)}const n=t.modelTopology,r=t.weightsManifest;if(null==n&&null==r)throw new Error(`The JSON from HTTP path ${this.path} contains neither model topology or manifest for weights.`);return Object(f["g"])(t,e=>this.loadWeights(e))}async loadWeights(e){const t=Array.isArray(this.path)?this.path[1]:this.path,[n,r]=Se(t),a=this.weightPathPrefix||n,s=[];for(const u of e)s.push(...u.weights);const o=[],i=[];for(const u of e)for(const e of u.paths)null!=this.weightUrlConverter?i.push(this.weightUrlConverter(e)):o.push(a+e+r);this.weightUrlConverter&&o.push(...await Promise.all(i));const c=await xe(o,{requestInit:this.requestInit,fetchFunc:this.fetch,onProgress:this.onProgress});return[s,Object(f["d"])(c)]}}function Se(e){const t=e.lastIndexOf("/"),n=e.lastIndexOf("?"),r=e.substring(0,t),a=n>t?e.substring(n):"";return[r+"/",a]}function Ne(e){return null!=e.match(je.URL_SCHEME_REGEX)}je.URL_SCHEME_REGEX=/^https?:\/\//;const Ce=(e,t)=>{if("undefined"===typeof fetch&&(null==t||null==t.fetchFunc))return null;{let n=!0;if(n=Array.isArray(e)?e.every(e=>Ne(e)):Ne(e),n)return Ie(e,t)}return null};function Ie(e,t){return new je(e,t)}function Te(e,t){return Ie(e,t)}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */m.registerSaveRouter(Ce),m.registerLoadRouter(Ce);class $e{constructor(e){this.modelArtifacts=e}async load(){return this.modelArtifacts}}class Ee{constructor(e){this.saveHandler=e}async save(e){return this.saveHandler(e)}}function Ae(e,t,n,r){if(1===arguments.length){const t=null!=e.modelTopology||null!=e.weightSpecs;return t?new $e(e):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new $e({modelTopology:e}))}return console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new $e({modelTopology:e,weightSpecs:t,weightData:n,trainingConfig:r})}function Re(e){return new Ee(e)}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var _e=n("a3f7"),Fe=n("487b"),De=n("e22c"),Me=n("54ef"),Le=n("c912");
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Pe(e,t,n){const r=Object(_e["a"])(e,"labels","confusionMatrix"),a=Object(_e["a"])(t,"predictions","confusionMatrix");E["b"](null==n||n>0&&Number.isInteger(n),()=>"If provided, numClasses must be a positive integer, but got "+n),E["b"](1===r.rank,()=>"Expected the rank of labels to be 1, but got "+r.rank),E["b"](1===a.rank,()=>"Expected the rank of predictions to be 1, but got "+a.rank),E["b"](r.shape[0]===a.shape[0],()=>`Mismatch in the number of examples: ${r.shape[0]} vs. ${a.shape[0]}. Labels and predictions should have the same number of elements.`),E["b"](n>0&&Number.isInteger(n),()=>"numClasses is required to be a positive integer, but got "+n);const s=Object(De["a"])(Object(re["a"])(r,"int32"),n),o=Object(De["a"])(Object(re["a"])(a,"int32"),n),i=Object(Le["a"])(s),c=Object(Fe["a"])(i,o);return Object(re["a"])(c,"int32")}const Be=Object(Me["b"])({confusionMatrix_:Pe});
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var Ve=n("c05b"),ze=n("73b8"),We=n("05bb");
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
let Ue;function Ge(e,t=3){if(t>4)throw new Error("Cannot construct Tensor with more than 4 channels from pixels.");if(null==e)throw new Error("pixels passed to tf.browser.fromPixels() can not be null");let n=!1,r=!1,a=!1,s=!1,o=!1,i=!1;if(e.data instanceof Uint8Array)n=!0;else if("undefined"!==typeof ImageData&&e instanceof ImageData)r=!0;else if("undefined"!==typeof HTMLVideoElement&&e instanceof HTMLVideoElement)a=!0;else if("undefined"!==typeof HTMLImageElement&&e instanceof HTMLImageElement)s=!0;else if(null!=e.getContext)o=!0;else{if(!("undefined"!==typeof ImageBitmap&&e instanceof ImageBitmap))throw new Error("pixels passed to tf.browser.fromPixels() must be either an HTMLVideoElement, HTMLImageElement, HTMLCanvasElement, ImageData in browser, or OffscreenCanvas, ImageData in webworker or {data: Uint32Array, width: number, height: number}, but was "+e.constructor.name);i=!0}if(a){const t=2;if(a&&e.readyState<t)throw new Error("The video element has not loaded data yet. Please wait for `loadeddata` event on the <video> element.")}const c=Object(ze["c"])(Ve["jb"],p["a"].backendName);if(null!=c){const n={pixels:e},r={numChannels:t};return p["a"].runKernel(Ve["jb"],n,r)}const[u,l]=a?[e.videoWidth,e.videoHeight]:[e.width,e.height];let d,h;if(o?d=e.getContext("2d").getImageData(0,0,u,l).data:r||n?d=e.data:(s||a||i)&&(null==Ue&&(Ue=document.createElement("canvas").getContext("2d")),Ue.canvas.width=u,Ue.canvas.height=l,Ue.drawImage(e,0,0,u,l),d=Ue.getImageData(0,0,u,l).data),4===t)h=new Int32Array(d);else{const e=u*l;h=new Int32Array(e*t);for(let n=0;n<e;n++)for(let e=0;e<t;++e)h[n*t+e]=d[4*n+e]}const f=[l,u,t];return Object(We["a"])(h,f,"int32")}function He(e){return null!=e&&e.data instanceof Uint8Array}function qe(){return"undefined"!==typeof window&&"undefined"!==typeof ImageBitmap&&window.hasOwnProperty("createImageBitmap")}function Ke(e){return null!=e&&0!==e.width&&0!==e.height}function Xe(e){return qe()&&!(e instanceof ImageBitmap)&&Ke(e)&&!He(e)}async function Ye(e,t=3){let n=null;if(Object(h["c"])().getBool("WRAP_TO_IMAGEBITMAP")&&Xe(e)){let t;try{t=await createImageBitmap(e,{premultiplyAlpha:"none"})}catch(r){t=null}n=null!=t&&t.width===e.width&&t.height===e.height?t:e}else n=e;return Ge(n,t)}async function Qe(e,t){let n=Object(_e["a"])(e,"img","toPixels");if(!(e instanceof oe["a"])){const e=n;n=Object(re["a"])(e,"int32"),e.dispose()}if(2!==n.rank&&3!==n.rank)throw new Error(`toPixels only supports rank 2 or 3 tensors, got rank ${n.rank}.`);const[r,a]=n.shape.slice(0,2),s=2===n.rank?1:n.shape[2];if(s>4||2===s)throw new Error("toPixels only supports depth of size 1, 3 or 4 but got "+s);if("float32"!==n.dtype&&"int32"!==n.dtype)throw new Error(`Unsupported type for toPixels: ${n.dtype}. Please use float32 or int32 tensors.`);const o=await n.data(),i="float32"===n.dtype?255:1,c=new Uint8ClampedArray(a*r*4);for(let u=0;u<r*a;++u){const e=[0,0,0,255];for(let r=0;r<s;r++){const t=o[u*s+r];if("float32"===n.dtype){if(t<0||t>1)throw new Error(`Tensor values for a float32 Tensor must be in the range [0 - 1] but encountered ${t}.`)}else if("int32"===n.dtype&&(t<0||t>255))throw new Error(`Tensor values for a int32 Tensor must be in the range [0 - 255] but encountered ${t}.`);1===s?(e[0]=t*i,e[1]=t*i,e[2]=t*i):e[r]=t*i}const t=4*u;c[t+0]=Math.round(e[0]),c[t+1]=Math.round(e[1]),c[t+2]=Math.round(e[2]),c[t+3]=Math.round(e[3])}if(null!=t){t.width=a,t.height=r;const e=t.getContext("2d"),n=new ImageData(c,a,r);e.putImageData(n,0,0)}return n!==e&&n.dispose(),c}const Ze=Object(Me["b"])({fromPixels_:Ge});function Je(e,t){const n=e.shape.length,r=t.shape.length;if(n<1)throw new Error(`tf.gatherND() expects the input to be rank 1 or higher, but the rank was ${n}.`);if(r<1)throw new Error(`tf.gatherND() expects the indices to be rank 1 or higher, but the rank was ${r}.`);if("int32"!==t.dtype)throw new Error(`tf.gatherND() expects the indices to be int32 type, but the dtype was ${t.dtype}.`);if(t.shape[r-1]>n)throw new Error(`index innermost dimension length must be <= tensor rank; saw: ${t.shape[r-1]} vs. ${n}`);if(0===Object(E["O"])(e.shape))throw new Error(`Requested more than 0 entries, but input is empty. Input shape: ${e.shape}.`);const a=t.shape,s=a[a.length-1];let o=1;for(let d=0;d<a.length-1;++d)o*=a[d];const i=e.shape,c=a.slice();c.pop();let u=1;for(let d=s;d<n;++d)u*=i[d],c.push(i[d]);const l=[...Object(E["j"])(e.shape).map(e=>e/u),1].slice(0,s);return[c,o,u,l]}var et=n("a34f");
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tt(e,t,n){const r=e.shape.length;E["b"](r===t.length,()=>`Error in slice${r}D: Length of begin ${t} must match the rank of the array (${r}).`),E["b"](r===n.length,()=>`Error in slice${r}D: Length of size ${n} must match the rank of the array (${r}).`);for(let a=0;a<r;++a)E["b"](t[a]+n[a]<=e.shape[a],()=>`Error in slice${r}D: begin[${a}] + size[${a}] (${t[a]+n[a]}) would overflow input.shape[${a}] (${e.shape[a]})`)}function nt(e){const t=[];let n=0;while(e>0)1&e&&t.push(n),e/=2,n++;return t}function rt(e,t,n){const r=[];for(let a=0;a<e.length;a++)r[a]=Math.ceil((t[a]-e[a])/n[a]);return r}function at(e,t,n,r){const a=[...e];for(let s=a.length;s<r.length;s++)a.push(1);for(let s=0;s<n;s++)0===s?a[t]=1:(a.splice(t,0,1),a.pop());return a}function st(e,t,n){return n<=e?n:n-(t-1)}function ot(e,t){const n=[];for(let r=0;r<e;r++)n.push(t+r);return n}function it(e,t,n,r,a,s,o,i,c){const u=e.length;let l=new Array(u),d=new Array(u),p=new Array(u);if(t.length&&n>0){const c=t[0],u=n+1;l=ct(o,c,u,r,e),d=ut(i,c,u,a,e),p=at(s,c,u,e)}else for(let h=0;h<u;h++)l[h]=dt(o,r,s,e,h,c),d[h]=pt(i,a,s,e,h,c),p[h]=lt(s,h,c);return{begin:l,end:d,strides:p}}function ct(e,t,n,r,a){const s=[...a],o=ot(n,t);for(let i=0;i<s.length;i++)if(o.indexOf(i)>-1)s[i]=0;else{const a=st(t,n,i);let o=r[a];e&1<<a&&(o=0),s[i]=o}return s}function ut(e,t,n,r,a){const s=[...a],o=ot(n,t);for(let i=0;i<s.length;i++)if(o.indexOf(i)>-1)s[i]=Number.MAX_SAFE_INTEGER;else{const a=st(t,n,i);let o=r[a];e&1<<a&&(o=Number.MAX_SAFE_INTEGER),s[i]=o}for(let i=0;i<s.length;i++){const e=a[i];s[i]<0&&(s[i]+=e),s[i]=E["i"](0,s[i],a[i])}return s}function lt(e,t,n){let r=e[t];return(n&1<<t||null==r)&&(r=1),r}function dt(e,t,n,r,a,s){let o=t[a];const i=n[a]||1;(e&1<<a||s&1<<a||null==o)&&(o=i>0?Number.MIN_SAFE_INTEGER:Number.MAX_SAFE_INTEGER);const c=r[a];return o<0&&(o+=c),o=E["i"](0,o,c-1),o}function pt(e,t,n,r,a,s){let o=t[a];const i=n[a]||1;(e&1<<a||s&1<<a||null==o)&&(o=i>0?Number.MAX_SAFE_INTEGER:Number.MIN_SAFE_INTEGER);const c=r[a];return o<0&&(o+=c),o=i>0?E["i"](0,o,c):E["i"](-1,o,c-1),o}function ht(e,t,n){let r=n.length;for(let a=0;a<n.length;a++)if(n[a]>1){r=a;break}for(let a=r+1;a<n.length;a++)if(t[a]>0||n[a]!==e[a])return!1;return!0}function ft(e,t){let n=e.length>0?e[e.length-1]:1;for(let r=0;r<e.length-1;r++)n+=e[r]*t[r];return n}function mt(e,t,n){let r;const a=e.shape.length;let s;return r="number"===typeof t?[t,...new Array(a-1).fill(0)]:t.length<a?t.concat(new Array(a-t.length).fill(0)):t.slice(),r.forEach(e=>{E["b"](-1!==e,()=>"slice() does not support negative begin indexing.")}),s=null==n?new Array(a).fill(-1):"number"===typeof n?[n,...new Array(a-1).fill(-1)]:n.length<a?n.concat(new Array(a-n.length).fill(-1)):n,s=s.map((t,n)=>t>=0?t:(E["b"](-1===t,()=>`Negative size values should be exactly -1 but got ${t} for the slice() size at index ${n}.`),e.shape[n]-r[n])),[r,s]}function bt(e,t,n,r,a,s,o,i,c){let u=t.slice(),l=n.slice(),d=r;null==r&&(d=new Array(u.length));const p=nt(o);if(p.length>1)throw new Error("Multiple ellipses in slice is not allowed.");if(0!==o&&0!==i)throw new Error("Using both ellipsisMask and newAxisMask is not yet supported.");if(0!==o&&0!==c)throw new Error("Using both ellipsisMask and shrinkAxisMask is not yet supported.");const h=e.length-u.length,f=nt(i),m=e.slice();f.forEach(e=>{u[e]=0,l[e]=1,m.splice(e,0,1)});const{begin:b,end:g,strides:y}=it(m,p,h,u,l,d,a,s,o);u=b,l=g,d=y;const x=nt(c);x.forEach(e=>{l[e]=u[e]+1,d[e]=1});const O=rt(u,l,d),v=O.filter((e,t)=>-1===x.indexOf(t)),w=d.every(e=>1===e);return{nonStrided:w,$begin:u,$end:l,$strides:d,size:O,newShape:m,outShape:v}}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class gt{getClassName(){return this.constructor.className}static fromConfig(e,t){return new e(t)}}class yt{constructor(){this.classNameMap={}}static getMap(){return null==yt.instance&&(yt.instance=new yt),yt.instance}static register(e){yt.getMap().classNameMap[e.className]=[e,e.fromConfig]}}function xt(e){Object(E["b"])(null!=e.className,()=>"Class being registered does not have the static className property defined."),Object(E["b"])("string"===typeof e.className,()=>"className is required to be a string, but got type "+typeof e.className),Object(E["b"])(e.className.length>0,()=>"Class being registered has an empty-string as its className, which is disallowed."),yt.register(e)}var Ot=n("76c2"),vt=n("d565"),wt=n("eb7e");
/** @license See the LICENSE file. */
const kt="3.9.0";var jt=n("c04e4"),St=n("9117"),Nt=n("c77c"),Ct=n("a5aa"),It=n("163a"),Tt=n("93b2"),$t=n("a09b"),Et=n("538e"),At=n("015f");
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class Rt extends gt{minimize(e,t=!1,n){const{value:r,grads:a}=this.computeGradients(e,n);if(null!=n){const e=n.map(e=>({name:e.name,tensor:a[e.name]}));this.applyGradients(e)}else this.applyGradients(a);return Object(jt["d"])(a),t?r:(r.dispose(),null)}get iterations(){return null==this.iterations_&&(this.iterations_=0),this.iterations_}incrementIterations(){this.iterations_=this.iterations+1}computeGradients(e,t){return Object(Et["f"])(e,t)}dispose(){null!=this.iterations_&&Object(jt["d"])(this.iterations_)}async saveIterations(){return null==this.iterations_&&(this.iterations_=0),{name:"iter",tensor:Object(At["a"])(this.iterations_,"int32")}}async getWeights(){throw new Error("getWeights() is not implemented for this optimizer yet.")}async setWeights(e){throw new Error("setWeights() is not implemented for this optimizer class "+this.getClassName())}async extractIterations(e){return this.iterations_=(await e[0].tensor.data())[0],e.slice(1)}}Object.defineProperty(Rt,Symbol.hasInstance,{value:e=>null!=e.minimize&&null!=e.computeGradients&&null!=e.applyGradients});
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class _t extends Rt{constructor(e,t,n=null){super(),this.learningRate=e,this.rho=t,this.epsilon=n,this.accumulatedGrads=[],this.accumulatedUpdates=[],null==n&&(this.epsilon=p["a"].backend.epsilon())}applyGradients(e){const t=Array.isArray(e)?e.map(e=>e.name):Object.keys(e);t.forEach((t,n)=>{const r=p["a"].registeredVariables[t],a=!1;null==this.accumulatedGrads[n]&&(this.accumulatedGrads[n]={originalName:t+"/accum_grad",variable:Object(jt["t"])(()=>Object($t["a"])(r).variable(a))}),null==this.accumulatedUpdates[n]&&(this.accumulatedUpdates[n]={originalName:t+"/accum_var",variable:Object(jt["t"])(()=>Object($t["a"])(r).variable(a))});const s=Array.isArray(e)?e[n].tensor:e[t];if(null==s)return;const o=this.accumulatedGrads[n].variable,i=this.accumulatedUpdates[n].variable;Object(jt["t"])(()=>{const e=Object(St["a"])(Object(Ct["a"])(o,this.rho),Object(Ct["a"])(Object(Tt["a"])(s),1-this.rho)),t=Object(Ct["a"])(Object(Nt["a"])(Object(It["a"])(Object(St["a"])(i,this.epsilon)),Object(It["a"])(Object(St["a"])(o,this.epsilon))),s),n=Object(St["a"])(Object(Ct["a"])(i,this.rho),Object(Ct["a"])(Object(Tt["a"])(t),1-this.rho));o.assign(e),i.assign(n);const a=Object(St["a"])(Object(Ct["a"])(t,-this.learningRate),r);r.assign(a)})}),this.incrementIterations()}dispose(){null!=this.accumulatedUpdates&&(Object(jt["d"])(this.accumulatedGrads.map(e=>e.variable)),Object(jt["d"])(this.accumulatedUpdates.map(e=>e.variable)))}async getWeights(){const e=[...this.accumulatedGrads,...this.accumulatedUpdates];return[await this.saveIterations()].concat(e.map(e=>({name:e.originalName,tensor:e.variable})))}async setWeights(e){e=await this.extractIterations(e);const t=e.length/2,n=!1;this.accumulatedGrads=e.slice(0,t).map(e=>({originalName:e.name,variable:e.tensor.variable(n)})),this.accumulatedUpdates=e.slice(t,2*t).map(e=>({originalName:e.name,variable:e.tensor.variable(n)}))}getConfig(){return{learningRate:this.learningRate,rho:this.rho,epsilon:this.epsilon}}static fromConfig(e,t){return new e(t["learningRate"],t["rho"],t["epsilon"])}}_t.className="Adadelta",xt(_t);var Ft=n("46b8");
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Dt extends Rt{constructor(e,t=.1){super(),this.learningRate=e,this.initialAccumulatorValue=t,this.accumulatedGrads=[]}applyGradients(e){const t=Array.isArray(e)?e.map(e=>e.name):Object.keys(e);t.forEach((t,n)=>{const r=p["a"].registeredVariables[t];if(null==this.accumulatedGrads[n]){const e=!1;this.accumulatedGrads[n]={originalName:t+"/accumulator",variable:Object(jt["t"])(()=>Object(Ft["a"])(r.shape,this.initialAccumulatorValue).variable(e))}}const a=Array.isArray(e)?e[n].tensor:e[t];if(null==a)return;const s=this.accumulatedGrads[n].variable;Object(jt["t"])(()=>{const e=Object(St["a"])(s,Object(Tt["a"])(a));s.assign(e);const t=Object(St["a"])(Object(Ct["a"])(Object(Nt["a"])(a,Object(It["a"])(Object(St["a"])(e,p["a"].backend.epsilon()))),-this.learningRate),r);r.assign(t)})}),this.incrementIterations()}dispose(){null!=this.accumulatedGrads&&Object(jt["d"])(this.accumulatedGrads.map(e=>e.variable))}async getWeights(){return[await this.saveIterations()].concat(this.accumulatedGrads.map(e=>({name:e.originalName,tensor:e.variable})))}async setWeights(e){e=await this.extractIterations(e);const t=!1;this.accumulatedGrads=e.map(e=>({originalName:e.name,variable:e.tensor.variable(t)}))}getConfig(){return{learningRate:this.learningRate,initialAccumulatorValue:this.initialAccumulatorValue}}static fromConfig(e,t){return new e(t["learningRate"],t["initialAccumulatorValue"])}}Dt.className="Adagrad",xt(Dt);var Mt=n("c9f1"),Lt=n("a009");
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class Pt extends Rt{constructor(e,t,n,r=null){super(),this.learningRate=e,this.beta1=t,this.beta2=n,this.epsilon=r,this.accumulatedFirstMoment=[],this.accumulatedSecondMoment=[],Object(jt["t"])(()=>{this.accBeta1=Object(At["a"])(t).variable(),this.accBeta2=Object(At["a"])(n).variable()}),null==r&&(this.epsilon=p["a"].backend.epsilon())}applyGradients(e){const t=Array.isArray(e)?e.map(e=>e.name):Object.keys(e);Object(jt["t"])(()=>{const n=Object(Lt["a"])(1,this.accBeta1),r=Object(Lt["a"])(1,this.accBeta2);t.forEach((t,a)=>{const s=p["a"].registeredVariables[t],o=!1;null==this.accumulatedFirstMoment[a]&&(this.accumulatedFirstMoment[a]={originalName:t+"/m",variable:Object(jt["t"])(()=>Object($t["a"])(s).variable(o))}),null==this.accumulatedSecondMoment[a]&&(this.accumulatedSecondMoment[a]={originalName:t+"/v",variable:Object(jt["t"])(()=>Object($t["a"])(s).variable(o))});const i=Array.isArray(e)?e[a].tensor:e[t];if(null==i)return;const c=this.accumulatedFirstMoment[a].variable,u=this.accumulatedSecondMoment[a].variable,l=Object(St["a"])(Object(Ct["a"])(c,this.beta1),Object(Ct["a"])(i,1-this.beta1)),d=Object(St["a"])(Object(Ct["a"])(u,this.beta2),Object(Ct["a"])(Object(Tt["a"])(i),1-this.beta2)),h=Object(Nt["a"])(l,n),f=Object(Nt["a"])(d,r);c.assign(l),u.assign(d);const m=Object(St["a"])(Object(Ct["a"])(Object(Nt["a"])(h,Object(St["a"])(Object(It["a"])(f),this.epsilon)),-this.learningRate),s);s.assign(m)}),this.accBeta1.assign(Object(Ct["a"])(this.accBeta1,this.beta1)),this.accBeta2.assign(Object(Ct["a"])(this.accBeta2,this.beta2))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.accBeta2.dispose(),null!=this.accumulatedFirstMoment&&Object(jt["d"])(this.accumulatedFirstMoment.map(e=>e.variable)),null!=this.accumulatedSecondMoment&&Object(jt["d"])(this.accumulatedSecondMoment.map(e=>e.variable))}async getWeights(){const e=[...this.accumulatedFirstMoment,...this.accumulatedSecondMoment];return[await this.saveIterations()].concat(e.map(e=>({name:e.originalName,tensor:e.variable})))}async setWeights(e){e=await this.extractIterations(e),Object(jt["t"])(()=>{this.accBeta1.assign(Object(Mt["a"])(this.beta1,this.iterations_+1)),this.accBeta2.assign(Object(Mt["a"])(this.beta2,this.iterations_+1))});const t=e.length/2,n=!1;this.accumulatedFirstMoment=e.slice(0,t).map(e=>({originalName:e.name,variable:e.tensor.variable(n)})),this.accumulatedSecondMoment=e.slice(t,2*t).map(e=>({originalName:e.name,variable:e.tensor.variable(n)}))}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon}}static fromConfig(e,t){return new e(t["learningRate"],t["beta1"],t["beta2"],t["epsilon"])}}Pt.className="Adam",xt(Pt);var Bt=n("8ae0"),Vt=n("09f4");
/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/
class zt extends Rt{constructor(e,t,n,r=null,a=0){super(),this.learningRate=e,this.beta1=t,this.beta2=n,this.epsilon=r,this.decay=a,this.accumulatedFirstMoment=[],this.accumulatedWeightedInfNorm=[],Object(jt["t"])(()=>{this.iteration=Object(At["a"])(0).variable(),this.accBeta1=Object(At["a"])(t).variable()}),null==r&&(this.epsilon=p["a"].backend.epsilon())}applyGradients(e){const t=Array.isArray(e)?e.map(e=>e.name):Object.keys(e);Object(jt["t"])(()=>{const n=Object(Lt["a"])(1,this.accBeta1),r=Object(Nt["a"])(-this.learningRate,Object(St["a"])(Object(Ct["a"])(this.iteration,this.decay),1));t.forEach((t,a)=>{const s=p["a"].registeredVariables[t],o=!1;null==this.accumulatedFirstMoment[a]&&(this.accumulatedFirstMoment[a]={originalName:t+"/m",variable:Object($t["a"])(s).variable(o)}),null==this.accumulatedWeightedInfNorm[a]&&(this.accumulatedWeightedInfNorm[a]={originalName:t+"/v",variable:Object($t["a"])(s).variable(o)});const i=Array.isArray(e)?e[a].tensor:e[t];if(null==i)return;const c=this.accumulatedFirstMoment[a].variable,u=this.accumulatedWeightedInfNorm[a].variable,l=Object(St["a"])(Object(Ct["a"])(c,this.beta1),Object(Ct["a"])(i,1-this.beta1)),d=Object(Ct["a"])(u,this.beta2),h=Object(Bt["a"])(i),f=Object(Vt["a"])(d,h);c.assign(l),u.assign(f);const m=Object(St["a"])(Object(Ct["a"])(Object(Nt["a"])(r,n),Object(Nt["a"])(l,Object(St["a"])(f,this.epsilon))),s);s.assign(m)}),this.iteration.assign(Object(St["a"])(this.iteration,1)),this.accBeta1.assign(Object(Ct["a"])(this.accBeta1,this.beta1))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.iteration.dispose(),null!=this.accumulatedFirstMoment&&Object(jt["d"])(this.accumulatedFirstMoment.map(e=>e.variable)),null!=this.accumulatedWeightedInfNorm&&Object(jt["d"])(this.accumulatedWeightedInfNorm.map(e=>e.variable))}async getWeights(){throw new Error("getWeights() is not implemented for Adamax yet.")}async setWeights(e){throw new Error("setWeights() is not implemented for Adamax yet.")}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon,decay:this.decay}}static fromConfig(e,t){return new e(t["learningRate"],t["beta1"],t["beta2"],t["epsilon"],t["decay"])}}zt.className="Adamax",xt(zt);
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class Wt extends Rt{constructor(e){super(),this.learningRate=e,this.setLearningRate(e)}applyGradients(e){const t=Array.isArray(e)?e.map(e=>e.name):Object.keys(e);t.forEach((t,n)=>{const r=Array.isArray(e)?e[n].tensor:e[t];if(null==r)return;const a=p["a"].registeredVariables[t];Object(jt["t"])(()=>{const e=Object(St["a"])(Object(Ct["a"])(this.c,r),a);a.assign(e)})}),this.incrementIterations()}setLearningRate(e){this.learningRate=e,null!=this.c&&this.c.dispose(),this.c=Object(jt["l"])(Object(At["a"])(-e))}dispose(){this.c.dispose()}async getWeights(){return[await this.saveIterations()]}async setWeights(e){if(e=await this.extractIterations(e),0!==e.length)throw new Error("SGD optimizer does not have settable weights.")}getConfig(){return{learningRate:this.learningRate}}static fromConfig(e,t){return new e(t["learningRate"])}}Wt.className="SGD",xt(Wt);
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class Ut extends Wt{constructor(e,t,n=!1){super(e),this.learningRate=e,this.momentum=t,this.useNesterov=n,this.accumulations=[],this.m=Object(At["a"])(this.momentum)}applyGradients(e){const t=Array.isArray(e)?e.map(e=>e.name):Object.keys(e);t.forEach((t,n)=>{const r=p["a"].registeredVariables[t];if(null==this.accumulations[n]){const e=!1;this.accumulations[n]={originalName:t+"/momentum",variable:Object(jt["t"])(()=>Object($t["a"])(r).variable(e))}}const a=this.accumulations[n].variable,s=Array.isArray(e)?e[n].tensor:e[t];null!=s&&Object(jt["t"])(()=>{let e;const t=Object(St["a"])(Object(Ct["a"])(this.m,a),s);e=this.useNesterov?Object(St["a"])(Object(Ct["a"])(this.c,Object(St["a"])(s,Object(Ct["a"])(t,this.m))),r):Object(St["a"])(Object(Ct["a"])(this.c,t),r),a.assign(t),r.assign(e)})}),this.incrementIterations()}dispose(){this.m.dispose(),null!=this.accumulations&&Object(jt["d"])(this.accumulations.map(e=>e.variable))}setMomentum(e){this.momentum=e}async getWeights(){return[await this.saveIterations()].concat(this.accumulations.map(e=>({name:e.originalName,tensor:e.variable})))}async setWeights(e){e=await this.extractIterations(e);const t=!1;this.accumulations=e.map(e=>({originalName:e.name,variable:e.tensor.variable(t)}))}getConfig(){return{learningRate:this.learningRate,momentum:this.momentum,useNesterov:this.useNesterov}}static fromConfig(e,t){return new e(t["learningRate"],t["momentum"],t["useNesterov"])}}Ut.className="Momentum",xt(Ut);
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class Gt extends Rt{constructor(e,t=.9,n=0,r=null,a=!1){if(super(),this.learningRate=e,this.decay=t,this.momentum=n,this.epsilon=r,this.accumulatedMeanSquares=[],this.accumulatedMoments=[],this.accumulatedMeanGrads=[],this.centered=a,null==r&&(this.epsilon=p["a"].backend.epsilon()),null==e)throw new Error("learningRate for RMSPropOptimizer must be defined.")}applyGradients(e){const t=Array.isArray(e)?e.map(e=>e.name):Object.keys(e);t.forEach((t,n)=>{const r=p["a"].registeredVariables[t],a=!1;null==this.accumulatedMeanSquares[n]&&(this.accumulatedMeanSquares[n]={originalName:t+"/rms",variable:Object(jt["t"])(()=>Object($t["a"])(r).variable(a))}),null==this.accumulatedMoments[n]&&(this.accumulatedMoments[n]={originalName:t+"/momentum",variable:Object(jt["t"])(()=>Object($t["a"])(r).variable(a))}),null==this.accumulatedMeanGrads[n]&&this.centered&&(this.accumulatedMeanGrads[n]={originalName:t+"/mg",variable:Object(jt["t"])(()=>Object($t["a"])(r).variable(a))});const s=Array.isArray(e)?e[n].tensor:e[t];if(null==s)return;const o=this.accumulatedMeanSquares[n].variable,i=this.accumulatedMoments[n].variable;Object(jt["t"])(()=>{const e=Object(St["a"])(Object(Ct["a"])(o,this.decay),Object(Ct["a"])(Object(Tt["a"])(s),1-this.decay));if(this.centered){const t=this.accumulatedMeanGrads[n].variable,a=Object(St["a"])(Object(Ct["a"])(t,this.decay),Object(Ct["a"])(s,1-this.decay)),c=Object(Nt["a"])(Object(Ct["a"])(s,this.learningRate),Object(It["a"])(Object(Lt["a"])(e,Object(St["a"])(Object(Tt["a"])(a),this.epsilon)))),u=Object(St["a"])(Object(Ct["a"])(i,this.momentum),c);o.assign(e),t.assign(a),i.assign(u);const l=Object(Lt["a"])(r,u);r.assign(l)}else{const e=Object(St["a"])(Object(Ct["a"])(o,this.decay),Object(Ct["a"])(Object(Tt["a"])(s),1-this.decay)),t=Object(St["a"])(Object(Ct["a"])(i,this.momentum),Object(Nt["a"])(Object(Ct["a"])(s,this.learningRate),Object(It["a"])(Object(St["a"])(e,this.epsilon))));o.assign(e),i.assign(t);const n=Object(Lt["a"])(r,t);r.assign(n)}})}),this.incrementIterations()}dispose(){null!=this.accumulatedMeanSquares&&Object(jt["d"])(this.accumulatedMeanSquares.map(e=>e.variable)),null!=this.accumulatedMeanGrads&&this.centered&&Object(jt["d"])(this.accumulatedMeanGrads.map(e=>e.variable)),null!=this.accumulatedMoments&&Object(jt["d"])(this.accumulatedMoments.map(e=>e.variable))}async getWeights(){const e=[...this.accumulatedMeanSquares,...this.accumulatedMoments];return this.centered&&e.push(...this.accumulatedMeanGrads),[await this.saveIterations()].concat(e.map(e=>({name:e.originalName,tensor:e.variable})))}async setWeights(e){e=await this.extractIterations(e);const t=this.centered?e.length/3:e.length/2,n=!1;this.accumulatedMeanSquares=e.slice(0,t).map(e=>({originalName:e.name,variable:e.tensor.variable(n)})),this.accumulatedMoments=e.slice(t,2*t).map(e=>({originalName:e.name,variable:e.tensor.variable(n)})),this.centered&&(this.accumulatedMeanGrads=e.slice(2*t,3*t).map(e=>({originalName:e.name,variable:e.tensor.variable(n)})))}getConfig(){return{learningRate:this.learningRate,decay:this.decay,momentum:this.momentum,epsilon:this.epsilon,centered:this.centered}}static fromConfig(e,t){return new e(t["learningRate"],t["decay"],t["momentum"],t["epsilon"],t["centered"])}}Gt.className="RMSProp",xt(Gt);var Ht=n("23bf"),qt=n("132b"),Kt=n("57e0");
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class Xt{static sgd(e){return new Wt(e)}static momentum(e,t,n=!1){return new Ut(e,t,n)}static rmsprop(e,t=.9,n=0,r=null,a=!1){return new Gt(e,t,n,r,a)}static adam(e=.001,t=.9,n=.999,r=null){return new Pt(e,t,n,r)}static adadelta(e=.001,t=.95,n=null){return new _t(e,t,n)}static adamax(e=.002,t=.9,n=.999,r=null,a=0){return new zt(e,t,n,r,a)}static adagrad(e,t=.1){return new Dt(e,t)}}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Yt={sgd:Xt.sgd,momentum:Xt.momentum,adadelta:Xt.adadelta,adagrad:Xt.adagrad,rmsprop:Xt.rmsprop,adamax:Xt.adamax,adam:Xt.adam},Qt=(()=>"undefined"!==typeof requestAnimationFrame?requestAnimationFrame:"undefined"!==typeof setImmediate?setImmediate:e=>e())();
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Zt(){return new Promise(e=>Qt(()=>e()))}var Jt=n("36e5"),en=n("526f");
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function tn(e,t){const n=e[0].length;e.forEach((e,t)=>{E["b"](e.length===n,()=>`Error in concat${n}D: rank of tensors[${t}] must be the same as the rank of the rest (${n})`)}),E["b"](t>=0&&t<n,()=>`Error in concat${n}D: axis must be between 0 and ${n-1}.`);const r=e[0];e.forEach((e,a)=>{for(let s=0;s<n;s++)E["b"](s===t||e[s]===r[s],()=>`Error in concat${n}D: Shape of tensors[${a}] (${e}) does not match the shape of the rest (${r}) along the non-concatenated axis ${a}.`)})}function nn(e,t){const n=e[0].slice();for(let r=1;r<e.length;r++)n[t]+=e[r][t];return n}var rn=n("b818"),an=n("4749");
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const sn=30;function on(e){return e<=sn?e:Object(E["G"])(e,Math.floor(Math.sqrt(e)))}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cn(e,t,n){const r=n*("number"===typeof e?e:e[0]),a=t*("number"===typeof e?e:e[1]);return[r,a]}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function un(e,t,n,r=!0){let a=[];if(r)a=a.concat(t.slice(0)),a.push(e[0]/n),a=a.concat(e.slice(1));else{a=a.concat(e[0]);const n=t.length;for(let r=0;r<n;++r)a=a.concat([e[r+1]/t[r],t[r]]);a=a.concat(e.slice(n+1))}return a}function ln(e,t,n=!0){const r=[];if(n){r.push(t);for(let n=t+1;n<e;++n)n<=2*t?(r.push(n),r.push(n-(t+1))):r.push(n)}else{const n=[],a=[];for(let r=1;r<e;++r)r>=2*t+1||r%2===1?a.push(r):n.push(r);r.push(...n),r.push(0),r.push(...a)}return r}function dn(e,t,n,r=!0){const a=[];r?a.push(e[0]/n):a.push(e[0]*n);for(let s=1;s<e.length;++s)s<=t.length?r?a.push(t[s-1]*e[s]):a.push(e[s]/t[s-1]):a.push(e[s]);return a}function pn(e,t){const n=[0];for(let r=0;r<t;++r)n.push(e[r][0]);return n}function hn(e,t,n){const r=e.slice(0,1);for(let a=0;a<n;++a)r.push(e[a+1]-t[a][0]-t[a][1]);return r}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const fn=1.7580993408473768,mn=1.0507009873554805,bn=.3275911,gn=.254829592,yn=-.284496736,xn=1.421413741,On=-1.453152027,vn=1.061405429;var wn=n("b294");
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kn(e,t){if(e.length!==t.length)throw new Error(`Cannot merge real and imag arrays of different lengths. real:${e.length}, imag: ${t.length}.`);const n=new Float32Array(2*e.length);for(let r=0;r<n.length;r+=2)n[r]=e[r/2],n[r+1]=t[r/2];return n}function jn(e){const t=new Float32Array(e.length/2),n=new Float32Array(e.length/2);for(let r=0;r<e.length;r+=2)t[r/2]=e[r],n[r/2]=e[r+1];return{real:t,imag:n}}function Sn(e){const t=Math.ceil(e.length/4),n=new Float32Array(t),r=new Float32Array(t);for(let a=0;a<e.length;a+=4)n[Math.floor(a/4)]=e[a],r[Math.floor(a/4)]=e[a+1];return{real:n,imag:r}}function Nn(e){const t=Math.floor(e.length/4),n=new Float32Array(t),r=new Float32Array(t);for(let a=2;a<e.length;a+=4)n[Math.floor(a/4)]=e[a],r[Math.floor(a/4)]=e[a+1];return{real:n,imag:r}}function Cn(e,t){const n=e[2*t],r=e[2*t+1];return{real:n,imag:r}}function In(e,t,n,r){e[2*r]=t,e[2*r+1]=n}function Tn(e,t){const n=new Float32Array(e/2),r=new Float32Array(e/2);for(let a=0;a<Math.ceil(e/2);a++){const s=(t?2:-2)*Math.PI*(a/e);n[a]=Math.cos(s),r[a]=Math.sin(s)}return{real:n,imag:r}}function $n(e,t,n){const r=(n?2:-2)*Math.PI*(e/t),a=Math.cos(r),s=Math.sin(r);return{real:a,imag:s}}
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const En="->",An=/->/g,Rn=",",_n="...";function Fn(e,t){e=e.replace(/\s/g,"");const n=(e.length-e.replace(An,"").length)/En.length;if(n<1)throw new Error("Equations without an arrow are not supported.");if(n>1)throw new Error(`Equation must contain exactly one arrow ("${En}").`);const[r,a]=e.split(En);Object(E["b"])(-1===r.indexOf(_n),()=>`The ellipsis notation ("${_n}") is not supported yet.`);const s=r.split(Rn),o=s.length;if(t!==o)throw new Error(`Expected ${o} input tensors, received ${t}`);if(o>2)throw new Error("Support for more than 2 input tensors is not implemented yet.");const i=[];for(let p=0;p<a.length;++p){const e=a[p];if(!s.some(t=>-1!==t.indexOf(e)))throw new Error(`Output subscripts contain the label ${e} not present in the input subscripts.`);-1===i.indexOf(e)&&i.push(e)}for(let p=0;p<r.length;++p){const e=r[p];-1===i.indexOf(e)&&e!==Rn&&i.push(e)}const c=new Array(s.length);for(let p=0;p<o;++p){if(new Set(s[p].split("")).size!==s[p].length)throw new Error(`Found duplicate axes in input component ${s[p]}. Support for duplicate axes in input is not implemented yet.`);c[p]=[];for(let e=0;e<s[p].length;++e)c[p].push(i.indexOf(s[p][e]))}const u=i.length,l=a.length,d=[];for(let p=l;p<u;++p)d.push(p);return{allDims:i,summedDims:d,idDims:c}}function Dn(e,t){let n=new Array(e);n.fill(-1);for(let a=0;a<t.length;++a)n[t[a]]=a;const r=[];for(let a=0;a<e;++a)-1===n[a]&&r.push(a);return n=n.filter(e=>-1!==e),{permutationIndices:n,expandDims:r}}function Mn(e,t,n){const r=new Array(e);for(let a=0;a<n.length;++a){const e=n[a].shape;for(let n=0;n<t[a].length;++n)void 0===r[t[a][n]]?r[t[a][n]]=e[n]:Object(E["b"])(r[t[a][n]]===e[n],()=>`Expected dimension ${r[t[a][n]]} at axis ${n} of input shaped ${JSON.stringify(e)}, but got dimension `+e[n])}}function Ln(e,t){const n=e,r=[];let a=0;0===e.length&&n.push(-1),a=e.length+1;for(let o=0;o<a;++o)r.push([]);const s=[];for(let o=0;o<n.length;++o){const e=n[o],a=Bn(t,e);for(const t of a)-1===s.indexOf(t)&&(r[o].push(t),s.push(t))}return{path:n,steps:r}}function Pn(e){return e.every((e,t)=>e===t)}function Bn(e,t){const n=[];for(let r=0;r<e.length;++r)0!==e[r].length&&-1===e[r].indexOf(t)&&-1!==t||n.push(r);return n}function Vn(e,t,n=0){let r=[];if("number"===typeof t)Object(E["b"])(e.shape[n]%t===0,()=>"Number of splits must evenly divide the axis."),r=new Array(t).fill(e.shape[n]/t);else{const a=t.reduce((e,t)=>(-1===t&&(e+=1),e),0);Object(E["b"])(a<=1,()=>"There should be only one negative value in split array.");const s=t.indexOf(-1);if(-1!==s){const r=t.reduce((e,t)=>t>0?e+t:e);t[s]=e.shape[n]-r}Object(E["b"])(e.shape[n]===t.reduce((e,t)=>e+t),()=>"The sum of sizes must match the size of the axis dimension."),r=t}return r}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zn(e,t){let n,r=!1;e<=sn?(n=e,r=!0):n=Object(E["G"])(e,Math.floor(Math.sqrt(e)));while(!r)n>t||n===e?r=!0:n=Object(E["G"])(e,n+1);return n}function Wn(e,t,n){const r=[],a=e.length;for(let s=0;s<a;s++)s!==t?r.push(e[s]):r.push(n);return r}function Un(e,t,n,r){const a=t.shape.length,s=e.shape.length;if(0!==r&&(r<-a||r>a))throw new Error(`Expect batchDims in the range of [-${a}, ${a}], but got ${r}`);if(r<0&&(r+=a),r>s)throw new Error(`batchDims (${r}) must be less than rank(x) (\n    ${s}).`);if(n<r)throw new Error(`batchDims (${r}) must be less than or equal to axis (${n}).`);for(let d=0;d<r;++d)if(e.shape[d]!==t.shape[d])throw new Error(`x.shape[${d}]: ${e.shape[d]} should be equal to indices.shape[${d}]: ${t.shape[d]}.`);const o=e.shape[n],i=[];let c=1,u=1,l=1;for(let d=0;d<r;++d)i.push(e.shape[d]),c*=e.shape[d];for(let d=r;d<n;d++)i.push(e.shape[d]),u*=e.shape[d];for(let d=r;d<a;d++)i.push(t.shape[d]);for(let d=n+1;d<s;d++)i.push(e.shape[d]),l*=e.shape[d];return{batchSize:c,sliceSize:l,outerSize:u,dimSize:o,outputShape:i}}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Gn(e){try{return e.map(e=>Object(wt["decodeString"])(e))}catch(Qn){throw new Error("Failed to decode encoded string bytes into utf-8, error: "+Qn)}}function Hn(e){return e.map(e=>Object(wt["encodeString"])(e))}var qn=n("7ed6"),Kn=n("8389"),Xn=n("0280"),Yn=n("8b87")},ffb3:function(e,t,n){"use strict";n.d(t,"a",(function(){return c}));var r=n("6ae2"),a=n("c05b"),s=n("a3f7"),o=n("54ef");
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function i(e){const t=Object(s["a"])(e,"x","sigmoid"),n={x:t};return r["a"].runKernel(a["Cc"],n)}const c=Object(o["b"])({sigmoid_:i})}}]);
//# sourceMappingURL=chunk-775a2954.664761fe.js.map